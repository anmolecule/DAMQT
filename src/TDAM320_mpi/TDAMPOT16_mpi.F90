!> @file TDAMPOT15_mpi.F90

!> @author Jaime Fernandez Rico, Rafael Lopez, Ignacio Ema, Guillermo Ramirez
!> @copyright  Copyright 2013-2018, Jaime Fernandez Rico, Rafael Lopez, Ignacio Ema, Guillermo Ramirez
! 
!> @details This file is part of DAM320.
! 
!>  DAM320 is free software: you can redistribute it and/or modify
!>  it under the terms of the GNU General Public License as published by
!>  the Free Software Foundation, either version 3 of the License, or
!>  (at your option) any later version.
! 
!>  DAM320 is distributed in the hope that it will be useful,
!>  but WITHOUT ANY WARRANTY; without even the implied warranty of
!>  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!>  GNU General Public License for more details.
! 
!>  You should have received a copy of the GNU General Public License
!>  along with DAM320.  If not, see <http://www.gnu.org/licenses/>.
!
!------------------------------------------------------------------------
!
!> Program for tabulation of the electrostatic potential from the representation of the molecular density performed with
!! DAM320
!
!> Parallel version with MPI
!
!> Version of August 2014
!
  subroutine PREDAMPOT_mpi
    USE MPI
    USE DAM320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    USE DAMPOT320_T
    USE PARALELO_T
    implicit none
    integer(KINT) :: i, ia, ierr, ipoint, j, nbasis
    real(KREAL) :: aux

    abort = 0
    abortroot = 0
    geomthr = 1.d-10		! Geometry threshold: two points at a distance lower than geomthr are considered to be the coincident
    longoutput = .false.	! If .true. a more detailed output is given
    lmaxrep = lmaxi			! highest "l" in the expansion of the potential
    umbrlargo = 1.d-9		! Threshold for determining the short-range radius

    if (myrank .eq. 0 .and. .not. lexact) write(iout,"('Potential from expansion of the density: lmaxrep = ', i3)") lmaxrep
    call constapot		!	Computes auxiliary constants

    call leedamqtpot		!	Reads file _2016.damqt and _2016.dmqtv (generated by DAM2016)
    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
            call error(1,'Stop')
    endif
    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    if (myrank .eq. 0) then
        if (ldengz) then	! restores files back to their original gzipped status
            call system ("gzip "//trim(projectname)//".den")
        endif
        if (lgbsgz) then
            inquire(file=trim(projectname)//".ggbs", exist=lgbsgz, iostat=ierr)
            if (ierr .eq. 0 .and. lgbsgz) then
                call system ("gzip "//trim(projectname)//".ggbs")
            else
                call system ("gzip "//trim(projectname)//".sgbs")
            endif
        endif
    endif

#ifdef DBLPRCGRID
    if (myrank .eq. 0) then
        write(iout,"('Grid generated in double precision')")
        write(iout,"('WARNING! This grid will not be compatible with gOpenMol')")
    endif
#endif

    allocate (ra2l1((lmaxrep+1)**2), ra2l1inv((lmaxrep+1)**2), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating ra2l1 and ra2l1inv in processor ',i3)") myrank
        abort = 1
    endif
    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
        call error(1,'Stop')
    endif
    return
    END	


! #define DBLPRCGRID	! Uncomment this line  if double precision grid is wanted
!> @details Initiates the process of MESP evaluation
  subroutine DAMPOT_mpi(vtot,drvxtot,drvytot,drvztot,dxxtot,dxytot,dxztot,dyytot,dyztot,dzztot,x,y,z)
    USE MPI
    USE DAM320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    USE DAMPOT320_T
    USE PARALELO_T
    implicit none
    integer(KINT) :: i, ia, ierr, ipoint, j, nbasis
    real(KREAL) :: aux, drvx, drvxtot, drvy, drvytot, drvz, drvztot
    real(KREAL) :: dxx, dxxtot, dxy, dxytot, dxz, dxztot, dyy,dyytot, dyz, dyztot, dzz, dzztot
    real(KREAL) :: ve, vetot, vn, vntot, vtot, vtotia, x, xmax, xmin, xyzmax, xyzmin, y, ymax, ymin, z, zmax, zmin
    if (lderiv2) lgradient = .true.
    vntot = cero
    vetot = cero
    vtot = cero
    drvxtot = cero
    drvytot = cero
    drvztot = cero
    dxxtot = cero
    dxytot = cero
    dxztot = cero
    dyytot = cero
    dyztot = cero
    dzztot = cero
    do ia = 1, ncen
        call submesp(ia, x, y, z, vn, ve, vtotia, drvx, drvy, drvz, dxx, dxy, dxz, dyy, dyz, dzz)
        drvxtot = drvxtot + drvx
        drvytot = drvytot + drvy
        drvztot = drvztot + drvz
        dxxtot = dxxtot + dxx
        dxytot = dxytot + dxy
        dxztot = dxztot + dxz
        dyytot = dyytot + dyy
        dyztot = dyztot + dyz
        dzztot = dzztot + dzz
        vntot = vntot + vn
        vetot = vetot + ve
        vtot = vtot + vtotia
    enddo
    return
    end
!**********************************************************************
!    subroutine consta
!
!	Computes and stores auxiliary constants
!		re(i) = dfloat(i)
!		ri(i) = uno / dfloat(i)
!		fact(i) = dfloat(i!)
!		facti(i) = uno / dfloat(i!)
!		facts(i) = dfloat((i+1/2)!)
!		ind(i) = i*(i+1)/2
!    	ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m) 
!			/ (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
!
!**********************************************************************
!> details Deals with constants
  subroutine constapot
    USE DAM320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    USE DAMPOT320_T
    USE PARALELO_T
    implicit none
    integer(KINT) :: i, ierr, ikt, k1, k12, l, l1, l1l1, l2, l2l2, lm, lmtot, m, m1, m1a, m2, m2a, md, ms
    real(KREAL) :: aux, ss, sd
    integer(KINT), parameter :: mxlcofpot = mxl*(mxl+3)/2, mxkcofpot = mxlcofpot*(mxlcofpot+3)/2
!	auxiliary parameters and functions
    pi = acos(-uno)
    raizpi = sqrt(pi)
    re(0) = cero
    ri(0) = 1.d300
    dosl1(0) = uno
    dosl1i(0) = uno
    do i = 1, mxreal
        re(i) = re(i-1) + uno        ! dfloat(i)
        re(-i) = -re(i)
        ri(i) = uno / re(i)       	! uno / dfloat(i)
        ri(-i) = -ri(i)
        dosl1(i) = re(i) + re(i) + uno	! dfloat(iÃ¬)
        dosl1(-i) = -re(i) - re(i) + uno
        dosl1i(i) = uno / dosl1(i)		! dfloat( 1/(i+i+1) )
        dosl1i(-i) = uno / dosl1(-i)
    enddo
    fact(0) = uno
    facti(0) = uno
    facts(-1) = raizpi
    facts(0) = facts(-1) * umed
    do i = 1, mxfact
        fact(i) = fact(i-1) * re(i)   		!  i!
        facts(i) = facts(i-1) * re(i+i+1) * umed	! (i+1/2)!
        facti(i) = uno / fact(i)     		!  uno / i!
    enddo
    umedpow(0) = uno							!
    do i = 1, mxlexp							!
        umedpow(i) = umedpow(i-1) * umed			! 1 / 2^i
    enddo
    ind(0) = 0
    do i = 1, mxind
        ind(i) = ind(i-1) + i         !  i*(i+1)/2
    enddo
    root(0) = cero
    do i = 1, mxroot
        root(i) = sqrt(re(i))        !  sqrt(i)
        rooti(i) = uno / root(i)     !  uno / sqrt(i)
    enddo
    lm = 0
    do l = 0, mxbin
        do m = 0, l
            lm = lm + 1
            bin(lm) = fact(l) * facti(m) * facti(l-m)
        end do
    end do
!    ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m) / (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
    ang(1) = umed / raizpi
    lm = 1
    do l = 1, mxangl
        lm = lm + 1
        ang(lm) = ang(1) * sqrt(re(2*l+1))
        aux = ang(lm) * raiz2
        do m = 1, l
            lm = lm + 1
            aux = aux / sqrt(re(l-m+1)*re(l+m))
            ang(lm) = aux
        enddo
    enddo
!     Tabulates the coefficients for the decomposition of products
!     of two functions depending on phi (sin (m*phi), cos (m*phi))
!     into functions of the same type
    do m2 = -mxemes, mxemes
        do m1 = -mxemes, mxemes
            call emes ( m1, m2, ms, md, ss, sd)
            msv(m1,m2) = ms
            mdv(m1,m2) = md
            ssv(m1,m2) = ss
            sdv(m1,m2) = sd
        enddo
    enddo
!	Coefficients for the decomposition of products of regular spherical harmonics into
!	regular spherical harmonics
    allocate(app(0:2*mxl+1,0:mxkcofpot), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating app in processor ',i3)") myrank
        abort = 1
        return
    endif
    if (longoutput) write(iout,"('Size of app   = ', i15, ' bytes')") size(app)
    allocate(bpp(0:2*mxl+1,0:mxkcofpot), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating bpp in processor ',i3)") myrank
        abort = 1
        return
    endif
    if (longoutput) write(iout,"('Size of bpp   = ', i15, ' bytes')") size(bpp)
    call acofpot
    call bcofpot
!	Tabulates some auxiliary indices for locating the previous coefficients
    do l2 = 0,mxl
        do l1 = 0,mxl
            do m2 = -l2, l2
                do m1 = -l1, l1
                    l1l1 = ind(l1)
                    l2l2 = ind(l2)
                    m1a = abs(m1)
                    m2a = abs(m2)
                    if ( l1.eq.l2 ) then
                        k1 = l1l1 + max(m1a,m2a)
                        k12 = ind(k1) + l1l1 + min(m1a,m2a)
                    elseif (l1.gt.l2) then
                        k1 = l1l1 + m1a
                        k12 = ind(k1) + l2l2 + m2a
                    else
                        k1 = l2l2 + m2a
                        k12 = ind(k1) + l1l1 + m1a
                    endif
                    indk12(l1*(l1+1)+m1+1,l2*(l2+1)+m2+1) = k12
                end do
            end do
        end do
    end do
    return
    end
!
!   *******************************************************************
!> @details required by constapot
  subroutine acofpot
    USE DAM320_T
    USE DAM320_CONST_T
    implicit none
    integer(KINT) :: k1, k2, k20, k200, kk, kk0, kk00, l, lp, m, m1, mp, n
    real(KREAL) :: aux, bux
    app = cero
!
!   starting elements app(00,lm)(n) = delta(l,n)
!
    k1 = 0
    do l = 0 , mxl
        do m = 0 , l
            kk = ind(k1)
            app(l,kk) = uno
            k1 = k1 + 1
        enddo
    enddo
!
!   elements app(lm,m'm')(n)
!
    do mp = 1 , mxl
        k2 = ind(mp) + mp
        k20 = ind(mp-1) + mp-1
        do l = mp , mxl
            if ( l.eq.mp ) then
                m1 = mp
            else
                m1 = 0
            endif
            do m = m1 , l
                k1 = ind(l) + m
                kk = ind(k1) + k2
                kk0 = ind(k1) + k20
                do n = l-mp , l+mp , 2
                    if ( n.ge.m+mp) then
                        app(n,kk) = (2*mp-1) * ( app(n-1,kk0) * ri(n+n-1) - app(n+1,kk0) * ri(n+n+3) )
                    endif
                enddo
            enddo
        enddo
    enddo
!
!   elements app(lm,l'm')(n)
!
    do mp = 0 , mxl
        k200 = 0
        do lp = mp+1 , mxl
            k2 = ind(lp) + mp
            k20 = ind(lp-1) + mp
            if ( lp.gt.mp+1 ) k200 = ind(lp-2) + mp
            do l = lp , mxl
                if ( l.eq.lp ) then
                    m1 = mp
                else
                    m1 = 0
                endif
                do m = m1 , l
                    k1 = ind(l) + m
                    kk = ind(k1) + k2
                    kk0 = ind(k1) + k20
                    kk00 = ind(k1) + k200
                    do n = l-lp , l+lp , 2
                        if ( n.ge.m+mp) then
                            aux = app(n+1,kk0) * re(n+m+mp+1) * dosl1i(n+1)
                            if ( n.gt.m+mp ) aux = aux + app(n-1,kk0) * re(n-m-mp) * dosl1i(n-1)
                            aux = aux * dosl1(lp-1)
                            if ( lp.gt.mp+1 ) aux = aux - re(lp+mp-1) * app(n,kk00)
                            app(n,kk) = aux * ri(lp-mp)
                        endif
                    enddo
                enddo
            enddo
        enddo
    enddo
    return
    end
!
!   *******************************************************************
!> @details required by constapot
  subroutine bcofpot
    USE DAM320_T
    USE DAM320_CONST_T
    implicit none
    integer(KINT) :: k1, k2, k20, k200, kk, kk0, kk00, l, lp, m, m1, mmp, mp, n
    real(KREAL) :: aux, bux, t1, t2
    bpp = cero
!
!   starting elements bpp(lm,00)(n) = delta(l,n)
!
    k1 = 0
    do l = 0 , mxl
        do m = 0 , l
            kk = ind(k1)
            bpp(l,kk) = uno
            k1 = k1 + 1
        enddo
    enddo
!
!   elements bpp(lm,m'm')(n)
!
    do mp = 1 , mxl
        k2 = ind(mp) + mp
        k20 = ind(mp-1) + mp-1
        do l = mp , mxl
            if ( l.eq.mp ) then
                m1 = mp
            else
                m1 = 0
            endif
            do m = m1 , l
                k1 = ind(l) + m
                kk = ind(k1) + k2
                kk0 = ind(k1) + k20
                do n = l-mp , l+mp , 2
                    if ( mp.gt.m ) then
                        t1 = uno
                        t2 = uno
                    else
                        t1 = -re(n-(m-mp+1)) * re(n-(m-mp+1)+1)
                        t2 = -re(n+(m-mp+1)) * re(n+(m-mp+1)+1)
                    endif
                    if ( n.ge.abs(m-mp)) then
                        if (n.eq.0) then
                            bux=cero
                        else
                            bux=t1*bpp(n-1,kk0) * dosl1i(n-1)
                        endif
                        bpp(n,kk) = dosl1(mp-1) * ( bux - t2 * bpp(n+1,kk0) * dosl1i(n+1) )
                    endif
                enddo
            enddo
        enddo
    enddo
!
!   elements bpp(lm,l'm')(n)
!
    do mp = 0 , mxl
        k200 = 0
        do lp = mp+1 , mxl
            k2 = ind(lp) + mp
            k20 = ind(lp-1) + mp
            if ( lp.gt.mp+1 ) k200 = ind(lp-2) + mp
            do l = lp , mxl
                if ( l.eq.lp ) then
                    m1 = mp
                else
                    m1 = 0
                endif
                do m = m1 , l
                    k1 = ind(l) + m
                    kk = ind(k1) + k2
                    kk0 = ind(k1) + k20
                    kk00 = ind(k1) + k200
                    do n = l-lp , l+lp , 2
                        mmp = abs(m-mp)
                        if ( n.ge.mmp) then
                            aux = bpp(n+1,kk0) * re(n+mmp+1) * dosl1i(n+1)
                            if ( n.gt.mmp ) aux = aux + bpp(n-1,kk0) * re(n-mmp) * dosl1i(n-1)
                            aux = aux * dosl1(lp-1)
                            if ( lp.gt.mp+1 ) aux = aux - re(lp+mp-1) * bpp(n,kk00)
                            bpp(n,kk) = aux * ri(lp-mp)
                        endif
                    enddo
                enddo
            enddo
        enddo
    enddo
    return
    end
!
!	***************************************************************
!> @details reads the damqt and dmqtv files
  subroutine leedamqtpot
    USE MPI
    USE DAM320_T
    USE DAMPOT320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    USE GAUSS_T
    USE PARALELO_T
    implicit none
    integer(KINT) :: i, ia, icarga, icflm, ierr, indnf, indng, interv, j, jshft, k, k1, k2, knt, kntlm
    integer(KINT) :: l, lenindintrv, lm, m, nbasis, ncenbas, ncflm, nsamples, nsize
    real(KREAL) :: aux, bux, dltsample, dost, flm, fr1, fr2l2, pi4d2l1, r, ra, ral1inv, rainv, ral
    real(KREAL) :: rinta, rintb, rlarex, step, stepmed, suml, suml1, suml2, summ, summ1, summ2, t
    real(KREAL) :: tcheb(0:mxlenpol-1)
    inquire(file=trim(projectname)//"_2016.damqt", size=nsize, iostat=ierr)
    if (ierr .ne. 0) then
        write(iout,"('Error when inquiring file ', a, ' in processor ',i3)") trim(projectname)//"_2016.damqt", myrank
        abort = 1
        return
    endif
    if (nsize .eq. -1) then
        write(iout,"('Size of file ', a, ' cannot be determined in processor ',i3)") trim(projectname)//"_2016.damqt", myrank
        abort = 1
        return
    endif
    if (myrank .eq. 0 .and. longoutput) write(iout,"('Size of file ', a, ' = ', i12)") trim(projectname)//"_2016.damqt", nsize
#if _WIN32
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
#elif __INTEL_COMPILER
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
#else
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='unformatted', action = 'read', access='stream', iostat=ierr)
#endif
    if (ierr .ne. 0) then
        write(iout,"('Cannot open file ', a, ' in processor ',i3)") trim(projectname)//"_2016.damqt", myrank
        abort = 1
        return
    endif
#if _WIN32
    open (unit=11, file=trim(projectname)//"_2016.dmqtv", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
#elif __INTEL_COMPILER
    open (unit=11, file=trim(projectname)//"_2016.dmqtv", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
#else
    open (unit=11, file=trim(projectname)//"_2016.dmqtv", form='unformatted', action = 'read', access='stream', iostat=ierr)
#endif
    if (ierr .ne. 0) then
        write(iout,"('Cannot open file ', a, ' in processor ',i3)") trim(projectname)//"_2016.dmqtv", myrank
        abort = 1
        return
    endif
    if (myrank .eq. 0 .and. longoutput) write(iout,"('Opens files ', a, ' and ', a)") trim(projectname)//"_2016.damqt", &
            trim(projectname)//"_2016.dmqtv"
    read(10) ncen, nbas, ncaps
    if (myrank .eq. 0) write(iout,"('ncen = ', i4, ' nbas = ', i6, ' ncaps = ', i5)") ncen, nbas, ncaps

!	Allocates memory for geometry

    if (.not.allocated(atmnam)) allocate(atmnam(ncen), stat = ierr)
    if (.not.allocated(atwt)) allocate(atwt(ncen), stat = ierr)  !AK27June2015
    if (.not.allocated(nzn)) allocate(nzn(ncen), stat = ierr)
    if (.not.allocated(rcen)) allocate(rcen(3,ncen), stat = ierr)
    if (.not.allocated(zn)) allocate(zn(ncen), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating atmnam, nzn, rcen or zn in processor ',i3)") myrank
        abort = 1
        return
    endif

    if (myrank .eq. 0) write(iout,"(27x,'GEOMETRY')")
    if (myrank .eq. 0) write(iout,"(/t1, ' no. of center:', t20, 'x', t32, 'y', t44, 'z', t56, 'charge')")
    do ia = 1, ncen
        read(10) rcen(1,ia), rcen(2,ia), rcen(3,ia), zn(ia)
        if (abs(zn(ia)-re(int(zn(ia) + umbrzn))) .gt. umbrzn) then
                nzn(ia) = 0
        else
                nzn(ia) = int(zn(ia) + umbrzn)
        endif
        atmnam(ia) = atmnms(nzn(ia))
        atwt(ia) = atmwts(nzn(ia))  !AK27June2015
        if (myrank .eq. 0) write(iout,"(t4, i5, t13, f12.7, t25, f12.7, t37, f12.7, t51, f10.5)") &
                ia, rcen(1,ia), rcen(2,ia), rcen(3,ia) , zn(ia)
    enddo
    nsize = nsize - sizeof(rcen) - sizeof(zn)

!	Basis set
    read(10) lsto	! .true. means STO basis, .false. means GTO basis
    if (lsto) then
        if (lexact) then
            if (myrank .eq. 0) write(iout,"('Exact potential not prepared for STO yet. Stop')")
            abort = 1
            return
        endif

!		Allocates memory for the basis set

        if (.not.allocated(ll)) allocate(ll(ncaps), stat = ierr)
        if (.not.allocated(lmaxc)) allocate(lmaxc(ncen), stat = ierr)
        if (.not.allocated(nf)) allocate(nf(ncaps), stat = ierr)
        if (.not.allocated(ngini)) allocate(ngini(ncen), stat = ierr)
        if (.not.allocated(ngfin)) allocate(ngfin(ncen), stat = ierr)
        if (.not.allocated(nn)) allocate(nn(ncaps), stat = ierr)
        if (.not.allocated(rnor)) allocate(rnor(ncaps), stat = ierr)
        allocate(xx(ncaps), stat = ierr)
        if (ierr .ne. 0) then
            write(iout,"('Memory error when allocating ll, lmaxc, nf, ngini, ngfin, nn, rnor or xx in processor ',i3)") &
            myrank
            abort = 1
            return
        endif

        if (myrank .eq. 0) write(iout,"(/t22,'STO Basis set',/t22,13('-'))")
        i = 0
        ncenbas = 0
        do ia = 1, ncen
            read(10) ngini(ia), ngfin(ia)
            nsize = nsize - sizeof(ngini(ia)) - sizeof(ngfin(ia))
            if (myrank.eq.0 .and. longoutput)  write(iout,"(t5,'center ', i4,/t12,'n', t16, 'l', t25,'exp', t35, 'ind func')") ia
            lmaxc(ia) = 0
            if (ngini(ia) .le. 0) cycle
            ncenbas = ncenbas + 1
            do k = ngini(ia), ngfin(ia)
                i = i + 1
                read(10) nf(i), nn(i), ll(i), xx(i)
                nsize = nsize - sizeof(nf(i)) - sizeof(nn(i)) - sizeof(ll(i)) - sizeof(xx(i))
                rnor(i) = sqrt((dos * xx(i))**(2*nn(i)+1) / fact(2*nn(i)))
                if (ll(i) .gt. lmaxc(ia)) lmaxc(ia) = ll(i)
                if (myrank .eq. 0 .and. longoutput)  write(iout,"(t11,i2,t15,i2,t20,e12.5,t36,i4)") nn(i), ll(i), xx(i), nf(i)
            enddo
        enddo
    else
        read(10) nprimitot
        nsize = nsize - sizeof(nprimitot)

!		Allocates memory for the basis set

        if (.not.allocated(cfcontr)) allocate(cfcontr(nprimitot), stat = ierr)
        if (.not.allocated(ipntprim)) allocate(ipntprim(ncaps), stat = ierr)
        if (.not.allocated(ll)) allocate(ll(ncaps), stat = ierr)
        if (.not.allocated(lmaxc)) allocate(lmaxc(ncen), stat = ierr)
        if (.not.allocated(ncontr)) allocate(ncontr(ncen), stat = ierr)
        if (.not.allocated(nf)) allocate(nf(ncaps), stat = ierr)
        if (.not.allocated(ngini)) allocate(ngini(ncen), stat = ierr)
        if (.not.allocated(ngfin)) allocate(ngfin(ncen), stat = ierr)
        if (.not.allocated(nprimit)) allocate(nprimit(ncaps), stat = ierr)
        if (.not.allocated(rnor)) allocate(rnor(ncaps), stat = ierr)
        if (.not.allocated(xxg)) allocate(xxg(nprimitot), stat = ierr)
        if (ierr .ne. 0) then
            write(iout,"('Memory error when allocating cfcontr, ipntprim, ll, lmaxc, ncontr, nf, ngini, ngfin, &
                    &nprimit, rnor or xxg in processor ',i3)") myrank
            abort = 1
            return
        endif

        lmaxbase = 0
        knt = 0
        icarga = 0
        indnf = 1
        indng = 1
        ncenbas = 0
        do ia = 1, ncen
            lmaxc(ia) = 0
            read(10) ncontr(ia)
            nsize = nsize - sizeof(ncontr(ia))
            if (ncontr(ia) .le. 0) then
                ngini(ia) = -1
                ngfin(ia) = -1
                cycle
            endif
            ncenbas = ncenbas + 1
            ngini(ia) = indng
            ngfin(ia) = indng + ncontr(ia) - 1
            indng = indng + ncontr(ia)
            do j = 1, ncontr(ia)
                knt = knt + 1
                read(10) nprimit(knt), ll(knt)
                nsize = nsize - sizeof(nprimit(knt)) - sizeof(ll(knt))
                if (ll(knt) .gt. lmaxc(ia)) lmaxc(ia) = ll(knt)
                nf(knt) = indnf
                indnf = indnf + 2*ll(knt) + 1
                ipntprim(knt) = icarga+1
                read(10) xxg(icarga+1:icarga+nprimit(knt))
                nsize = nsize - sizeof(xxg(icarga+1:icarga+nprimit(knt)))
                read(10) cfcontr(icarga+1:icarga+nprimit(knt))
                nsize = nsize - sizeof(cfcontr(icarga+1:icarga+nprimit(knt)))
!				computes and stores the radial normalization factor
                aux = cero
                bux = ll(knt) + 1.5d0
                do k1 = 1, nprimit(knt)
                    do k2 = 1, k1-1
                            aux=aux + dos*cfcontr(icarga+k1)*cfcontr(icarga+k2)/(xxg(icarga+k1)+xxg(icarga+k2))**bux
                    enddo
                    aux = aux + cfcontr(icarga+k1) * cfcontr(icarga+k1) / (dos*xxg(icarga+k1))**bux
                enddo
                rnor(knt) = sqrt( dos / (facts(ll(knt))*aux) )
                icarga = icarga+nprimit(knt) ! actualizes the index for loading primitives exponents and contraction coefficients
            enddo
        enddo
        if (myrank .eq. 0) write(iout,"(/t22,'GTO Basis set',/t22,13('-'))")
        if (myrank .eq. 0 .and. longoutput) then
            icarga = 0
            knt = 0
            do ia = 1, ncen
                write(iout,"(/1x,'atom no.',1x,i4,'(',a2,')')") ia, atmnam(ia)
                write(iout,"(1x,'number of contractions = ',i4)") ncontr(ia)
                do j = 1, ncontr(ia)
                    knt = knt + 1
                    write(iout,"(/1x,'contraction no. ',i4,' ; l = ',i2)") j,  ll(knt)
                    write(iout,"('exponents: ', 8(1x,e12.5))") (xxg(icarga+k), k = 1, nprimit(knt))
                    write(iout,"('coefficients: ', 8(1x,e12.5))") (cfcontr(icarga+k),k=1,nprimit(knt))
                    icarga = icarga+nprimit(knt)
                enddo
            enddo
        endif
        if (myrank .eq. 0) write(iout,"('Number of basis functions = ', i4)") nbas
    endif

!	Data of density representation
    read(10) lmaxexp
    nsize = nsize - sizeof(lmaxexp)
    if (lmaxrep .gt. lmaxexp) then
        if (myrank .eq. 0) write(iout,"('lmaxrep = ', i3, ' greater than lmaxexp ', i3)") lmaxrep, lmaxexp
        if (myrank .eq. 0) write(iout,"('takes lmaxrep = ',i3)") lmaxexp
        lmaxrep = lmaxexp
    endif
    lmtop = (lmaxexp+1)*(lmaxexp+1)

    if (myrank .eq. 0 .and. longoutput) write(iout,"('lmaxexp = ', i2, ' nintervaj = ', i2)") lmaxexp, nintervaj

    allocate(icfposd(lmtop*nintervaj+1,ncen), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating icfposd in processor ',i3)") myrank
        abort = 1
        return
    endif
    if (longoutput) write(iout,"('Size of icfposd   = ', i15, ' bytes')") size(icfposd)
    nsize = nsize - sizeof(icfposd(:,1)) * ncenbas

    allocate(xajustd(nintervaj,ncen), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating xajustd in processor ',i3)") myrank
        abort = 1
        return
    endif
    if (longoutput) write(iout,"('Estimated highest size of xajustd   = ', i15, ' bytes')") size(xajustd)
    nsize = nsize - sizeof(xajustd(:,1)) * ncenbas

    allocate(cfajust(nsize/8), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating cfajust in processor ',i3)") myrank
        abort = 1
        return
    endif

    if (myrank .eq. 0 .and. longoutput) write(iout,"('radii of fitting intervals: ',/, 8(1x,e17.10))") rinterv
    icfposd = 0
    xajustd = cero
    cfajust = cero
    k = 0
    do ia = 1, ncen      ! Do over centers
        if (ngini(ia) .le. 0) cycle
        read(10) icfposd(1:lmtop*nintervaj+1,ia)
        if (k .gt. 0) icfposd(1:lmtop*nintervaj+1,ia) = icfposd(1:lmtop*nintervaj+1,ia) + icfposd(lmtop*nintervaj+1,k) - 1
        k = ia
        read(10) xajustd(1:nintervaj,ia)		! Exponents
        if (longoutput) write(iout,"('fitting exponents: ',/, 8(1x,e17.10))")  xajustd(1:nintervaj,ia)
!     fitting coeficients
        read(10) cfajust(icfposd(1,ia):icfposd(lmtop*nintervaj+1,ia)-1)
    enddo

!	Generates an auxiliary index array for determining the interval to which a given r belongs
    step = rinterv(1)
    fct = uno / step
    lenindintrv = int(rinterv(nintervaj) * fct + udec)

    allocate(indintrv(lenindintrv), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating indintrv in processor ',i3)") myrank
        abort = 1
        return
    endif
    if (longoutput) write(iout,"('Size of indintrv   = ', i15, ' bytes')") size(indintrv)

    r = cero
    interv = 1
    do i = 1, lenindintrv-1
        r = r + step
        if (r .gt. (rinterv(interv))) interv = interv + 1
        indintrv(i) = interv
    enddo
    indintrv(lenindintrv) = interv

!	Reads auxiliary integrals from file .dmqtv

    allocate(cfrint1(icfposd(lmtop*nintervaj+1,ncen)-1), cfrint2l2(icfposd(lmtop*nintervaj+1,ncen)-1), &
        QGacum(nintervaj*lmtop,ncen), Qgpart(nintervaj*lmtop), qpacum(nintervaj*lmtop,ncen), qppart(nintervaj*lmtop), &
        rlargo(ncen), rmultip(lmtop,ncen), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating cfrint1, cfrint2l2, QGacum, Qgpart, &
            &qpacum, qppart, rlargo and rmultip in processor ',i3)") myrank
        abort = 1
        return
    endif
    cfrint1 = cero
    cfrint2l2 = cero
    QGacum = cero
    Qgpart = cero
    qppart = cero
    qpacum = cero
    rlargo = cero
    rmultip = cero
    do ia = 1, ncen      ! Do over centers
        if (ngini(ia) .le. 0) cycle
!	multipolar moments
        read(11) rmultip(1:lmtop,ia)
!	Reads the integrals:
!		Qg(la,ma,i;ia) = 
!			Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(i-1),l_i}]
!		qp(la,ma,i;ia) = 
!			Integrate[ r * fradtr[la,ma,r], {r,l_(i-1),l_i}]
!	and computes from them and stores the integrals:
!		QGacum(la,ma,i;ia) = 
!			Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,0,l_i}]
!		qpacum(la,ma,i;ia) = 
!			Integrate[ r * fradtr[la,ma,r], {r,l_(i-1),Infinity}]
!    where  ia  labels the center (atom),
        read(11) Qgpart(1:nintervaj*lmtop)
        read(11) qppart(1:nintervaj*lmtop)
        QGacum(1:lmtop,ia) = Qgpart(1:lmtop)
        do i = lmtop+1, nintervaj*lmtop, lmtop
            QGacum(i:i+lmtop-1,ia) = QGacum(i-lmtop:i-1,ia) + Qgpart(i:i+lmtop-1)
        enddo
        qpacum((nintervaj-1)*lmtop+1:nintervaj*lmtop,ia) = cero
        do i = (nintervaj-2)*lmtop+1, 1, -lmtop
            qpacum(i:i+lmtop-1,ia) = qpacum(i+lmtop:i+2*lmtop-1,ia) + qppart(i+lmtop:i+2*lmtop-1)
        enddo
!    Reads the fitting coeficients of auxiliary integrals for electrostatic potential and field
        read(11) cfrint1(icfposd(1,ia):icfposd(lmtop*nintervaj+1,ia)-1) ! Expansion coefficients of auxiliary integrals rint1
        read(11) cfrint2l2(icfposd(1,ia):icfposd(lmtop*nintervaj+1,ia)-1) ! Expansion coefficients of auxiliary integrals rint2l2
    enddo
    close(10)
    close(11)

    if (myrank .eq. 0 .and. longoutput) then
        write(iout,"('Size of icfpos   = ', i15, ' bytes')") size(icfpos)
        write(iout,"('Size of cfajust   = ', i15, ' bytes')") size(cfajust)
        write(iout,"('Size of xajust   = ', i15, ' bytes')") size(xajust)
        write(iout,"('Size of rmultip   = ', i15, ' bytes')") size(rmultip)
        write(iout,"('Size of cfrint1   = ', i15, ' bytes')") size(cfrint1)
        write(iout,"('Size of cfrint2l2 = ', i15, ' bytes')") size(cfrint2l2)
        write(iout,"('Size of Qgpart    = ', i15, ' bytes')") size(Qgpart)
        write(iout,"('Size of Qgacum    = ', i15, ' bytes')") size(Qgacum)
        write(iout,"('Size of qppart    = ', i15, ' bytes')") size(qppart)
        write(iout,"('Size of qpacum    = ', i15, ' bytes')") size(qpacum)
    endif

!	Determines the long-range radii and the highest l in the expansion for each interval
    allocate(lcorto(nintervaj,ncen), llargo(0:mxlargo,ncen), Qllargo(0:lmaxrep), stat = ierr )
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating lcorto, llargo, auxll,  and Qllargo in processor ',i3)") myrank
        abort = 1
        return
    endif
!	long-range radii
    if (myrank .eq. 0) then
        write(iout,"(//'Convergence threshold for gradient = ',e12.5,/)") drcutcp
        write(iout,"('Long-range threshold = ',e12.5)") umbrlargo
        if (longoutput) then
            write(iout,"('Size of lcorto   = ', i15, ' bytes')") size(lcorto)
            write(iout,"('Size of Qllargo   = ', i15, ' bytes')") size(Qllargo)
        endif
    endif

    nsamples = 4
    do ia = 1, ncen
        rlargo(ia) = cero
        if (ngini(ia) .le. 0) cycle
        kntlm = 0
        do l = 0, lmaxrep
            summ1 = cero
            do m = -l, l
                kntlm = kntlm + 1
                summ1 = summ1 + abs(rmultip(kntlm,ia)) * fact(l+abs(m)) * umedpow(abs(m)) &
                                        * facti(l-abs(m)) * facti(abs(m))
            enddo
            Qllargo(l) = summ1
        enddo
        rlargo(ia) = rinterv(nintervaj)
        lcorto(1:nintervaj,ia) = 0
        do interv = 1, nintervaj
            dltsample = udec * (rinterv(interv) - rinterv(interv-1))
            do i = 0, nsamples-1	! samples over nsamples points in each interval to decide the highest l
                ra = rinterv(interv-1) + dltsample + (rinterv(interv) - rinterv(interv-1) - dos * dltsample) &
                        * ri(nsamples-1) * re(i)
                t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
                dost = t + t
                tcheb(0) = uno	! Chebyshev T  polynomials
                tcheb(1) = t
                do j = 2, mxlenpol-1
                    tcheb(j) = dost * tcheb(j-1) - tcheb(j-2)
                enddo
                lm = 0
                rainv = uno / ra
                ral = uno
                ral1inv = rainv
                suml1 = cero
                suml2 = cero
                do l = 0, lmaxrep
                    pi4d2l1 = cuatro * pi * dosl1i(l)	!   4 * pi / (2l+1)
                    summ2 = cero
                    do m = -l, l
                        lm = lm + 1
                        if(abs(QGacum((nintervaj-1)*lmtop+lm,ia)) .lt. umbrlargo) cycle
                        icflm = icfposd((interv-1)*lmtop+lm,ia)
                        rinta = cero
                        rintb = cero
                        do j = 0, icfposd((interv-1)*lmtop+lm+1,ia)-icflm-1
                            rinta = rinta + cfrint2l2(icflm+j) * tcheb(j)
                            rintb = rintb + cfrint1(icflm+j) * tcheb(j)
                        enddo
                        rinta = rinta * (ra-rinterv(interv-1))
                        if (interv .gt. 1) rinta = QGacum((interv-2)*lmtop+lm,ia) + rinta
                        rintb = qpacum((interv-1)*lmtop+lm,ia) + rintb * (rinterv(interv)-ra)
                        summ2 = summ2 + abs(pi4d2l1 * ( ral1inv * rinta + ral * rintb)) * fact(l+abs(m)) &
                                * umedpow(abs(m)) * facti(l-abs(m)) * facti(abs(m))
                    enddo
                    suml1 = suml1 + Qllargo(l) * ral1inv
                    suml2 = suml2 + summ2
                    if (abs(summ2) .gt. umbrlargo .and. l .gt. lcorto(interv,ia)) lcorto(interv,ia) = l
                    if (abs(suml2-suml1) .gt. umbrlargo) rlargo(ia) = rinterv(interv)
                    ral = ral * ra
                    ral1inv = ral1inv * rainv
                enddo
            enddo
        enddo
        if (myrank .eq. 0) then
            if (longoutput) then
                write(iout,"('Long-range radius for center ',i4,' (',a2,') = ', e12.5, ' lcorto = ', 30(i3))") &
                      ia, atmnms(nzn(ia)), rlargo(ia), lcorto(1:nintervaj,ia)
            else
                write(iout,"('Long-range radius for center ',i4,' (',a2,') = ', e12.5)") &
                        ia, atmnms(nzn(ia)), rlargo(ia)
            endif
        endif
        llargo(0,ia) = lcorto(1,ia)
        do i = 1, mxlargo
            ra = re(i)
            rainv = uno / ra
            ral1inv = rainv
            kntlm = 0
            do l = 0, lmaxrep
                summ1 = cero
                do m = -l, l
                    kntlm = kntlm + 1
                    summ1 = summ1 + abs(rmultip(kntlm,ia)) * fact(l+abs(m)) * umedpow(abs(m)) &
                                            * facti(l-abs(m)) * facti(abs(m))
                enddo
                Qllargo(l) = summ1 * ral1inv
                ral1inv = ral1inv * rainv
            enddo
            llargo(i,ia) = 0
            suml1 = cero
            do l = lmaxrep, 0, -1
                suml1 = suml1 + Qllargo(l)
                if (suml1 .gt. umbrlargo) then
                    llargo(i,ia) = l
                    exit
                endif
            enddo
        enddo
        if (myrank .eq. 0 .and. longoutput) write(iout,"('llargo: ', 51(i3))") llargo(0:mxlargo,ia)
    enddo
    deallocate (Qgpart, qppart)
    return
    end
!
!   ***************************************************************
!     Calculates the electrostatic mesp from the represented density at point (x,y,z)
!> @details Evaluates MESP using spherical harmonics 
   subroutine submesp(ia, x, y, z, vnucl, vel, vtot, drvx, drvy, drvz, dxx, dxy, dxz, dyy, dyz, dzz)
    USE DAM320_T
    USE DAMPOT320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T, zn_orig => zn
    implicit none
    integer(KINT) :: i, ia, ierr, interv, icflm, j, jshft, kntlm, l, lm, lmtopot, ltop, m
    real(KREAL) :: aux, bux, dost, drvx, drvy, drvz, drvvlm, drv2vlm
    real(KREAL) :: dxx, dxy, dxz, dyy, dyz, dzz, flm, fux
    real(KREAL) :: pi4exp, ra, ra2, rainv, ra2inv, rinta, rintb, sgn, t, tp, vnucl, vel, vlm, vqlm, vtot
    real(KREAL) :: x, xa, xadivra, y, ya, yadivra, z, za, zadivra
    real(KREAL), parameter :: vtope = 1.d10		! To prevent infinity, if the point coincides with a nucleus, loads the value of parameter vtope
    integer(KINT), parameter :: idimzlm = (mxlexp+2)*(mxlexp+2)
    real(KREAL) :: zlma(idimzlm), zlmadx(idimzlm), zlmady(idimzlm), zlmadz(idimzlm)
    real(KREAL) :: zlmadxx(idimzlm), zlmadxy(idimzlm), zlmadxz(idimzlm), zlmadyy(idimzlm), zlmadyz(idimzlm), zlmadzz(idimzlm)
    real(KREAL) :: tcheb(0:mxlenpol-1), pi4d2l1((mxlexp+1)*(mxlexp+1)), d2l1((mxlexp+1)*(mxlexp+1))
    real(KREAL), allocatable :: zn(:)
    allocate(zn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating zn in multmolec. Stop')
    if (lvalence) then
        do i = 1, ncen
            zn(i) = atom_core(zn_orig(i))
        enddo
    else
        zn = zn_orig
    endif
    pi4exp = cuatro * pi
    xa = x - rcen(1,ia)
    ya = y - rcen(2,ia)
    za = z - rcen(3,ia)
    ra2 = xa*xa+ya*ya+za*za
    vnucl = cero
    vel = cero
    vtot = cero
    drvx = cero
    drvy = cero
    drvz = cero
    dxx = cero
    dxy = cero
    dxz = cero
    dyy = cero
    dyz = cero
    dzz = cero
    if (ra2 .lt. geomthr*geomthr) then
        vnucl = vtope
        vtot = vtope
        if (lgradient) then
            drvx = -vtope
            drvy = -vtope
            drvz = -vtope
            if (lderiv2) then
                dxx = vtope
                dxy = vtope
                dxz = vtope
                dyy = vtope
                dyz = vtope
                dzz = vtope
            endif
        endif
        if (ngini(ia) .le. 0) return
        icflm = icfposd(1,ia)
        sgn = uno
        rintb = cero
        do i = 0, icfposd(2,ia)-icflm-1
            rintb = rintb + cfrint1(icflm+i) * sgn
            sgn = -sgn
        enddo
        vel = - cuatro * pi * (qpacum(1,ia) + rintb * rinterv(1))
        return
    endif
    ra = sqrt(ra2)
    rainv = uno / ra
    ra2inv = rainv * rainv
    if (ngini(ia) .le. 0) then
        vnucl = zn(ia) * rainv
        vtot = vnucl
        if (lgradient) then
            drvx = -vnucl * xa * ra2inv
            drvy = -vnucl * ya * ra2inv
            drvz = -vnucl * za * ra2inv
            if (lderiv2) then
                dxx = -(re(3) * drvx * xa + vnucl) * ra2inv
                dxy = -re(3) * drvx * ya * ra2inv
                dxz = -re(3) * drvx * za * ra2inv
                dyy = -(re(3) * drvy * ya + vnucl) * ra2inv
                dyz = -re(3) * drvy * za * ra2inv
                dzz = -(re(3) * drvz * za + vnucl) * ra2inv
            endif
        endif
        return
    endif
    if (ra .lt. rlargo(ia)) then
        interv = indintrv(int(fct*ra)+1)
        ltop = lcorto(interv,ia)
    else
        ltop = llargo(min(int(ra),mxlargo),ia)
    endif
    lmtopot = (ltop+1)*(ltop+1)
    vnucl = zn(ia) * rainv
    xadivra = xa * rainv
    yadivra = ya * rainv
    zadivra = za * rainv
    zlma(1) = uno		! Regular spherical harmonics of r-R(ia)
    zlma(2) = ya
    zlma(3) = za
    zlma(4) = xa
    ra2l1(1) = ra
    ra2l1inv(1) = rainv
    pi4d2l1(1) = cuatro * pi
    d2l1(1) = uno
    lm = 1
    do l = 1, ltop
        zlma((l+1)*(l+3)+1) = dosl1(l) * (xa * zlma(l*(l+2)+1) - ya * zlma(l*l+1))		! zlm(l+1,l+1,ia)
        zlma((l+1)*(l+1)+1) = dosl1(l) * (ya * zlma(l*(l+2)+1) + xa * zlma(l*l+1))		! zlm(l+1,-(l+1),ia)
        zlma((l+2)*(l+2)-1) = dosl1(l) * za* zlma(l*(l+2)+1)				! zlm(l+1,l,ia)
        zlma(l*(l+2)+3) = dosl1(l) * za * zlma(l*l+1)					! zlm(l+1,-l,ia)
        do m = 0, l-1
            zlma((l+1)*(l+2)+m+1) = ri(l-m+1) * (dosl1(l)*za*zlma(l*(l+1)+m+1) - re(l+m)*ra2*zlma((l-1)*l+m+1))	! zlm(l+1,m,ia)
            zlma((l+1)*(l+2)-m+1) = ri(l-m+1) * (dosl1(l)*za*zlma(l*(l+1)-m+1) - re(l+m)*ra2*zlma((l-1)*l-m+1))	! zlm(l+1,-m,ia)
        enddo
        aux = ra2l1(lm) * ra2
        bux = ra2l1inv(lm) * ra2inv
        do m = -l, l
            lm = lm + 1
            ra2l1(lm) = aux
            ra2l1inv(lm) = bux
            pi4d2l1(lm) = cuatro * pi * dosl1i(l)	!   4 * pi / (2l+1)
            d2l1(lm) = dosl1(l)
        enddo
    enddo
    if (lgradient) then
        call derivzlm(ltop, idimzlm, zlma, zlmadx, zlmady, zlmadz)
        call derivzlm(ltop, idimzlm, zlmadx, zlmadxx, zlmadxy, zlmadxz)
        call dzlm2y(ltop, idimzlm, zlmady, zlmadyy, zlmadyz)
        call dzlm2z(ltop, idimzlm, zlmadz, zlmadzz)
        if (ra .ge. rlargo(ia)) then  ! The point is in the long-range region (ra >= rlargo(ia) )
            kntlargo = kntlargo + 1
            aux = zn(ia)	! aux is the nuclear charge for l = 0 and zero otherwise
            do lm = 1, lmtopot
                vel = vel - rmultip(lm,ia) * zlma(lm) * ra2l1inv(lm)
                vlm = (aux - rmultip(lm,ia) ) * ra2l1inv(lm)
                vtot = vtot + vlm * zlma(lm)
                drvvlm = -d2l1(lm) * vlm * rainv
                drv2vlm = -(d2l1(lm)+uno) * drvvlm * rainv
                drvx = drvx + xadivra * drvvlm * zlma(lm) + vlm * zlmadx(lm)
                drvy = drvy + yadivra * drvvlm * zlma(lm) + vlm * zlmady(lm)
                drvz = drvz + zadivra * drvvlm * zlma(lm) + vlm * zlmadz(lm)
                fux = rainv * rainv * rainv * (ra * drv2vlm - drvvlm)
                if (lderiv2) then
                    dxx = dxx + (xa*xa * fux + drvvlm * rainv) * zlma(lm) &
                            + dos * xadivra * drvvlm * zlmadx(lm) + vlm * zlmadxx(lm)
                    dyy = dyy + (ya*ya * fux + drvvlm * rainv) * zlma(lm) &
                            + dos * yadivra * drvvlm * zlmady(lm) + vlm * zlmadyy(lm)
                    dzz = dzz + (za*za * fux + drvvlm * rainv) * zlma(lm) &
                            + dos * zadivra * drvvlm * zlmadz(lm) + vlm * zlmadzz(lm)
                    dxy = dxy + xa*ya * fux * zlma(lm) + xadivra * drvvlm * zlmady(lm) &
                            + yadivra * drvvlm * zlmadx(lm) + vlm * zlmadxy(lm)
                    dxz = dxz + xa*za * fux * zlma(lm) + xadivra * drvvlm * zlmadz(lm) &
                            + zadivra * drvvlm * zlmadx(lm) + vlm * zlmadxz(lm)
                    dyz = dyz + ya*za * fux * zlma(lm) + yadivra * drvvlm * zlmadz(lm) &
                                    + zadivra * drvvlm * zlmady(lm) + vlm * zlmadyz(lm)
                endif
                aux = cero
            enddo
        else		!     The point is in the short-range region (ra < rlargo(ia) )
            kntcorto = kntcorto + 1
            t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
            dost = t + t
            tcheb(0) = uno	! Chebyshev T  polynomials
            tcheb(1) = t
            do j = 2, mxlenpol-1
                    tcheb(j) = dost * tcheb(j-1) - tcheb(j-2)
            enddo
            aux = zn(ia)	! aux is the nuclear charge for l = 0 and zero otherwise
            pi4exp = pi4exp * exp(-xajustd(interv,ia)*ra)
            do lm = 1, lmtopot
                if(abs(QGacum((nintervaj-1)*lmtop+lm,ia)) .lt. umbrlargo) cycle
                icflm = icfposd((interv-1)*lmtop+lm,ia)
                flm = cero
                rinta = cero
                rintb = cero
                do i = 0, icfposd((interv-1)*lmtop+lm+1,ia)-icflm-1
                    rinta = rinta + cfrint2l2(icflm+i) * tcheb(i)
                    rintb = rintb + cfrint1(icflm+i) * tcheb(i)
                    flm   = flm + cfajust(icflm+i) * tcheb(i)
                enddo
                rinta = rinta * (ra-rinterv(interv-1))
                if (interv .gt. 1) rinta = QGacum((interv-2)*lmtop+lm,ia) + rinta
                rintb = qpacum((interv-1)*lmtop+lm,ia) + rintb * (rinterv(interv)-ra)
                vel = vel - pi4d2l1(lm) * ( rinta + ra2l1(lm) * rintb) * zlma(lm) * ra2l1inv(lm)
                vlm = (aux - pi4d2l1(lm) * ( rinta + ra2l1(lm) * rintb)) * ra2l1inv(lm)
                vqlm = (aux - pi4d2l1(lm) * rinta) * ra2l1inv(lm)
                vtot = vtot + vlm * zlma(lm)
                drvvlm = -d2l1(lm) * vqlm * rainv 	! d2l1(lm) = (l+l+1)
                drv2vlm = -(d2l1(lm)+uno) * drvvlm * rainv + pi4exp * flm
                drvx = drvx + xadivra * drvvlm * zlma(lm) + vlm * zlmadx(lm)
                drvy = drvy + yadivra * drvvlm * zlma(lm) + vlm * zlmady(lm)
                drvz = drvz + zadivra * drvvlm * zlma(lm) + vlm * zlmadz(lm)
                fux = rainv * rainv * rainv * (ra * drv2vlm - drvvlm)
                if (lderiv2) then
                    dxx = dxx + (xa*xa * fux + drvvlm * rainv) * zlma(lm) &
                            + dos * xadivra * drvvlm * zlmadx(lm) + vlm * zlmadxx(lm)
                    dyy = dyy + (ya*ya * fux + drvvlm * rainv) * zlma(lm) &
                            + dos * yadivra * drvvlm * zlmady(lm) + vlm * zlmadyy(lm)
                    dzz = dzz + (za*za * fux + drvvlm * rainv) * zlma(lm) &
                            + dos * zadivra * drvvlm * zlmadz(lm) + vlm * zlmadzz(lm)
                    dxy = dxy + xa*ya * fux * zlma(lm) + xadivra * drvvlm * zlmady(lm) &
                            + yadivra * drvvlm * zlmadx(lm) + vlm * zlmadxy(lm)
                    dxz = dxz + xa*za * fux * zlma(lm) + xadivra * drvvlm * zlmadz(lm) &
                            + zadivra * drvvlm * zlmadx(lm) + vlm * zlmadxz(lm)
                    dyz = dyz + ya*za * fux * zlma(lm) + yadivra * drvvlm * zlmadz(lm) &
                            + zadivra * drvvlm * zlmady(lm) + vlm * zlmadyz(lm)
                endif
                aux = cero
            enddo
        endif  ! End of test over long/short-range
    else
        if (ra .ge. rlargo(ia)) then  ! The point is in the long-range region (ra >= rlargo(ia) )
            kntlargo = kntlargo + 1
            vel = - dot_product( rmultip(1:lmtopot,ia),zlma(1:lmtopot)*ra2l1inv(1:lmtopot) )
        else		!     The point is in the short-range region (ra < rlargo(ia) )
            kntcorto = kntcorto + 1
            t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
            dost = t + t
            tcheb(0) = uno	! Chebyshev T  polynomials
            tcheb(1) = t
            do j = 2, mxlenpol-1
                tcheb(j) = dost * tcheb(j-1) - tcheb(j-2)
            enddo
            do lm = 1, lmtopot
                if(abs(QGacum((nintervaj-1)*lmtop+lm,ia)) .lt. umbrlargo) cycle
                icflm = icfposd((interv-1)*lmtop+lm,ia)
                rinta = cero
                rintb = cero
                do i = 0, icfposd((interv-1)*lmtop+lm+1,ia)-icflm-1
                    rinta = rinta + cfrint2l2(icflm+i) * tcheb(i)
                    rintb = rintb + cfrint1(icflm+i) * tcheb(i)
                enddo
                rinta = rinta * (ra-rinterv(interv-1))
                if (interv .gt. 1) rinta = QGacum((interv-2)*lmtop+lm,ia) + rinta
                rintb = qpacum((interv-1)*lmtop+lm,ia) + rintb * (rinterv(interv)-ra)
                vel = vel - pi4d2l1(lm) * ( rinta + ra2l1(lm) * rintb ) * zlma(lm) * ra2l1inv(lm)
            enddo
        endif  ! End of test over long/short-range
        vtot = vnucl + vel
    endif
    return
    end
	
!   ***************************************************************
!> @details Tabulates the spherical harmonics
  subroutine armonicos(lmax, xxa, yya, zza, zlma)
    USE DAM320_T
    USE DAM320_CONST_T
    implicit none
    integer(KINT) :: l, lmax, m
    real(KREAL) :: rra2, xxa, yya, zza
    real(KREAL) :: zlma((2*mxl)**2)
!	Tabulation of regular spherical harmonics associated to the position vector of point (x,y,z) relative
!	to the positions of the different centers, (XA,YA,ZA):
!
!     	zlm(l,m,ia) = zlm(l,m,x-XA,y-YA,z-ZA)
!
!     	where  ia   numerates the centers (nuclei), the coordinates of center ia being  (XA,YA,ZA)
!
!     	the indices (l,m) are contracted into a single uno:	lm = l*(l+1)+m      lm = 0, 1, 2, ... (lmaxexp+1)**2-1
    rra2 = xxa*xxa+yya*yya+zza*zza
    zlma(1) = uno		! Regular spherical harmonics of r-R(ia)
    zlma(2) = yya
    zlma(3) = zza
    zlma(4) = xxa
    do l = 1, lmax-1
        zlma((l+1)*(l+3)+1)=re(l+l+1)*(xxa*zlma(l*(l+2)+1)-yya * zlma(l*l+1))		! zlm(l+1,l+1)
        zlma((l+1)*(l+1)+1)=re(l+l+1)*(yya*zlma(l*(l+2)+1)+xxa*zlma(l*l+1))		! zlm(l+1,-(l+1))
        zlma((l+2)*(l+2)-1)=re(l+l+1)*zza* zlma(l*(l+2)+1)				! zlm(l+1,l)
        zlma(l*(l+2)+3) = re(l+l+1) * zza * zlma(l*l+1)					! zlm(l+1,-l)
        do m = 0, l-1
            zlma((l+1)*(l+2)+m+1)=ri(l-m+1)*(re(l+l+1)*zza*zlma(l*(l+1)+m+1)-(l+m)*rra2*zlma((l-1)*l+m+1))	! zlm(l+1,m)
            zlma((l+1)*(l+2)-m+1)=ri(l-m+1)*(re(l+l+1)*zza*zlma(l*(l+1)-m+1)-(l+m)*rra2*zlma((l-1)*l-m+1))	! zlm(l+1,-m)
        end do
    end do
    return
    end
!
!   subroutine freq20: computes functions
!       Fn  = y^n * Integrate[Exp[-x*t]* t**(n-1/2),{t,0,1}]
!           = ( Gamma(n+1/2) - Gamma(n+1/2,x) ) * x**(Gamma(-n-1/2)
!           = gamma(n+1/2,x) * x**(Gamma(-n-1/2)
!       with n <= 20
!       This file has been generated with the notebook:
!               <</home/rafa/math/notebooks/pargamma25_D_3.nb>>
!       and modified to introduce a factor y^n
!
subroutine freq20(r, x, fv)
   USE DAM320_T
   USE DAM320_CONST_T
   IMPLICIT NONE
   integer(KINT) :: i, iz
   real(KREAL) :: ex, fv, r, x, y, z
   dimension fv(0:20)
   z = abs(x)
   if (z .gt. 200.d0) then
      y = 1.d0 / sqrt(z)
      fv(0) = sqrt(pi) * y
      do i = 1, 20
      fv(i) = fv(i-1) * (i+i-1.d0) * 0.5d0 * y * y
      enddo
      go to 3000
   endif
   iz = z
   ex = exp(-x)
   if (iz .lt. 15) then
      if (z .lt. uno) then
!   Interval  0 <= z <= 1   ( eps = 1.233D-23 )
!   polynomial approximation of F20(z)
      fv(20) = (4.8780487804878049D-2+z            &
         *(-4.6511627906976744D-2+z*(2.2222222222222222D-2+z*(-7.0921985815602829D-3+z    &
         *(1.7006802721088306D-3+z*(-3.2679738562078113D-4+z*(5.2410901466593768D-5+z     &
         *(-7.2150072107054325D-6+z*(8.7023111885020894D-7+z*(-9.3414605558779118D-8+z    &
         *(9.0351213814743503D-9+z*(-7.9521759542980011D-10+z*(6.4150755129047891D-11+z   &
         *(-4.7343391649764174D-12+z*(3.0436531511475638D-13+z*(-1.3202921548315112D-14))))))))))))))))
      go to 2000
      endif
      go to (5,10,15) iz/5+1
5      continue
!      Interval  1 <= z < 5   ( eps = 1.330D-18 )
!      polynomial approximation of Exp[x] * F20(z)
      fv(20) = ex * (4.8780487804887270D-2+z   &
         *(2.2688598978478804D-3+z*(1.0083821782313802D-4+z*(4.2909877732148515D-6+z      &
         *(1.7514258408881220D-7+z*(6.8681734495339967D-9+z*(2.5926134770018764D-10+z     &
         *(9.3953223491830761D-12+z*(3.3867973398004913D-13+z*(9.6616173655492100D-15+z   &
         *(5.7513908577916034D-16+z*(-6.2419044563656976D-18+z*(1.1998040254144381D-18)))))))))))))
      go to 2000
10      continue
!      Interval  5 <= z < 10   ( eps = 2.197D-19 )
!      polynomial approximation of Exp[x] * F20(z)
      fv(20) = ex * (4.8780489794684994D-2+z   &
         *(2.2688557223858922D-3+z*(1.0084228213483975D-4+z*(4.2885543942049550D-6+z      &
         *(1.7614425798911456D-7+z*(6.5681000211449926D-9+z*(3.2677371327339277D-10+z     &
         *(-2.2026297716826657D-12+z*(1.8688737085070686D-12+z*(-1.4483765011674838D-13+z &
         *(1.2354396010917641D-14+z*(-6.6752016236177459D-16+z*(2.7402216839405727D-17+z  &
         *(-6.7707030795245797D-19+z*(9.1143746166955684D-21)))))))))))))))
      go to 2000
15      continue
!      Interval  10 <= z < 15   ( eps = 1.851D-18 )
!      polynomial approximation of Exp[x] * F20(z)
      fv(20) = ex * (4.8841694978314296D-2+z   &
         *(2.1952612298984881D-3+z*(1.4197437389228347D-4+z*(-9.8786540053342240D-6+z     &
         *(3.5368648978184568D-6+z*(-5.7450024066913360D-7+z*(7.5878158972779751D-8+z     &
         *(-7.5109257899927147D-9+z*(5.7546785517165086D-10+z*(-3.3687901762469887D-11+z  &
         *(1.4918741683111878D-12+z*(-4.8451102282376191D-14+z*(1.0969631911429229D-15+z  &
         *(-1.5550170752478661D-17+z*(1.0620901118859267D-19)))))))))))))))
      go to 2000
   else
      go to (25,35,45,55,65,75,85,95,105) (iz-15)/10+1
!      If z > 105: asymptotical expression
      fv(20) = 5.406242982335075D17 / sqrt(z)**41
      go to 2000
25      continue
!      Interval  15 <= z < 25   ( eps = 6.625D-15 )
!   polynomial approximation of Exp[x] * (Fasympt20 - F20(z))
      y = uno / z
      fv(20) = 5.406242982335075D17 * sqrt(y)**41 - ex * (3.0503304845140581D-3+y       &
         *(1.1486927303924751D-1+y*(1.3891510674628955D2+y*(-9.5722910256661872D3+y       &
         *(5.7578266413379715D5+y*(-2.3718074066048430D7+y*(7.5220959099166695D8+y        &
         *(-1.8095278252442547D10+y*(3.3759474357408302D11+y*(-4.8252519908180661D12+y    &
         *(5.2571946506189288D13+y*(-4.2249439839665580D14+y*(2.4081147377852433D15+y     &
         *(-8.7280423804452341D15+y*(1.6439985245835246D16)))))))))))))))
      go to 2000
35      continue
!      Interval  25 <= z < 35   ( eps = 3.089D-18 )
!   polynomial approximation of Exp[x] * (Fasympt20 - F20(z))
      y = uno / z
      fv(20) = 5.406242982335075D17 * sqrt(y)**41 - ex * (5.8747691846974363D-5+y       &
         *(9.7764465514125199D-1+y*(2.3413516830415170D1+y*(-5.6335933979497473D1+y       &
         *(3.6483404782967801D4+y*(-1.4583609380850435D6+y*(6.1127998541254078D7+y        &
         *(-1.6602879996934203D9+y*(3.5553799778962732D10+y*(-5.3096505923262290D11+y     &
         *(5.6870782720347124D12+y*(-3.7315170959956712D13+y*(1.3243661404335882D14)))))))))))))
      go to 2000
45      continue
!      Interval  35 <= z < 45   ( eps = 1.547D-19 )
!   polynomial approximation of Exp[x] * (Fasympt20 - F20(z))
      y = uno / z
      fv(20) = 5.406242982335075D17 * sqrt(y)**41 - ex * (1.5989754165300373D-5+y       &
         *(9.9312556185710981D-1+y*(2.0838150065672113D1+y*(2.0523027473807872D2+y        &
         *(1.8285896271688041D4+y*(-5.3545710391705998D5+y*(2.5719413843168101D7+y        &
         *(-6.1308064271060475D8+y*(1.1700760809463463D10+y*(-1.2321136681771141D11+y     &
         *(7.6107340878398950D11)))))))))))
      go to 2000
55      continue
!      Interval  45 <= z < 55   ( eps = 4.160D-20 )
!   polynomial approximation of Exp[x] * (Fasympt20 - F20(z))
      y = uno / z
      fv(20) = 5.406242982335075D17 * sqrt(y)**41 - ex * (1.7437254480506169D-5+y       &
         *(9.9235105114453346D-1+y*(2.0982789209186459D1+y*(1.9436556162147273D2+y        &
         *(1.8182243066041124D4+y*(-4.5064318513701511D5+y*(1.8402159511206095D7+y        &
         *(-2.8453651344225732D8+y*(3.1367646260747387D9)))))))))
      go to 2000
65      continue
!      Interval  55 <= z < 65   ( eps = 3.182D-20 )
!   polynomial approximation of Exp[x] * (Fasympt20 - F20(z))
      y = uno / z
      fv(20) = 5.406242982335075D17 * sqrt(y)**41 - ex * (4.4813294293896279D-5+y       &
         *(9.8176159665610593D-1+y*(2.2650698969190298D1+y*(6.2837162193241420D1+y        &
         *(2.2790603420436922D4+y*(-4.1574900536061811D5+y*(9.5985867522416429D6)))))))
      go to 2000
75      continue
!      Interval  65 <= z < 75   ( eps = 5.328D-20 )
!   polynomial approximation of Exp[x] * (Fasympt20 - F20(z))
      y = uno / z
      fv(20) = 5.406242982335075D17 * sqrt(y)**41 - ex * (2.0651610448975019D-4+y       &
         *(9.3080337375748514D-1+y*(2.8584764207936303D1+y*(-2.1182416824959043D2+y       &
         *(2.2555785714611651D4)))))
      go to 2000
85      continue
!      Interval  75 <= z < 85   ( eps = 1.660D-19 )
!   polynomial approximation of Exp[x] * (Fasympt20 - F20(z))
      y = uno / z
      fv(20) = 5.406242982335075D17 * sqrt(y)**41 - ex * (1.4546785444263069D-3+y       &
         *(6.7563946245566736D-1+y*(4.1886052644826494D1)))
      go to 2000
95      continue
!      Interval  85 <= z < 95   ( eps = 6.308D-21 )
!   polynomial approximation of Exp[x] * (Fasympt20 - F20(z))
      y = uno / z
      fv(20) = 5.406242982335075D17 * sqrt(y)**41 - ex * (-3.7912464139565155D-3+y      &
         *(1.6136443019529395D0))
      go to 2000
105     continue
!      Interval  95 <= z < Infinity   ( eps = 1.692D-24 )
!   polynomial approximation of Exp[x] * (Fasympt20 - F20(z))
      y = uno / z
      fv(20) = 5.406242982335075D17 * sqrt(y)**41 - ex * (-2.9220486969845953D-3+y      &
         *(1.5312675193464893D0))
   endif
2000 continue
   fv(19) = (ex + z * fv(20) ) * 5.128205128205128D-2
   fv(18) = (ex + z * fv(19) ) * 5.405405405405405D-2
   fv(17) = (ex + z * fv(18) ) * 5.714285714285714D-2
   fv(16) = (ex + z * fv(17) ) * 6.060606060606061D-2
   fv(15) = (ex + z * fv(16) ) * 6.451612903225806D-2
   fv(14) = (ex + z * fv(15) ) * 6.896551724137931D-2
   fv(13) = (ex + z * fv(14) ) * 7.407407407407407D-2
   fv(12) = (ex + z * fv(13) ) * 8.000000000000000D-2
   fv(11) = (ex + z * fv(12) ) * 8.695652173913043D-2
   fv(10) = (ex + z * fv(11) ) * 9.523809523809524D-2
   fv(9)  = (ex + z * fv(10) ) * 1.052631578947368D-1
   fv(8)  = (ex + z * fv(9) )  * 1.176470588235294D-1
   fv(7)  = (ex + z * fv(8) )  * 1.333333333333333D-1
   fv(6)  = (ex + z * fv(7) )  * 1.538461538461538D-1
   fv(5)  = (ex + z * fv(6) )  * 1.818181818181818D-1
   fv(4)  = (ex + z * fv(5) )  * 2.222222222222222D-1
   fv(3)  = (ex + z * fv(4) )  * 2.857142857142857D-1
   fv(2)  = (ex + z * fv(3) )  * 4.000000000000000D-1
   fv(1)  = (ex + z * fv(2) )  * 6.666666666666667D-1
   fv(0)  = (ex + z * fv(1) )  * 2.000000000000000D0
3000 continue
   z = r
   do i = 1, 20
      fv(i) = fv(i) * z
      z = z * r
   enddo
   return
   end

