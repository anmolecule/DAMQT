!  Copyright 2013-2018, Jaime Fernandez Rico, Rafael Lopez, Ignacio Ema,
!  Guillermo Ramirez
! 
!  This file is part of DAM320.
! 
!  DAM320 is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation, either version 3 of the License, or
!  (at your option) any later version.
! 
!  DAM320 is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
! 
!  You should have received a copy of the GNU General Public License
!  along with DAM320.  If not, see <http://www.gnu.org/licenses/>.
!
!------------------------------------------------------------------------
!> @file TDAMDEN15_mpi.F90
!> @author Rafa
!> @details Program for tabulation of the electronic density from the representation of the molecular density performed with
!> DAM320
!!
!! Parallel version with MPI
!!
!! Version of August 2014
!!

  subroutine PREDAMDEN_mpi
    USE MPI
    USE DAM320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    USE DAMDEN320_T
    USE PARALELO_T
    implicit none
    integer(KINT) :: i, ia, ierr, ios, ipoint, j, nbasis
    real(KREAL) :: aux
    abort = 0
    abortroot = 0
    lminrep = 0			! lowest "l" in the expansion of the density.
    lmaxrep = lmaxi             ! highest "l" in the expansion of the density.
                                            ! the expansion of the density takes lminrep <= l <= lmaxrep
    umbrlargo = 1.d-8		! Long-range threshold
    lgbsgz = .false.
    if (myrank .eq. 0) then	! Checks whether the .ggbs or .sgbs file is gzipped or not
        inquire(file=trim(projectname)//".ggbs.gz", exist=lgbsgz, iostat=ierr)
        if (ierr .eq. 0 .and. lgbsgz) then
            call system ("gunzip "//trim(projectname)//".ggbs.gz")
        else
            inquire(file=trim(projectname)//".sgbs.gz", exist=lgbsgz, iostat=ierr)
            if (ierr .eq. 0 .and. lgbsgz) then
                call system ("gunzip "//trim(projectname)//".sgbs.gz")
            endif
        endif
    endif
    CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)

    call constaden		! Computes auxiliary constants

    call leedamqtden		! Reads file .damqt  (generated by DAM320)
    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
            call error(1,'Stop')
    endif
!    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    if (myrank .eq. 0) then
        if (lgbsgz) then
            inquire(file=trim(projectname)//".ggbs", exist=lgbsgz, iostat=ierr)
            if (ierr .eq. 0 .and. lgbsgz) then
                call system ("gzip "//trim(projectname)//".ggbs")
            else
                inquire(file=trim(projectname)//".sgbs", exist=lgbsgz, iostat=ierr)
                if (ierr .eq. 0 .and. lgbsgz) then
                    call system ("gzip "//trim(projectname)//".sgbs")
                endif
            endif
        endif
        write(iout,"('Highest l in density expansion = ', i3)") lmaxrep
    endif


    RETURN
    END
!
!   ***************************************************************
!
!> @details Inititates the density evaluation  	
  subroutine DAMDEN_mpi(den,dxden,dyden,dzden,dxxden,dxyden,dxzden,dyyden,dyzden,dzzden,x,y,z)
    USE MPI
    USE DAM320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    USE DAMDEN320_T
    USE PARALELO_T
    implicit none
    integer(KINT) :: ia
    real(KREAL) :: den, denrep, dendrvx, dendrvy, dendrvz, dxden, dxx, dxxden
    real(KREAL) :: dxy, dxyden, dxz, dxzden, dyden, dyy, dyyden, dyz, dyzden, dzden, dzz, dzzden
    real(KREAL) :: x, y, z
    if (lderiv2) lgradient = .true.
    den = cero
    dxden = cero
    dyden = cero
    dzden = cero
    dxxden = cero
    dxyden = cero
    dxzden = cero
    dyyden = cero
    dyzden = cero
    dzzden = cero
    do ia = 1, ncen
        call densrepr(ia, x, y, z, denrep, dendrvx, dendrvy, dendrvz, dxx, dxy, dxz, dyy, dyz, dzz)
        den = den + denrep
        dxden = dxden + dendrvx
        dyden = dyden + dendrvy
        dzden = dzden + dendrvz
        dxxden = dxxden + dxx
        dxyden = dxyden + dxy
        dxzden = dxzden + dxz
        dyyden = dyyden + dyy
        dyzden = dyzden + dyz
        dzzden = dzzden + dzz
    enddo
    return	
    end

	
!**********************************************************************
!    subroutine consta
!
!	Computes and stores auxiliary constants
!		re(i) = dfloat(i)
!		ri(i) = 1.d0 / dfloat(i)
!		fact(i) = dfloat(i!)
!		facti(i) = 1.d0 / dfloat(i!)
!		facts(i) = dfloat((i+1/2)!)
!		ind(i) = i*(i+1)/2
!    	ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m) 
!			/ (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
!
!**********************************************************************
!> @details Deals with constants 
  subroutine constaden
    USE DAM320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    implicit none
    integer(KINT) :: i, l, lm, m
    real(KREAL) :: aux
!	auxiliary parameters and functions
    pi = acos(-uno)
    raizpi = sqrt(pi)
    re(0) = cero
    ri(0) = 1.d300
    dosl1(0) = uno
    dosl1i(0) = uno
    do i = 1, mxreal
        re(i) = re(i-1) + uno        ! dfloat(i)
        re(-i) = -re(i)
        ri(i) = uno / re(i)       	! uno / dfloat(i)
        ri(-i) = -ri(i)
        dosl1(i) = re(i) + re(i) + uno	! dfloat(iÃ¬)
        dosl1(-i) = -re(i) - re(i) + uno
        dosl1i(i) = uno / dosl1(i)		! dfloat( 1/(i+i+1) )
        dosl1i(-i) = uno / dosl1(-i)
    enddo
    fact(0) = uno
    facts(-1) = raizpi
    facts(0) = facts(-1) * umed
    facti(0) = uno
    do i = 1, mxfact
        fact(i) = fact(i-1) * re(i)   		!  i!
        facts(i) = facts(i-1) * re(i+i+1) * umed	! (i+1/2)!
        facti(i) = uno / fact(i)     		!  uno / i!
    enddo
    umedpow(0) = uno							!
    do i = 1, mxlexp							!
        umedpow(i) = umedpow(i-1) * umed			! 1 / 2^i
    enddo									!
    ind(0) = 0
    do i = 1, mxind
        ind(i) = ind(i-1) + i         !  i*(i+1)/2
    enddo
!    ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m) / (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
    ang(1) = umed / raizpi
    lm = 1
    do l = 1, mxangl
        lm = lm + 1
        ang(lm) = ang(1) * sqrt(re(2*l+1))
        aux = ang(lm) * raiz2
        do m = 1, l
            lm = lm + 1
            aux = aux / sqrt(re(l-m+1)*re(l+m))
            ang(lm) = aux
        enddo
    enddo
    return
    end
!
!	***************************************************************
!> @details Reads damqt and dmqtv files
  subroutine leedamqtden
    USE MPI
    USE DAM320_T
    USE DAMDEN320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    USE GAUSS_T
    USE PARALELO_T
    implicit none
    integer(KINT) :: i, ia, icarga, icflm, ierr, indnf, indng, interv, j, jshft, k, k1, k2, knt, kntlm
    integer(KINT) :: l, lenindintrv, lm, m, ncenbas, ncfaj, ncflm, nsamples, nsize
    real(KREAL) :: aux, bux, dltsample, dost, flm, r, ra, ral, rlarex, step, suml, summ, t
    real(KREAL) :: tcheb(0:mxlenpol-1)
    inquire(file=trim(projectname)//"_2016.damqt", size=nsize, iostat=ierr)
    if (ierr .ne. 0) then
        write(iout,"('Error when inquiring file ', a, ' in processor ',i3)") trim(projectname)//"_2016.damqt", myrank
        abort = 1
        return
    endif
    if (nsize .eq. -1) then
        write(iout,"('Size of file ', a, ' cannot be determined in processor ',i3)") trim(projectname)//"_2016.damqt", myrank
        abort = 1
        return
    endif
    if (myrank .eq. 0 .and. longoutput) write(iout,"('Size of file ', a, ' = ', i12)") trim(projectname)//".damqt", nsize
#if _WIN32
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
#elif __INTEL_COMPILER
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
#else
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='unformatted', action = 'read', access='stream', iostat=ierr)
#endif
    if (ierr .ne. 0) then
        write(iout,"('Cannot open file ', a, ' in processor ',i3)") trim(projectname)//"_2016.damqt", myrank
        abort = 1
        return
    endif

    if (myrank .eq. 0 .and. longoutput) write(iout,"('Opens file ', a)") trim(projectname)//"_2016.damqt"
    read(10) ncen, nbas, ncaps
    nsize = nsize - sizeof(ncen) - sizeof(nbas) - sizeof(ncaps)
    if (myrank .eq. 0) write(iout,"('ncen = ', i4, ' nbas = ', i6, ' nshells = ', i5)") ncen, nbas, ncaps

!	Allocates memory for geometry

    if (.not.allocated(atmnam)) allocate(atmnam(ncen), stat=ierr)
    if (.not.allocated(atwt)) allocate(atwt(ncen), stat = ierr)  !AK27June2015
    if (.not.allocated(nzn)) allocate(nzn(ncen), stat=ierr)
    if (.not.allocated(rcen)) allocate(rcen(3,ncen), stat=ierr)
    if (.not.allocated(zn)) allocate(zn(ncen), stat = ierr) !AK27June2015
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating atmnam, nzn, rcen and zn in processor ',i3)") myrank
        abort = 1
        return
    endif

    if (myrank .eq. 0) write(iout,"(27x,'GEOMETRY')")
    if (myrank .eq. 0) write(iout,"(/t1, ' no. of center:', t20, 'x', t32, 'y', t44, 'z', t56, 'charge')")
!	Geometry and nuclear charges
    do ia = 1, ncen
        read(10) rcen(1,ia), rcen(2,ia), rcen(3,ia), zn(ia)
        if (abs(zn(ia)-re(int(zn(ia) + umbrzn))) .gt. umbrzn) then
                nzn(ia) = 0
        else
                nzn(ia) = int(zn(ia) + umbrzn)
        endif
        atmnam(ia) = atmnms(nzn(ia))
        atwt(ia) = atmwts(nzn(ia))  !AK27June2015
        if (myrank .eq. 0) write(iout,"(t4, i5, t13, f12.7, t25, f12.7, t37, f12.7, t51, f10.5)") &
                ia, rcen(1,ia), rcen(2,ia), rcen(3,ia) , zn(ia)
    enddo
    nsize = nsize - sizeof(rcen) - sizeof(zn)

!	Basis set
    read(10) lsto	! .true. means STO basis, .false. means GTO basis
    nsize = nsize - sizeof(lsto)
    if (lsto) then      ! Case of STO basis set

!		Allocates memory for the basis set

        if (.not.allocated(ll)) allocate(ll(ncaps), stat=ierr)
        if (.not.allocated(lmaxc)) allocate(lmaxc(ncen), stat=ierr)
        if (.not.allocated(nf)) allocate(nf(ncaps), stat=ierr)
        if (.not.allocated(ngini)) allocate(ngini(ncen), stat=ierr)
        if (.not.allocated(ngfin)) allocate(ngfin(ncen), stat=ierr)
        if (.not.allocated(nn)) allocate(nn(ncaps), stat=ierr)
        if (.not.allocated(rlargo)) allocate(rlargo(ncen), stat=ierr)
        if (.not.allocated(rnor)) allocate(rnor(ncaps), stat=ierr)
        if (.not.allocated(xx)) allocate(xx(ncaps), stat = ierr)
        if (ierr .ne. 0) then
            write(iout,"('Memory error when allocating ll, lmaxc, nf, ngini, ngfin, nn, rlargo, rnor and xx in processor ',i3)") &
            myrank
            abort = 1
            return
        endif

        if (myrank .eq. 0) write(iout,"(/t22,'STO Basis set',/t22,13('-'))")
        i = 0
        ncenbas = 0
        do ia = 1, ncen
            read(10) ngini(ia), ngfin(ia)
            nsize = nsize - sizeof(ngini(ia)) - sizeof(ngfin(ia))
            if (myrank .eq. 0 .and. longoutput) write(iout,"(t5,'center ', i4,/t12,'n', t16, 'l', t25,'exp', t35, 'ind func')") ia
            lmaxc(ia) = 0
            rlargo(ia) = cero
            if (ngini(ia) .le. 0) cycle
            ncenbas = ncenbas + 1
            do k = ngini(ia), ngfin(ia)
                i = i + 1
                read(10) nf(i), nn(i), ll(i), xx(i)
                nsize = nsize - sizeof(nf(i)) - sizeof(nn(i)) - sizeof(ll(i)) - sizeof(xx(i))
                rnor(i) = sqrt((dos * xx(i))**(2*nn(i)+1) / fact(2*nn(i)))
                rlarex = (15.d0 + 2.5d0 * re(nn(i)-1) + log(rnor(i))) / xx(i)
                rlargo(ia) = max(rlargo(ia), rlarex)		! intended to accelerate calculations if lexact .eq. .true.
                if (ll(i) .gt. lmaxc(ia)) lmaxc(ia) = ll(i)
                if (myrank .eq. 0 .and. longoutput)  write(iout,"(t11,i2,t15,i2,t20,e12.5,t36,i4)") nn(i), ll(i), xx(i), nf(i)
            enddo
        enddo
        if (myrank .eq. 0) write(iout,"('Number of basis functions = ', i4)") nbas
    else      ! Case of GTO basis set
        read(10) nprimitot
        nsize = nsize - sizeof(nprimitot)
!		Allocates memory for the basis set           
        if (.not.allocated(cfcontr)) allocate(cfcontr(nprimitot), stat=ierr)
        if (.not.allocated(ipntprim)) allocate(ipntprim(ncaps), stat=ierr)
        if (.not.allocated(ll)) allocate(ll(ncaps), stat=ierr)
        if (.not.allocated(lmaxc)) allocate(lmaxc(ncen), stat=ierr)
        if (.not.allocated(ncontr)) allocate(ncontr(ncen), stat=ierr)
        if (.not.allocated(nf)) allocate(nf(ncaps), stat=ierr)
        if (.not.allocated(ngini)) allocate(ngini(ncen), stat=ierr)
            if (.not.allocated(ngfin))	allocate(ngfin(ncen), stat=ierr)
        if (.not.allocated(nprimit)) allocate(nprimit(ncaps), stat=ierr)
        if (.not.allocated(rlargo)) allocate(rlargo(ncen), stat=ierr)
        if (.not.allocated(rnor)) allocate(rnor(ncaps), stat=ierr)
        if (.not.allocated(xxg)) allocate(xxg(nprimitot), stat = ierr)
        if (ierr .ne. 0) then
            write(iout,"('Memory error when allocating cfcontr, ipntprim, ll, lmaxc, ncontr, nf, ngini, ngfin, &
                    &nprimit, rlargo, rnor and xxg in processor ',i3)") myrank
            abort = 1
            return
        endif
        lmaxbase = 0
        knt = 0
        icarga = 0
        indnf = 1
        indng = 1
        ncenbas = 0
        do ia = 1, ncen
            read(10) ncontr(ia)
            nsize = nsize - sizeof(ncontr(ia))
            if (ncontr(ia) .le. 0) then
                ngini(ia) = -1
                ngfin(ia) = -1
                cycle
            endif
            ncenbas = ncenbas + 1
            ngini(ia) = indng
            ngfin(ia) = indng + ncontr(ia) - 1
            indng = indng + ncontr(ia)
            lmaxc(ia) = 0
            rlargo(ia) = cero
            do j = 1, ncontr(ia)
                knt = knt + 1
                read(10) nprimit(knt), ll(knt)
                nsize = nsize - sizeof(nprimit(knt)) - sizeof(ll(knt))
                if (ll(knt) .gt. lmaxc(ia)) lmaxc(ia) = ll(knt)
                nf(knt) = indnf
                indnf = indnf + 2*ll(knt) + 1
                ipntprim(knt) = icarga+1
                read(10) xxg(icarga+1:icarga+nprimit(knt))
                nsize = nsize - sizeof(xxg(icarga+1:icarga+nprimit(knt)))
                read(10) cfcontr(icarga+1:icarga+nprimit(knt))
                nsize = nsize - sizeof(cfcontr(icarga+1:icarga+nprimit(knt)))
!				computes and stores the radial normalization factor
                aux = cero
                bux = ll(knt) + 1.5d0
                do k1 = 1, nprimit(knt)
                    do k2 = 1, k1-1
                        aux=aux + dos*cfcontr(icarga+k1)*cfcontr(icarga+k2)/(xxg(icarga+k1)+xxg(icarga+k2))**bux
                    enddo
                    aux = aux + cfcontr(icarga+k1) * cfcontr(icarga+k1) / (dos*xxg(icarga+k1))**bux
                enddo
                rnor(knt) = sqrt( dos / (facts(ll(knt))*aux) )
                rlarex = sqrt((15.d0 + 2.5d0 * re(ll(knt)) + log(rnor(knt))) / xxg(icarga+1))
                rlargo(ia) = max(rlargo(ia), rlarex)		! intended to accelerate calculations if lexact .eq. .true.
                    icarga = icarga+nprimit(knt)	! actualizes the index for loading primitives exponents and contraction coefficients
            enddo
        enddo

        if (myrank .eq. 0) then
            write(iout,"(/t22,'GTO Basis set',/t22,13('-'))")
            if (longoutput) then
                icarga = 0
                knt = 0
                do ia = 1, ncen
                    if (ncontr(ia) .le. 0) cycle
                    write(iout,"(/1x,'atom no.',1x,i4,'(',a2,')')") ia, atmnam(ia)
                    write(iout,"(1x,'number of contractions = ',i4)") ncontr(ia)
                    do j = 1, ncontr(ia)
                        knt = knt + 1
                        write(iout,"(/1x,'contraction no. ',i4,' ; l = ',i2)") j,  ll(knt)
                        write(iout,"('exponents: ', 8(1x,e12.5))") (xxg(icarga+k), k = 1, nprimit(knt))
                        write(iout,"('coefficients: ', 8(1x,e12.5))") (cfcontr(icarga+k),k=1,nprimit(knt))
                        icarga = icarga+nprimit(knt)
                    enddo
                enddo
            endif
            write(iout,"('Number of basis functions = ', i4)") nbas
            write(iout,"('number of total primitives = ', i8)") nprimitot
        endif
    endif

!	Data of density representation
    read(10) lmaxexp
    nsize = nsize - sizeof(lmaxexp)

    if (lmaxrep .gt. lmaxexp) then
        if (myrank .eq. 0) then
            write(iout,"('lmaxrep = ', i3, ' greater than lmaxexp ', i3)") lmaxrep, lmaxexp
            write(iout,"('takes lmaxrep = ',i3)") lmaxexp
        endif
        lmaxrep = lmaxexp
    endif
    lmtop = (lmaxexp+1)*(lmaxexp+1)

    if (myrank .eq. 0 .and. longoutput) write(iout,"('lmaxexp = ', i2, ' nintervaj = ', i2)") lmaxexp, nintervaj

    allocate(icfposd(lmtop*nintervaj+1,ncen), xajustd(nintervaj,ncen), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating icfpos and xajust in processor ',i3)") myrank
        abort = 1
        return
    endif
    nsize = nsize - (sizeof(icfposd(:,1)) + sizeof(xajustd(:,1))) * ncenbas

    allocate(cfajust(nsize/8), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating cfajust in processor ',i3)") myrank
        abort = 1
        return
    endif
    icfposd = 0
    xajustd = cero
    cfajust = cero
    k = 0
    do ia = 1, ncen      ! Do over centers
        if (ngini(ia) .le. 0) cycle
        read(10) icfposd(1:lmtop*nintervaj+1,ia)
        if (k .gt. 0) icfposd(1:lmtop*nintervaj+1,ia) = icfposd(1:lmtop*nintervaj+1,ia) + icfposd(lmtop*nintervaj+1,k) - 1
        k = ia
        read(10) xajustd(1:nintervaj,ia)		! Exponents
        if (longoutput) write(iout,"('fitting exponents: ',/, 8(1x,e17.10))")  xajustd(1:nintervaj,ia)
!     fitting coeficients
        read(10) cfajust(icfposd(1,ia):icfposd(lmtop*nintervaj+1,ia)-1)
    enddo

!	Generates an auxiliary index array for determining the interval to which a given r belongs
    step = rinterv(1)
    fct = uno / step
    lenindintrv = int(rinterv(nintervaj) * fct + udec)

    allocate(indintrv(lenindintrv), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating indintrv in processor ',i3)") myrank
        abort = 1
        return
    endif
    if (longoutput) write(iout,"('Size of indintrv   = ', i15, ' bytes')") size(indintrv)

    r = cero
    interv = 1
    do i = 1, lenindintrv-1
        r = r + step
        if (r .gt. (rinterv(interv))) interv = interv + 1
        indintrv(i) = interv
    enddo
    indintrv(lenindintrv) = interv
    close(10)

!	Determines the long-range radii and the highest l in the expansion for each interval

    allocate(lcorto(nintervaj,ncen), stat = ierr)
    if (ierr .ne. 0) then
        write(iout,"('Memory error when allocating lcorto in processor ',i3)") myrank
        abort = 1
        return
    endif
    if (myrank .eq. 0 .and. longoutput) write(iout,"('Size of lcorto   = ', i15, ' bytes')") size(lcorto)

    if (myrank .eq. 0) then
        write(iout,"(//'Convergence threshold for gradient = ',e12.5,/)") drcutcp
        write(iout,"('Long-range threshold = ',e12.5)") umbrlargo
    endif
    nsamples = 4
    do ia = 1, ncen      ! Do over centers
        if (ngini(ia) .le. 0) then
            rlargo(ia) = cero
            cycle
        endif
        rlargo(ia) = rinterv(nintervaj)
        lcorto(1:nintervaj,ia) = 0
        do interv = 1, nintervaj
            dltsample = udec * (rinterv(interv) - rinterv(interv-1))
            do i = 0, nsamples-1	! samples over nsamples points in each interval to decide the highest l
                ra = rinterv(interv-1) + dltsample + (rinterv(interv) - rinterv(interv-1) - dos * dltsample) &
                        * ri(nsamples-1) * i
                aux = exp(-xajustd(interv,ia)*ra)
                t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
                dost = t + t
                tcheb(0) = uno	! Chebyshev T  polynomials
                tcheb(1) = t
                do j = 2, mxlenpol-1
                    tcheb(j) = dost * tcheb(j-1) - tcheb(j-2)
                enddo
                suml = cero
                lm = 0
                ral = uno
                do l = 0, lmaxrep
                    summ = cero
                    do m = -l, l
                        lm = lm + 1
                        icflm = icfposd((interv-1)*lmtop+lm,ia)
                        if(icflm .ge. icfposd((interv-1)*lmtop+lm+1,ia)) cycle
                        flm = cero
                        do j = 0, icfposd((interv-1)*lmtop+lm+1,ia)-icflm-1
                                flm   = flm + cfajust(icflm+j) * tcheb(j)
                        enddo
                        summ = summ + aux * abs(flm) * fact(l+abs(m)) * umedpow(abs(m)) * facti(l-abs(m)) &
                                        * facti(abs(m))
                    enddo
                    summ = summ * cuatro * pi * dosl1i(l) * ral
                    ral = ral * ra
                    if (summ .gt. umbrlargo .and. l .gt. lcorto(interv,ia)) lcorto(interv,ia) = l
                    suml = suml + summ
                enddo
                if (suml .gt. umbrlargo) rlargo(ia) = rinterv(interv)
            enddo
        enddo
        if (myrank .eq. 0) then
            if (longoutput) then
                write(iout,"('Long-range radius for center ',i4,' (',a2,') = ', e12.5, ' lcorto = ', 30(i3))") &
                        ia, atmnms(nzn(ia)), rlargo(ia), lcorto(1:nintervaj,ia)
            else
                write(iout,"('Long-range radius for center ',i4,' (',a2,') = ', e12.5)") &
                    ia, atmnms(nzn(ia)), rlargo(ia)
            endif
        endif
    enddo
    return
    end
!
!   ***************************************************************
!
!> @details Contribution of atomic fragment to density in point
  subroutine densrepr(ia, x, y, z, denrep, dendrvx, dendrvy, dendrvz, dxx, dxy, dxz, dyy, dyz, dzz)
    USE DAM320_T
    USE DAMDEN320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    implicit none
    integer(KINT) :: i, ia, icflm, interv, j, jshft, kntlm, l, m
    real(KREAL) :: aux, bux, cux, denrep, dendrvx, dendrvy, dendrvz, dost, dux, drvflm, drv2flm
    real(KREAL) :: dxx, dxy, dxz, dyy, dyz, dzz, eux, flm, fux
    real(KREAL) :: r3inv, ra, ra2, rainv, rj2, sgn, t, umt2i, x, xa, xadivra, y, ya, yadivra, z, za, zadivra
    integer(KINT), parameter :: idimzlm = (mxlexp+2)**2
    real(KREAL) :: tcheb(0:mxlenpol-1), ucheb(0:mxlenpol-1), drvtcheb(0:mxlenpol-1), drv2tcheb(0:mxlenpol-1)
    real(KREAL) :: zlma(idimzlm), zlmadx(idimzlm), zlmady(idimzlm), zlmadz(idimzlm)
    real(KREAL) :: zlmadxx(idimzlm), zlmadxy(idimzlm), zlmadxz(idimzlm), zlmadyy(idimzlm), zlmadyz(idimzlm), zlmadzz(idimzlm)
!	Contribution of atomic fragment ia to density  in point (x,y,z)
    denrep = cero
    dendrvx = cero
    dendrvy = cero
    dendrvz = cero
    dxx = cero
    dxy = cero
    dxz = cero
    dyy = cero
    dyz = cero
    dzz = cero
    if (ngini(ia) .le. 0) then
        return
    endif
    xa = x - rcen(1,ia)
    ya = y - rcen(2,ia)
    za = z - rcen(3,ia)
    ra2 = xa*xa+ya*ya+za*za
    if (ra2 .gt. rlargo(ia)*rlargo(ia)) then
        return
    endif
    ra = sqrt(ra2)
    if (ra .lt. rlargo(ia)) then
        interv = indintrv(int(fct*ra)+1)
    else
        interv = nintervaj
    endif
    rainv = uno / ra
    xadivra = xa * rainv
    yadivra = ya * rainv
    zadivra = za * rainv
    zlma(1) = uno		! Regular spherical harmonics of r-R(ia)
    zlma(2) = ya
    zlma(3) = za
    zlma(4) = xa
    do l = 1, lcorto(interv,ia)
        zlma((l+1)*(l+3)+1) = dosl1(l) * (xa * zlma(l*(l+2)+1) - ya * zlma(l*l+1))		! zlm(l+1,l+1,ia)
        zlma((l+1)*(l+1)+1) = dosl1(l) * (ya * zlma(l*(l+2)+1) + xa * zlma(l*l+1))		! zlm(l+1,-(l+1),ia)
        zlma((l+2)*(l+2)-1) = dosl1(l) * za* zlma(l*(l+2)+1)				! zlm(l+1,l,ia)
        zlma(l*(l+2)+3) = dosl1(l) * za * zlma(l*l+1)					! zlm(l+1,-l,ia)
        do m = 0, l-1
                zlma((l+1)*(l+2)+m+1) = ri(l-m+1) * (dosl1(l)*za*zlma(l*(l+1)+m+1) - re(l+m)*ra2*zlma((l-1)*l+m+1))	! zlm(l+1,m,ia)
                zlma((l+1)*(l+2)-m+1) = ri(l-m+1) * (dosl1(l)*za*zlma(l*(l+1)-m+1) - re(l+m)*ra2*zlma((l-1)*l-m+1))	! zlm(l+1,-m,ia)
        enddo
    enddo
    if (lgradient) then
        call derivzlm(lcorto(interv,ia), idimzlm, zlma, zlmadx, zlmady, zlmadz)
        if (lderiv2) then
            call derivzlm(lcorto(interv,ia), idimzlm, zlmadx, zlmadxx, zlmadxy, zlmadxz)
            call dzlm2y(lcorto(interv,ia), idimzlm, zlmady, zlmadyy, zlmadyz)
            call dzlm2z(lcorto(interv,ia), idimzlm, zlmadz, zlmadzz)
        endif

        aux = exp(-xajustd(interv,ia)*ra)
        bux = xajustd(interv,ia)
        cux = dos / (rinterv(interv)-rinterv(interv-1))
        t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
        dost = t + t
    ! 		umt2i = uno / (t*t - uno)
        tcheb(0) = uno		! Chebyshev T and U polynomials (U polynomial are used for derivatives of T polynomials
        tcheb(1) = t		! and first and second derivatives of T polynomials according to:
        ucheb(0) = uno		!			D[T_n(t),t] = n * U_(n-1)(t)
        ucheb(1) = dost	!	and:		D[T_n(t),{t,2}] = (n/(t^2-1)) * ( (n-1)*t*U_(n-1) - n * U_(n-2) )
        drvtcheb(0) = cero
        drvtcheb(1) = uno
        sgn = uno
        do j = 2, mxlenpol-1
            tcheb(j) = dost * tcheb(j-1) - tcheb(j-2)
            ucheb(j) = dost * ucheb(j-1) - ucheb(j-2)
            drvtcheb(j) = re(j) * ucheb(j-1)
        enddo
        drv2tcheb(0) = cero
        drv2tcheb(1) = cero
        if (uno-abs(t) .gt. 1.d-7) then
            umt2i = uno / (t*t - uno)
            do j = 2, mxlenpol-1
                drv2tcheb(j) = re(j) * umt2i * (re(j-1) * t * ucheb(j-1) - re(j) * ucheb(j-2))
            enddo
        else	! For values of t very close to 1 or -1, takes a linear approximation (Taylor series) of D[T[j,t],{t,2}]
            do j = 2, mxlenpol-1
                rj2 = re(j) * re(j)
                drv2tcheb(j) = sgn * ri(3) * (rj2 * (rj2-uno) + ri(5) * rj2 * (re(4)+rj2*(-re(5)+rj2)) * (abs(t)-uno) )
                if (t .lt. cero) sgn = - sgn
            enddo
        endif

        denrep = cero
        kntlm = lminrep*lminrep
        do l = lminrep, lcorto(interv,ia)	!     Computes density terms lminrep <= l <= lcorto(interv,ia)
            do m = -l, l
                kntlm = kntlm + 1
                icflm = icfposd(kntlm+(interv-1)*lmtop,ia)
                if(icflm .lt. icfposd(kntlm+(interv-1)*lmtop+1,ia)) then
                    flm = cero
                    drvflm = cero
                    drv2flm = cero
                    do j = 0, icfposd(kntlm+(interv-1)*lmtop+1,ia)-icflm-1
                        flm = flm + cfajust(j+icflm) * tcheb(j)
                        drvflm = drvflm + cfajust(j+icflm) * drvtcheb(j)
                        drv2flm = drv2flm + cfajust(j+icflm) * drv2tcheb(j)
                    enddo
                    flm = aux * flm
                    drvflm = cux * aux * drvflm		! Converts the derivative with respect to t to derivative respect to r
                    drv2flm = cux * cux * aux * drv2flm	! Same for second derivative
                    drv2flm = bux * (bux * flm - (drvflm+drvflm)) + drv2flm	! D[flm,{r,2}]
                    drvflm = -bux * flm + drvflm							! D[flm,r]
                    denrep = denrep + flm * zlma(kntlm)
                    dendrvx = dendrvx + xadivra * drvflm * zlma(kntlm) + flm * zlmadx(kntlm)
                    dendrvy = dendrvy + yadivra * drvflm * zlma(kntlm) + flm * zlmady(kntlm)
                    dendrvz = dendrvz + zadivra * drvflm * zlma(kntlm) + flm * zlmadz(kntlm)
                    r3inv = rainv * rainv * rainv
                    fux = r3inv * (ra * drv2flm - drvflm)
                    if (lderiv2) then
                        dxx = dxx + (xa*xa * fux + drvflm * rainv) * zlma(kntlm) &
                                + dos * xadivra * drvflm * zlmadx(kntlm) + flm * zlmadxx(kntlm)
                        dyy = dyy + (ya*ya * fux + drvflm * rainv) * zlma(kntlm) &
                                + dos * yadivra * drvflm * zlmady(kntlm) + flm * zlmadyy(kntlm)
                        dzz = dzz + (za*za * fux + drvflm * rainv) * zlma(kntlm) &
                                + dos * zadivra * drvflm * zlmadz(kntlm) + flm * zlmadzz(kntlm)
                        dxy = dxy + xa*ya * fux * zlma(kntlm) + xadivra * drvflm * zlmady(kntlm) &
                                + yadivra * drvflm * zlmadx(kntlm) + flm * zlmadxy(kntlm)
                        dxz = dxz + xa*za * fux * zlma(kntlm) + xadivra * drvflm * zlmadz(kntlm) &
                                + zadivra * drvflm * zlmadx(kntlm) + flm * zlmadxz(kntlm)
                        dyz = dyz + ya*za * fux * zlma(kntlm) + yadivra * drvflm * zlmadz(kntlm) &
                                + zadivra * drvflm * zlmady(kntlm) + flm * zlmadyz(kntlm)
                    endif
                endif
            enddo
        enddo
    else
        aux = exp(-xajustd(interv,ia)*ra)
        t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
        dost = t + t
        tcheb(0) = uno	! Chebyshev T  polynomials
        tcheb(1) = t
        do j = 2, mxlenpol-1
            tcheb(j) = dost * tcheb(j-1) - tcheb(j-2)
        enddo
        denrep = cero
        kntlm = lminrep*lminrep
        do l = lminrep, lcorto(interv,ia)	!     Computes density terms lminrep <= l <= lcorto(interv,ia)
            do m = -l, l
                kntlm = kntlm + 1
                icflm = icfposd(kntlm+(interv-1)*lmtop,ia)
                if(icflm .lt. icfposd(kntlm+(interv-1)*lmtop+1,ia)) then
                    flm = cero
                    do j = 0, icfposd(kntlm+(interv-1)*lmtop+1,ia)-icflm-1
                        flm = flm + cfajust(j+icflm) * tcheb(j)
                    enddo
                    denrep = denrep + aux * flm * zlma(l*(l+1)+m+1)
                endif
            enddo
        enddo
    endif

    return
    end
	
