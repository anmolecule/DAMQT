!  Copyright 2008-2021, Jaime Fernandez Rico, Rafael Lopez, Ignacio Ema,
!  Guillermo Ramirez, Anmol Kumar, Sachin D. Yeole, Shridhar R. Gadre
! 
!  This file is part of DAM320.
! 
!  DAM320 is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation, either version 3 of the License, or
!  (at your option) any later version.
! 
!  DAM320 is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
! 
!  You should have received a copy of the GNU General Public License
!  along with DAM320.  If not, see <http://www.gnu.org/licenses/>.
!
!------------------------------------------------------------------------
!
!> @author Rafa
! Program for tabulation of the electronic density from the representation of the molecular density performed with
! DAM320
!
! Version of August 2014
!

! #define DBLPRCGRID	! Uncomment this line  if double precision grid is wanted
  subroutine PREDAMDEN
    USE DAM320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    USE DAMDEN320_T
    implicit none
    integer(KINT) :: i, ia, ierr, ios, ipoint, j, nbasis
    real(KREAL) :: aux
    longoutput = .false.	! If .true. a more detailed output is given
    lminrep = 0			! lowest "l" in the expansion of the density.
    lmaxrep = lmaxi             ! highest "l" in the expansion of the density.
    umbrlargo = 1.d-8		! Long-range threshold
    numrtab = 0			! Number of tabulation points supplied in namelist
    rtab = cero			! Tabulation points supplied in namelist
    lgbsgz = .false.	! Checks whether the .ggbs or .sgbs file is gzipped or not
    inquire(file=trim(projectname)//".ggbs.gz", exist=lgbsgz, iostat=ierr)
    if (ierr .eq. 0 .and. lgbsgz) then
        call system ("gunzip "//trim(projectname)//".ggbs.gz")
    else
        inquire(file=trim(projectname)//".sgbs.gz", exist=lgbsgz, iostat=ierr)
        if (ierr .eq. 0 .and. lgbsgz) then
                call system ("gunzip "//trim(projectname)//".sgbs.gz")
        endif
    endif

    call constaden		! Computes auxiliary constants

    call leedamqtden		! Reads file .damqt  (generated by DAM320)
    if (lgbsgz) then
        inquire(file=trim(projectname)//".ggbs", exist=lgbsgz, iostat=ierr)
        if (ierr .eq. 0 .and. lgbsgz) then
            call system ("gzip "//trim(projectname)//".ggbs")
        else
            inquire(file=trim(projectname)//".sgbs", exist=lgbsgz, iostat=ierr)
            if (ierr .eq. 0 .and. lgbsgz) then
                call system ("gzip "//trim(projectname)//".sgbs")
            endif
        endif
    endif
#ifdef DBLPRCGRID
    write(iout,"('Grid generated in double precision')")
    write(iout,"('WARNING! This grid will not be compatible with gOpenMol')")
#endif
    write(iout,"('Highest l in density expansion = ', i3)") lmaxrep
    RETURN
    END
!
!   ***************************************************************
!
  subroutine DAMDEN(den,dxden,dyden,dzden,dxxden,dxyden,dxzden,dyyden,dyzden,dzzden,x,y,z)
    USE DAM320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    USE DAMDEN320_T
    implicit none
    integer(KINT) :: i, ia, ierr, ios, ipoint, j, nbasis
    real(KREAL) :: aux, den, denlp, denrep, dendrvx, dendrvy, dendrvz, denlplc, dxden, dxx, dxxden
    real(KREAL) :: dxy, dxyden, dxz, dxzden, dyden, dyy, dyyden, dyz, dyzden, dzden, dzz, dzzden
    real(KREAL) :: x, xmax, xmin, xyzmax, xyzmin, y, ymax, ymin, z, zmax, zmin


!	Tabulates specific points if required
    allocate(lnegia(ncen), stat = ierr)
    if (ierr .ne. 0) then
        call error(ierr,"Memory error when allocating lnegia in DAMDEN")
    endif
    den = cero
    dxden = cero
    dyden = cero
    dzden = cero
    dxxden = cero
    dxyden = cero
    dxzden = cero
    dyyden = cero
    dyzden = cero
    dzzden = cero
    do ia = 1, ncen
        call densrepr(ia, x, y, z, denrep, dendrvx, dendrvy, dendrvz, denlplc, dxx, dxy, dxz, dyy, dyz, dzz)
        den = den + denrep
        dxden = dxden + dendrvx
        dyden = dyden + dendrvy
        dzden = dzden + dendrvz
        dxxden = dxxden + dxx
        dxyden = dxyden + dxy
        dxzden = dxzden + dxz
        dyyden = dyyden + dyy
        dyzden = dyzden + dyz
        dzzden = dzzden + dzz
    enddo
    deallocate(lnegia)
    return	
    end

	
!**********************************************************************
!    subroutine consta
!
!	Computes and stores auxiliary constants
!		re(i) = dfloat(i)
!		ri(i) = 1.d0 / dfloat(i)
!		fact(i) = dfloat(i!)
!		facti(i) = 1.d0 / dfloat(i!)
!		facts(i) = dfloat((i+1/2)!)
!		ind(i) = i*(i+1)/2
!    	ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m) 
!			/ (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
!
!**********************************************************************
  subroutine constaden
    USE DAM320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    implicit none
    integer(KINT) :: i, l, lm, m
    real(KREAL) :: aux
!	auxiliary parameters and functions
    pi = acos(-uno)
    raizpi = sqrt(pi)
    re(0) = cero
    ri(0) = 1.d300
    dosl1(0) = uno
    dosl1i(0) = uno
    do i = 1, mxreal
        re(i) = re(i-1) + uno        ! dfloat(i)
        re(-i) = -re(i)
        ri(i) = uno / re(i)       	! uno / dfloat(i)
        ri(-i) = -ri(i)
        dosl1(i) = re(i) + re(i) + uno	! dfloat(i√¨)
        dosl1(-i) = -re(i) - re(i) + uno
        dosl1i(i) = uno / dosl1(i)		! dfloat( 1/(i+i+1) )
        dosl1i(-i) = uno / dosl1(-i)
    enddo
    fact(0) = uno
    facts(-1) = raizpi
    facts(0) = facts(-1) * umed
    facti(0) = uno
    do i = 1, mxfact
        fact(i) = fact(i-1) * re(i)   		!  i!
        facts(i) = facts(i-1) * re(i+i+1) * umed	! (i+1/2)!
        facti(i) = uno / fact(i)     		!  uno / i!
    enddo
    umedpow(0) = uno							!
    do i = 1, mxlexp							!
        umedpow(i) = umedpow(i-1) * umed			! 1 / 2^i
    enddo									!
    ind(0) = 0
    do i = 1, mxind
        ind(i) = ind(i-1) + i         !  i*(i+1)/2
    enddo
!    ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m) / (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
    ang(1) = umed / raizpi
    lm = 1
    do l = 1, mxangl
        lm = lm + 1
        ang(lm) = ang(1) * sqrt(re(2*l+1))
        aux = ang(lm) * raiz2
        do m = 1, l
            lm = lm + 1
            aux = aux / sqrt(re(l-m+1)*re(l+m))
            ang(lm) = aux
        enddo
    enddo
    return
    end
!
!	***************************************************************
!
  subroutine leedamqtden
    USE DAM320_T
    USE DAMDEN320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    USE GAUSS_T
    implicit none
    integer(KINT) :: i, ia, icarga, icflm, ierr, indnf, indng, interv, j, jshft, k, k1, k2, knt, kntlm
    integer(KINT) :: l, lenindintrv, lm, m, ncenbas, ncfaj, ncflm, nsamples, nsize
    real(KREAL) :: aux, bux, dltsample, dost, flm, r, ra, ral, rlarex, step, suml, summ, t
    real(KREAL) :: tcheb(0:mxlenpol-1)
    inquire(file=trim(projectname)//"_2016.damqt", size=nsize, iostat=ierr)
    if (ierr .ne. 0) then
        call error (ierr,"Error when inquiring damqt file")
        return
    endif
    if (nsize .eq. -1) then
        call error(1,"Size of file cannot be determined")
        return
    endif
    if (longoutput) write(iout,"('Size of file ', a, ' = ', i12)") trim(projectname)//".damqt", nsize
#if _WIN32
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
#elif __INTEL_COMPILER
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
#else
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='unformatted', action = 'read', access='stream', iostat=ierr)
#endif
    if (ierr .ne. 0) then
        write(iout,"('Cannot open file ', a)") trim(projectname)//"_2016.damqt"
    call error(1,"Cannot open file")
        return
    endif

    if (longoutput) write(iout,"('Opens file ', a)") trim(projectname)//"_2016.damqt"
    read(10) ncen, nbas, ncaps
    nsize = nsize - sizeof(ncen) - sizeof(nbas) - sizeof(ncaps)
    write(iout,"('ncen = ', i4, ' nbas = ', i6, ' ncaps = ', i5)") ncen, nbas, ncaps

!	Allocates memory for geometry

    if (.not.allocated(atmnam)) allocate(atmnam(ncen), stat=ierr)
    if (ierr .ne. 0) call error(ierr,"Memory error when allocating atmnamn")
    if (.not.allocated(atwt)) allocate(atwt(ncen), stat = ierr)  !AK27June2015
    if (.not.allocated(atvdw)) allocate(atvdw(ncen), stat = ierr)  !AK27June2015
    if (.not.allocated(nzn)) allocate(nzn(ncen), stat=ierr)
    if (.not.allocated(rcen)) allocate(rcen(3,ncen), stat=ierr) 
    if (.not.allocated(zn)) allocate(zn(ncen), stat = ierr) !AK27June2015
    if (ierr .ne. 0) then
        call error(ierr,"Memory error when allocating atmnam, nzn, rcen and zn")
        return
    endif

    write(iout,"(/24x,'GEOMETRY (BOHR)')")
    write(iout,"(/t1, ' no. of center:', t20, 'x', t32, 'y', t44, 'z', t56, 'charge')")
!	Geometry and nuclear charges
    do ia = 1, ncen
        read(10) rcen(1,ia), rcen(2,ia), rcen(3,ia), zn(ia)
        if (abs(zn(ia)-re(int(zn(ia) + umbrzn))) .gt. umbrzn) then
            nzn(ia) = 0
        else
            nzn(ia) = int(zn(ia) + umbrzn)
        endif
        atmnam(ia) = atmnms(nzn(ia))
        atwt(ia) = atmwts(nzn(ia)) !AK27June2015
        atvdw(ia) = atmvdw(nzn(ia)) !AK27June2015
        write(iout,"(t4, i5, t13, f12.7, t25, f12.7, t37, f12.7, t51, f10.5)") ia, rcen(1,ia), rcen(2,ia), rcen(3,ia) , zn(ia)
    enddo
    nsize = nsize - sizeof(rcen) - sizeof(zn)

!	Basis set
    read(10) lsto	! .true. means STO basis, .false. means GTO basis
    nsize = nsize - sizeof(lsto)
    if (lsto) then

!		Allocates memory for the basis set

        if (.not.allocated(ll)) allocate(ll(ncaps), stat = ierr)
        if (.not.allocated(lmaxc)) allocate(lmaxc(ncen), stat = ierr)
        if (.not.allocated(nf)) allocate(nf(ncaps), stat = ierr)
        if (.not.allocated(ngini)) allocate(ngini(ncen), stat = ierr)
        if (.not.allocated(ngfin)) allocate(ngfin(ncen), stat = ierr)
        if (.not.allocated(nn)) allocate(nn(ncaps), stat = ierr)
        if (.not.allocated(rlargo)) allocate(rlargo(ncen), stat = ierr)
        if (.not.allocated(rnor)) allocate(rnor(ncaps), stat = ierr)
        if (.not.allocated(xx)) allocate(xx(ncaps), stat = ierr)
!		allocate(ll(ncaps), lmaxc(ncen), nf(ncaps), ngini(ncen), ngfin(ncen), nn(ncaps), rlargo(ncen), rnor(ncaps), &
!			xx(ncaps), stat = ierr)
        if (ierr .ne. 0) then
            call error(ierr,"Memory error when allocating ll, lmaxc, nf, ngini, ngfin, nn, rlargo, rnor and xx")
            return
        endif

        write(iout,"(/t22,'STO Basis set',/t22,13('-'))")
        i = 0
        ncenbas = 0
        do ia = 1, ncen
            read(10) ngini(ia), ngfin(ia)
            nsize = nsize - sizeof(ngini(ia)) - sizeof(ngfin(ia))
            if (longoutput) write(iout,"(t5,'center ', i4,/t12,'n', t16, 'l', t25,'exp', t35, 'ind func')") ia
            lmaxc(ia) = 0
            rlargo(ia) = cero
            if (ngini(ia) .le. 0) cycle
            ncenbas = ncenbas + 1
            do k = ngini(ia), ngfin(ia)
                i = i + 1
                read(10) nf(i), nn(i), ll(i), xx(i)
                nsize = nsize - sizeof(nf(i)) - sizeof(nn(i)) - sizeof(ll(i)) - sizeof(xx(i))
                rnor(i) = sqrt((dos * xx(i))**(2*nn(i)+1) / fact(2*nn(i)))
                rlarex = (15.d0 + 2.5d0 * re(nn(i)-1) + log(rnor(i))) / xx(i)
                rlargo(ia) = max(rlargo(ia), rlarex)    ! intended to accelerate calculations if lexact .eq. .true.
                if (ll(i) .gt. lmaxc(ia)) lmaxc(ia) = ll(i)
                if (longoutput)  write(iout,"(t11,i2,t15,i2,t20,e12.5,t36,i4)") nn(i), ll(i), xx(i), nf(i)
            enddo
        enddo
        write(iout,"('Number of basis functions = ', i4)") nbas
    else
        read(10) nprimitot
        nsize = nsize - sizeof(nprimitot)
!		Allocates memory for the basis set

        if (.not.allocated(cfcontr)) allocate(cfcontr(nprimitot), stat = ierr)
        if (.not.allocated(ipntprim)) allocate(ipntprim(ncaps), stat = ierr)
        if (.not.allocated(ll)) allocate(ll(ncaps), stat = ierr)
        if (.not.allocated(lmaxc)) allocate(lmaxc(ncen), stat = ierr)
        if (.not.allocated(ncontr)) allocate(ncontr(ncen), stat = ierr)
        if (.not.allocated(nf)) allocate(nf(ncaps), stat = ierr)
        if (.not.allocated(ngini)) allocate(ngini(ncen), stat = ierr)
        if (.not.allocated(ngfin)) allocate(ngfin(ncen), stat = ierr)
        if (.not.allocated(nprimit)) allocate(nprimit(ncaps), stat = ierr)
        if (.not.allocated(rlargo)) allocate(rlargo(ncen), stat = ierr)
        if (.not.allocated(rnor)) allocate(rnor(ncaps), stat = ierr)
        if (.not.allocated(xxg)) allocate(xxg(nprimitot), stat = ierr)
!		allocate(cfcontr(nprimitot), ipntprim(ncaps), ll(ncaps), lmaxc(ncen), ncontr(ncen), nf(ncaps), ngini(ncen), &
!			ngfin(ncen), nprimit(ncaps), rlargo(ncen), rnor(ncaps), xxg(nprimitot), stat = ierr)
        if (ierr .ne. 0) then
            call error(ierr,"Memory error when allocating cfcontr, ipntprim, ll, lmaxc, ncontr, nf, ngini, ngfin, &
                    &nprimit, rlargo, rnor and xxg")
            return
        endif
        lmaxbase = 0
        knt = 0
        icarga = 0
        indnf = 1
        indng = 1
        ncenbas = 0
        do ia = 1, ncen
            read(10) ncontr(ia)
            nsize = nsize - sizeof(ncontr(ia))
            if (ncontr(ia) .le. 0) then
                ngini(ia) = -1
                ngfin(ia) = -1
                cycle
            endif
            ncenbas = ncenbas + 1
            ngini(ia) = indng
            ngfin(ia) = indng + ncontr(ia) - 1
            indng = indng + ncontr(ia)
            lmaxc(ia) = 0
            rlargo(ia) = cero
            do j = 1, ncontr(ia)
                knt = knt + 1
                read(10) nprimit(knt), ll(knt)
                nsize = nsize - sizeof(nprimit(knt)) - sizeof(ll(knt))
                if (ll(knt) .gt. lmaxc(ia)) lmaxc(ia) = ll(knt)
                nf(knt) = indnf
                indnf = indnf + 2*ll(knt) + 1
                ipntprim(knt) = icarga+1
                read(10) xxg(icarga+1:icarga+nprimit(knt))
                nsize = nsize - sizeof(xxg(icarga+1:icarga+nprimit(knt)))
                read(10) cfcontr(icarga+1:icarga+nprimit(knt))
                nsize = nsize - sizeof(cfcontr(icarga+1:icarga+nprimit(knt)))
!				computes and stores the radial normalization factor
                aux = cero
                bux = ll(knt) + 1.5d0
                do k1 = 1, nprimit(knt)
                    do k2 = 1, k1-1
                        aux=aux + dos*cfcontr(icarga+k1)*cfcontr(icarga+k2)/(xxg(icarga+k1)+xxg(icarga+k2))**bux
                    enddo
                    aux = aux + cfcontr(icarga+k1) * cfcontr(icarga+k1) / (dos*xxg(icarga+k1))**bux
                enddo
                rnor(knt) = sqrt( dos / (facts(ll(knt))*aux) )
                rlarex = sqrt((15.d0 + 2.5d0 * re(ll(knt)) + log(rnor(knt))) / xxg(icarga+1))
                rlargo(ia) = max(rlargo(ia), rlarex)    ! intended to accelerate calculations if lexact .eq. .true.
                icarga = icarga+nprimit(knt)    ! actualizes the index for loading primitives exponents and contraction coefficients
            enddo
        enddo

        write(iout,"(/t22,'GTO Basis set',/t22,13('-'))")
        if (longoutput) then
            icarga = 0
            knt = 0
            do ia = 1, ncen
                if (ncontr(ia) .le. 0) cycle
                write(iout,"(/1x,'atom no.',1x,i4,'(',a2,')')") ia, atmnam(ia)
                write(iout,"(1x,'number of contractions = ',i4)") ncontr(ia)
                do j = 1, ncontr(ia)
                    knt = knt + 1
                    write(iout,"(/1x,'contraction no. ',i4,' ; l = ',i2)") j,  ll(knt)
                    write(iout,"('exponents: ', 8(1x,e12.5))") (xxg(icarga+k), k = 1, nprimit(knt))
                    write(iout,"('coefficients: ', 8(1x,e12.5))") (cfcontr(icarga+k),k=1,nprimit(knt))
                    icarga = icarga+nprimit(knt)
                enddo
            enddo
        endif
        write(iout,"('Number of basis functions = ', i4)") nbas
        write(iout,"('number of total primitives = ', i8)") nprimitot
    endif

!	Data of density representation
    read(10) lmaxexp
    nsize = nsize - sizeof(lmaxexp)

    if (lmaxrep .gt. lmaxexp) then
        write(iout,"('lmaxrep = ', i3, ' greater than lmaxexp ', i3)") lmaxrep, lmaxexp
        write(iout,"('takes lmaxrep = ',i3)") lmaxexp
        lmaxrep = lmaxexp
    endif
    lmtop = (lmaxexp+1)*(lmaxexp+1)

    if (longoutput) write(iout,"('lmaxexp = ', i2, ' nintervaj = ', i2)") lmaxexp, nintervaj

    allocate(icfposd(lmtop*nintervaj+1,ncen), xajustd(nintervaj,ncen), stat = ierr)
    if (ierr .ne. 0) then
            call error(1,"Memory error when allocating icfpos and xajust")
            return
    endif
    nsize = nsize - (sizeof(icfposd(:,1)) + sizeof(xajustd(:,1))) * ncenbas

    allocate(cfajust(nsize/8), stat = ierr)
    if (ierr .ne. 0) then
        call error(ierr,"Memory error when allocating cfajust")
        return
    endif
    icfposd = 0
    xajustd = cero
    cfajust = cero
    k = 0
    do ia = 1, ncen      ! Do over centers
        if (ngini(ia) .le. 0) cycle
        read(10) icfposd(1:lmtop*nintervaj+1,ia)
        if (k .gt. 0) icfposd(1:lmtop*nintervaj+1,ia) = icfposd(1:lmtop*nintervaj+1,ia) + icfposd(lmtop*nintervaj+1,k) - 1
        k = ia
        read(10) xajustd(1:nintervaj,ia)		! Exponents
        if (longoutput) write(iout,"('fitting exponents: ',/, 8(1x,e17.10))")  xajustd(1:nintervaj,ia)
!     fitting coeficients
        read(10) cfajust(icfposd(1,ia):icfposd(lmtop*nintervaj+1,ia)-1)
    enddo

!	Generates an auxiliary index array for determining the interval to which a given r belongs
    step = rinterv(1)
    fct = uno / step
    lenindintrv = int(rinterv(nintervaj) * fct + udec)

    allocate(indintrv(lenindintrv), stat = ierr)
    if (ierr .ne. 0) then
        call error(ierr,"Memory error when allocating indintrv")
        return
    endif
    if (longoutput) write(iout,"('Size of indintrv   = ', i15, ' bytes')") size(indintrv)

    r = cero
    interv = 1
    do i = 1, lenindintrv-1
        r = r + step
        if (r .gt. (rinterv(interv))) interv = interv + 1
        indintrv(i) = interv
    enddo
    indintrv(lenindintrv) = interv
    close(10)

!	Determines the long-range radii and the highest l in the expansion for each interval

    allocate(lcorto(nintervaj,ncen), stat = ierr)
    if (ierr .ne. 0) then
        call error(ierr,"Memory error when allocating lcorto")
        return
    endif
    if (longoutput) write(iout,"('Size of lcorto   = ', i15, ' bytes')") size(lcorto)

    write(iout,"('Long-range threshold = ',e12.5)") umbrlargo
    nsamples = 4
    do ia = 1, ncen      ! Do over centers
        if (ngini(ia) .le. 0) then
            rlargo(ia) = cero
            cycle
        endif
        rlargo(ia) = rinterv(nintervaj)
        lcorto(1:nintervaj,ia) = 0
        do interv = 1, nintervaj
            dltsample = udec * (rinterv(interv) - rinterv(interv-1))
            do i = 0, nsamples-1	! samples over nsamples points in each interval to decide the highest l
                ra = rinterv(interv-1) + dltsample + (rinterv(interv) - rinterv(interv-1) - dos * dltsample) &
                        * ri(nsamples-1) * i
                aux = exp(-xajustd(interv,ia)*ra)
                t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
                dost = t + t
                tcheb(0) = uno	! Chebyshev T  polynomials
                tcheb(1) = t
                do j = 2, mxlenpol-1
                    tcheb(j) = dost * tcheb(j-1) - tcheb(j-2)
                enddo
                suml = cero
                lm = 0
                ral = uno
                do l = 0, lmaxrep
                    summ = cero
                    do m = -l, l
                        lm = lm + 1
                        icflm = icfposd((interv-1)*lmtop+lm,ia)
                        if(icflm .ge. icfposd((interv-1)*lmtop+lm+1,ia)) cycle
                        flm = cero
                        do j = 0, icfposd((interv-1)*lmtop+lm+1,ia)-icflm-1
                            flm   = flm + cfajust(icflm+j) * tcheb(j)
                        enddo
                        summ = summ + aux * abs(flm) * fact(l+abs(m)) * umedpow(abs(m)) * facti(l-abs(m)) &
                                        * facti(abs(m))
                    enddo
                    summ = summ * cuatro * pi * dosl1i(l) * ral
                    ral = ral * ra
                    if (summ .gt. umbrlargo .and. l .gt. lcorto(interv,ia)) lcorto(interv,ia) = l
                    suml = suml + summ
                enddo
                if (suml .gt. umbrlargo) rlargo(ia) = rinterv(interv)
            enddo
        enddo
        if (longoutput) then
                write(iout,"('Long-range radius for center ',i4,' (',a2,') = ', e12.5, ' lcorto = ', 30(i3))") &
                        ia, atmnms(nzn(ia)), rlargo(ia), lcorto(1:nintervaj,ia)
        else
                write(iout,"('Long-range radius for center ',i4,' (',a2,') = ', e12.5)") &
                        ia, atmnms(nzn(ia)), rlargo(ia)
        endif
    enddo
    return
    end
	
!   ***************************************************************

  subroutine densrepr(ia, x, y, z, denrep, dendrvx, dendrvy, dendrvz, denlplc, dxx, dxy, dxz, dyy, dyz, dzz)
    USE DAM320_T
    USE DAMDEN320_T
    USE DAM320_CONST_T
    USE DAM320_DATA_T
    implicit none
    integer(KINT) :: i, ia, icflm, interv, j, jshft, kntlm, l, m
    real(KREAL) :: aux, bux, cux, denrep, denlplc, dendrvx, dendrvy, dendrvz, dost, dux, drvflm, drv2flm
    real(KREAL) :: dxx, dxy, dxz, dyy, dyz, dzz, eux, flm, fux
    real(KREAL) :: r3inv, ra, ra2, rainv, rj2, sgn, t, umt2i, x, xa, xadivra, y, ya, yadivra, z, za, zadivra
    integer(KINT), parameter :: idimzlm = (mxlexp+2)**2
    real(KREAL) :: tcheb(0:mxlenpol-1), ucheb(0:mxlenpol-1), drvtcheb(0:mxlenpol-1), drv2tcheb(0:mxlenpol-1)
    real(KREAL) :: zlma(idimzlm), zlmadx(idimzlm), zlmady(idimzlm), zlmadz(idimzlm)
    real(KREAL) :: zlmadxx(idimzlm), zlmadxy(idimzlm), zlmadxz(idimzlm), zlmadyy(idimzlm), zlmadyz(idimzlm), zlmadzz(idimzlm)
!	Contribution of atomic fragment ia to density  in point (x,y,z)
    denrep = cero
    dendrvx = cero
    dendrvy = cero
    dendrvz = cero
    dxx = cero
    dxy = cero
    dxz = cero
    dyy = cero
    dyz = cero
    dzz = cero
    if (ngini(ia) .le. 0) then
        return
    endif
    xa = x - rcen(1,ia)
    ya = y - rcen(2,ia)
    za = z - rcen(3,ia)
    ra2 = xa*xa+ya*ya+za*za
    if (ra2 .gt. rlargo(ia)*rlargo(ia)) then
        return
    endif
    ra = sqrt(ra2)
    if (ra .lt. rlargo(ia)) then
            interv = indintrv(int(fct*ra)+1)
    else
            interv = nintervaj
    endif
    rainv = uno / ra
    xadivra = xa * rainv
    yadivra = ya * rainv
    zadivra = za * rainv
    zlma(1) = uno		! Regular spherical harmonics of r-R(ia)
    zlma(2) = ya
    zlma(3) = za
    zlma(4) = xa
    do l = 1, lcorto(interv,ia)
        zlma((l+1)*(l+3)+1) = dosl1(l) * (xa * zlma(l*(l+2)+1) - ya * zlma(l*l+1))		! zlm(l+1,l+1,ia)
        zlma((l+1)*(l+1)+1) = dosl1(l) * (ya * zlma(l*(l+2)+1) + xa * zlma(l*l+1))		! zlm(l+1,-(l+1),ia)
        zlma((l+2)*(l+2)-1) = dosl1(l) * za* zlma(l*(l+2)+1)				! zlm(l+1,l,ia)
        zlma(l*(l+2)+3) = dosl1(l) * za * zlma(l*l+1)					! zlm(l+1,-l,ia)
        do m = 0, l-1
                zlma((l+1)*(l+2)+m+1) = ri(l-m+1) * (dosl1(l)*za*zlma(l*(l+1)+m+1) - re(l+m)*ra2*zlma((l-1)*l+m+1))	! zlm(l+1,m,ia)
                zlma((l+1)*(l+2)-m+1) = ri(l-m+1) * (dosl1(l)*za*zlma(l*(l+1)-m+1) - re(l+m)*ra2*zlma((l-1)*l-m+1))	! zlm(l+1,-m,ia)
        enddo
    enddo
    if (lgradient) then
        call derivzlm(lcorto(interv,ia), idimzlm, zlma, zlmadx, zlmady, zlmadz)
        if (lderiv2) then
            call derivzlm(lcorto(interv,ia), idimzlm, zlmadx, zlmadxx, zlmadxy, zlmadxz)
            call dzlm2y(lcorto(interv,ia), idimzlm, zlmady, zlmadyy, zlmadyz)
            call dzlm2z(lcorto(interv,ia), idimzlm, zlmadz, zlmadzz)
        endif
        aux = exp(-xajustd(interv,ia)*ra)
        bux = xajustd(interv,ia)
        cux = dos / (rinterv(interv)-rinterv(interv-1))
        t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
        dost = t + t
        tcheb(0) = uno		! Chebyshev T and U polynomials (U polynomial are used for derivatives of T polynomials
        tcheb(1) = t		! and first and second derivatives of T polynomials according to:
        ucheb(0) = uno		!			D[T_n(t),t] = n * U_(n-1)(t)
        ucheb(1) = dost	!	and:		D[T_n(t),{t,2}] = (n/(t^2-1)) * ( (n-1)*t*U_(n-1) - n * U_(n-2) )
        drvtcheb(0) = cero
        drvtcheb(1) = uno
        sgn = uno
        do j = 2, mxlenpol-1
            tcheb(j) = dost * tcheb(j-1) - tcheb(j-2)
            ucheb(j) = dost * ucheb(j-1) - ucheb(j-2)
            drvtcheb(j) = re(j) * ucheb(j-1)
        enddo
        drv2tcheb(0) = cero
        drv2tcheb(1) = cero
        if (uno-abs(t) .gt. 1.d-7) then
            umt2i = uno / (t*t - uno)
            do j = 2, mxlenpol-1
                drv2tcheb(j) = re(j) * umt2i * (re(j-1) * t * ucheb(j-1) - re(j) * ucheb(j-2))
            enddo
        else	! For values of t very close to 1 or -1, takes a linear approximation (Taylor series) of D[T[j,t],{t,2}]
            do j = 2, mxlenpol-1
                rj2 = re(j) * re(j)
                drv2tcheb(j) = sgn * ri(3) * (rj2 * (rj2-uno) + ri(5) * rj2 * (re(4)+rj2*(-re(5)+rj2)) * (abs(t)-uno) )
                if (t .lt. cero) sgn = - sgn
            enddo
        endif

        denrep = cero
        denlplc = cero
        kntlm = lminrep*lminrep
        do l = lminrep, lcorto(interv,ia)	!     Computes density terms lminrep <= l <= lcorto(interv,ia)
            do m = -l, l
                kntlm = kntlm + 1
                icflm = icfposd(kntlm+(interv-1)*lmtop,ia)
                if(icflm .lt. icfposd(kntlm+(interv-1)*lmtop+1,ia)) then
                    flm = cero
                    drvflm = cero
                    drv2flm = cero
                    do j = 0, icfposd(kntlm+(interv-1)*lmtop+1,ia)-icflm-1
                        flm = flm + cfajust(j+icflm) * tcheb(j)
                        drvflm = drvflm + cfajust(j+icflm) * drvtcheb(j)
                        drv2flm = drv2flm + cfajust(j+icflm) * drv2tcheb(j)
                    enddo
                    flm = aux * flm
                    drvflm = cux * aux * drvflm		! Converts the derivative with respect to t to derivative respect to r
                    drv2flm = cux * cux * aux * drv2flm	! Same for second derivative
                    drv2flm = bux * (bux * flm - (drvflm+drvflm)) + drv2flm	! D[flm,{r,2}]
                    drvflm = -bux * flm + drvflm							! D[flm,r]
                    denrep = denrep + flm * zlma(kntlm)
                    dendrvx = dendrvx + xadivra * drvflm * zlma(kntlm) + flm * zlmadx(kntlm)
                    dendrvy = dendrvy + yadivra * drvflm * zlma(kntlm) + flm * zlmady(kntlm)
                    dendrvz = dendrvz + zadivra * drvflm * zlma(kntlm) + flm * zlmadz(kntlm)
                    if (lderiv2) then
                        r3inv = rainv * rainv * rainv
                        fux = r3inv * (ra * drv2flm - drvflm)
                        dxx = dxx + (xa*xa * fux + drvflm * rainv) * zlma(kntlm) &
                                + dos * xadivra * drvflm * zlmadx(kntlm) + flm * zlmadxx(kntlm)
                        dyy = dyy + (ya*ya * fux + drvflm * rainv) * zlma(kntlm) &
                                + dos * yadivra * drvflm * zlmady(kntlm) + flm * zlmadyy(kntlm)
                        dzz = dzz + (za*za * fux + drvflm * rainv) * zlma(kntlm) &
                                + dos * zadivra * drvflm * zlmadz(kntlm) + flm * zlmadzz(kntlm)
                        dxy = dxy + xa*ya * fux * zlma(kntlm) + xadivra * drvflm * zlmady(kntlm) &
                                + yadivra * drvflm * zlmadx(kntlm) + flm * zlmadxy(kntlm)
                        dxz = dxz + xa*za * fux * zlma(kntlm) + xadivra * drvflm * zlmadz(kntlm) &
                                + zadivra * drvflm * zlmadx(kntlm) + flm * zlmadxz(kntlm)
                        dyz = dyz + ya*za * fux * zlma(kntlm) + yadivra * drvflm * zlmadz(kntlm) &
                                + zadivra * drvflm * zlmady(kntlm) + flm * zlmadyz(kntlm)
                    endif
                endif
            enddo
        enddo
    else
        aux = exp(-xajustd(interv,ia)*ra)
        t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
        dost = t + t
        tcheb(0) = uno	! Chebyshev T  polynomials
        tcheb(1) = t
        do j = 2, mxlenpol-1
            tcheb(j) = dost * tcheb(j-1) - tcheb(j-2)
        enddo
        denrep = cero
        kntlm = lminrep*lminrep
        do l = lminrep, lcorto(interv,ia)	!     Computes density terms lminrep <= l <= lcorto(interv,ia)
            do m = -l, l
                kntlm = kntlm + 1
                icflm = icfposd(kntlm+(interv-1)*lmtop,ia)
                if(icflm .lt. icfposd(kntlm+(interv-1)*lmtop+1,ia)) then
                    flm = cero
                    do j = 0, icfposd(kntlm+(interv-1)*lmtop+1,ia)-icflm-1
                        flm = flm + cfajust(j+icflm) * tcheb(j)
                    enddo
                    denrep = denrep + aux * flm * zlma(l*(l+1)+m+1)
                endif
            enddo
        enddo
    endif
    return
    end
	
