!  Copyright 2013-2021, Jaime Fernandez Rico, Rafael Lopez, Ignacio Ema,
!  Guillermo Ramirez, Anmol Kumar, Sachin D. Yeole, Shridhar R. Gadre
! 
!  This file is part of DAM320.
! 
!  DAM320 is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation, either version 3 of the License, or
!  (at your option) any later version.
! 
!  DAM320 is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
! 
!  You should have received a copy of the GNU General Public License
!  along with DAM320.  If not, see <http://www.gnu.org/licenses/>.
!
!------------------------------------------------------------------------
! 
! Program for the analytical representation of the molecular density in terms of atomic fragments, these latter given as expansions
! of spherical harmonics times radial factors.
! 
! The program fits the radial factors to piecewise functions.
!
! Every piece of the radial factors consist of Chebyshev T polynomials of the variable
! 
!      t = 2 (r - l0) / (l1 - l0) - 1
!
! where l0 and l1 are the lower and upper boundaries of the corresponding interval of r. 
!
! The polynomials can be (optionally) multiplied by exponentials of minus a given exponent times r
!
! The intervals with exponentials are user-defined and the exponents can be supplied in the input or dynamically fitted
!
! The coefficients of the polynomials are computed by least-squares fitting
!
! It also computes the auxiliary integrals for the electrostatic potential and electric field.
!
! Data can be read from standard input data alone (general input: lgeninp = .true.)
! or from standard input and the files generated by SMILES (default):
!	*.gbs with geometry and basis set  and   *.den  with the density matrix.
!
! Requires the file DAM320_GLOBAL.F90 which must be compiled first (contains the modules)
!
! Parallel version with MPI
!
! Version of July 2023
!
!===============================================================================================
!                 MODULE GENCONTRACTMOD
!===============================================================================================
MODULE GENCONTRACTMOD
   USE DAM320_D
   IMPLICIT NONE
   type basishell
       integer(KINT) :: ncontr
       integer(KINT) :: nexp       ! number of exponents
       integer(KINT) :: lval
       integer(KINT) :: nprim
       real(KREAL), allocatable :: exp(:)
       integer(KINT), allocatable :: offset(:)  ! offset for functions index in molecular basis set
       real(KREAL), allocatable :: norm
       real(KREAL), allocatable :: coef(:,:)   ! contraction coefficients: first index: # primitives, second: # contractions
   end type
   type basisgencontr
       integer(KINT) :: lmax
       integer(KINT) :: nshells    ! number of shells (lmax+1)
       integer(KINT) :: nfuncs     ! number of basis functions
       integer(KINT) :: ncontractions     ! number of contractions
       type(basishell), allocatable :: shells(:)   ! shells (set of contracted functions with same l value)
   end type
   type(basisgencontr), allocatable :: basis(:)
   real(KREAL), allocatable :: biv(:,:)
   integer(KINT), allocatable :: knti1i2v(:,:)
   integer(KINT) :: kntcoefa(0:mxl), kntcoefb(0:mxl)
END MODULE
!
!                 END OF MODULE GENCONTRACTMOD
!...............................................................................................
  program GDAM320_mpi
    USE MPI
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE GAUSS
    USE PARALELO
    implicit none
    integer(KINT) :: i, ia, icen, idlt, ierr, intervaux, irank, ishift, ishiftnw, j, k, kj, knt, kntlm
    integer(KINT) :: l, la, leninamelist, lenrnamelist, lm, m, ma
    real(KREAL) :: aux, bux, qe, qn, qt, rant
    logical :: lprint
    real(KREAL4) :: tarray(2), tiempo, dtime
    real(KREAL4), allocatable :: timeprocs(:)
    real(KREAL) :: qlm((mxmult+1)**2), qlmnuc((mxmult+1)**2)
    logical :: lnamelist(5), ltimeprocs
    integer(KINT), allocatable, dimension(:) :: inamelist, lengthscf, idisp, jjlen, ncenranks
    real(KREAL), allocatable :: rnamelist(:)
    integer(KINT) :: icfaux(2)
    namelist / options / ioptaj, iswindows, lmaxexp, lmultmx, longoutput, lvalence, lzdo, umbral, umbralres
    call MPI_INIT(ierr)
    call MPI_COMM_SIZE(MPI_COMM_WORLD, nprocs, ierr)
    call MPI_COMM_RANK(MPI_COMM_WORLD, myrank, ierr)
    abort = 0
    abortroot = 0
    if (myrank .eq. 0) write(6,"('number of processors = ', i8)") nprocs
    tiempo = dtime(tarray)

!	Defaults for the NAMELIST OPTIONS
    longoutput = .false.	! If .true. a more detailed output is given
    lvalence = .false.      ! If .true. only valence electrons are considered
    lzdo = .false.          ! If .true. ZDO approximation holds
    lmaxexp = 10			! Highest value of  l  in the expansion
    lmultmx = 5             ! highest l of multipoles whose modules are stored
    ioptaj = 1              ! 1: fits the total density  (default)
                            ! 2: fits the one-center part of the density
                            ! 3: fits the two-center part of the density
    umbral = 1.d-12         ! Threshold for neglecting radial factors
    umbralres = 1.d-12      ! Threshold for truncating radial factors expansions
    iswindows = .false.		! .true. if running on a MS-windows system
!	End of Defaults for the NAMELIST OPTIONS

    ltimeprocs = .false.
    lgbsgz = .false.
    lden = .false.
    ldengz = .false.
    ldensprsbin = .false.
    if (myrank .eq. 0) then
!	Reads the namelist OPTIONS
        read(5,OPTIONS)
        read(5,*) projectname
        write(6,"(1x,'project name : ',a,/,1x,'==============')") projectname
        if (iswindows) then
            dirsep = "\\"
            i = index(projectname,dirsep,.true.)	! Checks position of last directory name separator
            if (i .eq. 0) then	! This is intended for MinGW, whose directory separator in windows is also /
                    dirsep = "/"
                    i = index(projectname,dirsep,.true.)	! Checks position of last directory name separator
            endif
        else
            dirsep = "/"
            i = index(projectname,dirsep,.true.)	! Checks position of last directory name separator
        end if

        if (lzdo) then
            write(6,"(/'IMPORTANT: ZDO approximation used, fits one-center part of density',/)")
            ioptaj = 2
        endif

        leninamelist = 3
        lenrnamelist = 2
        icfaux(1) = leninamelist
        icfaux(2) = lenrnamelist
        lgbsgz = .false.	! Checks whether the .ggbs file is gzipped or not
        inquire(file=trim(projectname)//".ggbs.gz", exist=lgbsgz, iostat=ierr)
        if (ierr .eq. 0 .and. lgbsgz) then
            call system ("gunzip "//trim(projectname)//".ggbs.gz")
        endif
        ldengz = .false.	! Checks whether the .den file is gzipped or not
        inquire(file=trim(projectname)//".den.gz", exist=ldengz, iostat=ierr)
        if (ierr .eq. 0 .and. ldengz) then
            call system ("gunzip "//trim(projectname)//".den.gz")
        endif
        inquire(file=trim(projectname)//".den", exist=lden, iostat=ierr)
        if (.not.(ierr .eq. 0 .and. lden)) then
            inquire(file=trim(projectname)//".densprsbin", exist=ldensprsbin, iostat=ierr)
        endif
        if (.not. (lden .or. ldensprsbin)) then
            write(6,"('No density matrix available ')")
            abort = 1
        else
            allocate(timeprocs(2*nprocs), stat = ierr)
            if (ierr .eq. 0) then
                ltimeprocs = .true.
                timeprocs = 0.
            else
                write(6,"('WARNING: Memory error when allocating timeprocs, ierr =  ',i5)") ierr
                ltimeprocs = .false.
            endif
            lnamelist = (/ longoutput, iswindows, ltimeprocs, lvalence, lzdo /)
        endif
    endif
    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
        call error(1,'Stop')
    endif
    CALL MPI_BCAST(projectname,len(projectname),MPI_CHARACTER,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(lnamelist,5,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(icfaux,2,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
    if (myrank .gt. 0) then
        leninamelist = icfaux(1)
        lenrnamelist = icfaux(2)
    endif

    allocate(inamelist(leninamelist), rnamelist(lenrnamelist), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating inamelist and rnamelist in processor ',i8)") myrank
        abort = 1
    endif
    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
        call error(1,'Stop')
    endif
    if (myrank .eq. 0 .and. longoutput) write(6,"('Size of inamelist   = ', i15, ' bytes')") size(inamelist)
    if (myrank .eq. 0 .and. longoutput) write(6,"('Size of rnamelist   = ', i15, ' bytes')") size(rnamelist)
    if (myrank .eq. 0)	then
        inamelist(1:3) = (/ lmaxexp, ioptaj, lmultmx /)
        rnamelist(1) = umbral
        rnamelist(2) = umbralres
    endif
    CALL MPI_BCAST(inamelist,leninamelist,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(rnamelist,lenrnamelist,MPI_REAL8,0,MPI_COMM_WORLD,ierr)
    if (myrank .ne. 0) then
        longoutput = lnamelist(1); iswindows = lnamelist(2); ltimeprocs = lnamelist(3)
        lvalence = lnamelist(4); lzdo = lnamelist(5)
        lmaxexp = inamelist(1); ioptaj = inamelist(2); lmultmx = inamelist(3)
        umbral = rnamelist(1)
        umbralres = rnamelist(2)
    endif

    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
        call error(1,'Stop')
    endif



    call consta1	!	Computes and stores several auxiliary constants and functions

!	Reads geometry and basis set generated by an external program
    call readggbs
    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
        call error(1,'Stop')
    endif
    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    if (lzdo) then
        lmaxexp = 2*lmaxbase
        lmultmx = min(lmultmx,lmaxexp)
    endif

    lmtop = (lmaxexp+1)*(lmaxexp+1)
    mxltot = mxldst + lmaxexp
    mxtpw = 2*lmaxexp+mxlenpol+3
    call consta2    !    Computes and stores further auxiliary constants and functions
    
!	Allocates buffers for procesors load distribution
    allocate(istav(0:nprocs-1), iendv(0:nprocs-1), ilenv(0:nprocs-1), idispv(0:nprocs-1), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating istav, iendv in processor ',i8)") myrank
        abort = 1
    endif
    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
        call error(1,'Stop')
    endif
        
!     Reads the density matrix
    if (myrank .eq. 0) then
        if (lden) then
            call readden
            if (abort .eq. 0) then
                call para_range_den
                call totalchargeGTO
            endif
            if (ldengz) then	! restores files back to their original gzipped status
                call system ("gzip "//trim(projectname)//".den")
            endif
            if (lgbsgz) then
                call system ("gzip "//trim(projectname)//".ggbs")
            endif
        else if(ldensprsbin) then
            call readdensprsbin
            if (abort .eq. 0) then
                call para_range_densprsbin
                call totalchargeGTO
            endif
        else
            write(6,"('No density matrix available ')")
            abort = 1
        endif
    endif
    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
        call error(1,'Stop')
    endif
    
    CALL MPI_BCAST(istav,nprocs,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(iendv,nprocs,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)

    if (ncen .lt. nprocs) then
! 		if (myrank .eq. 0) 
            write(6,"('Number of centers lower than number of processors.',/,'Rerun with a lower&
                    &number of processors (lower than or equal to the number of centers).')")
        abort = 1
    endif
    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
        call error(1,'Stop')
    endif

    if (myrank .eq. 0 .and. longoutput) then
        write(6,"('istav = ', 20(1x,i5))") istav(0:nprocs-1)
        write(6,"('iendv = ', 20(1x,i5))") iendv(0:nprocs-1)
    endif
    idispv(0) = 0
    do i = 0, nprocs-2
        ilenv(i) = (iendv(i)-istav(i)+1) * max(25,lmtop)
        idispv(i+1) = idispv(i) + ilenv(i)
    enddo
    ilenv(nprocs-1) = (iendv(nprocs-1)-istav(nprocs-1)+1) * max(25,lmtop)
    istart = istav(myrank)
    iend = iendv(myrank)
    if (myrank .eq. 0 .and. longoutput) write(6,"('in proc ', i8, ' istart = ', i5, ' iend = ', i5)") myrank, istart, iend
!	writes geometry in .xyz file for gOpenMol compatibility
    if (myrank .eq. 0) then
        open(99,file=trim(projectname)//".xyz",form='formatted', iostat=ierr)
        if (ierr .ne. 0) then
            write(6,"('Cannot open file ', a, ' in processor ',i8)") trim(projectname)//".xyz", myrank
        else
            write(99,*) ncen
            write(99,*)
            do ia = 1, ncen
                write(99,"(a2,3f15.10)") atmnms( int(zn(ia)) ), (rcen(j,ia)*0.529177249d0,j=1,3)
            end do
            close(99)
        endif
    endif

    if (myrank .eq. 0) then
        if (ioptaj .eq. 1) then	! Case 1: fits the total density
            write(6,"(/,'Fits the total density',/)")
        elseif (ioptaj .eq. 2) then	 ! Case 2: fits only the one-center part
            write(6,"(/,'Fits only the one-center terms of the density',/)")
        else						! Case 3: fits only the two-center part
            write(6,"(/,'Fits only the two-center terms of the density',/)")
        endif
        write(6,"('Cutoff for radial factors = ', e12.5)") umbral
        write(6,"('Threshold for radial factors projection = ', e12.5,/)") umbralres
    endif
    
!     Reads the density matrix chuncks for processors
    if (myrank .eq. 0) then
        if (lden) then
            call createdenprocs
        else if(ldensprsbin) then
            call createdensprsbinprocs
        else
            write(6,"('No density matrix available ')")
            abort = 1
        endif
        deallocate(dmat)
    endif
    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
        call error(1,'Stop')
    endif
    
!	Piecewise fitting of the radial factors
    if (lgencontract) then
       call gencontract
       call ajustagencontract
    else
       call ajusta
    endif

    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
        call error(1,'Stop')
    endif

    if (myrank .eq. 0) then
        allocate(rmultip(max(25,lmtop),ncen), stat = ierr)
        if (ierr .ne.0) then
            write(6,"('Error when allocating rmultip in processor ',i8)") myrank
            abort = 1
        endif
    endif
    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
        call error(1,'Stop')
    endif

    CALL MPI_GATHERV(rmultipfr, ilenv(myrank), MPI_REAL8, rmultip, ilenv, idispv, MPI_REAL8, 0, MPI_COMM_WORLD, ierr)
    if (ierr .ne.0) then
        write(6,"('Error gathering rmultip in processor ',i8)") myrank
        abort = 1
    endif

! 	do ia = 1, ncen
! 	write(6,"('rmultip(',i8,') = ', 10(1x,e17.10))") ia, rmultip(1:lmtop,ia)
! 	enddo
    CALL MPI_REDUCE(abort,abortroot,1,MPI_INTEGER,MPI_SUM,0,MPI_COMM_WORLD,ierr)
    CALL MPI_BCAST(abortroot,1,MPI_LOGICAL,0,MPI_COMM_WORLD,ierr)
    if (abortroot .gt. 0) then
        call error(1,'Stop')
    endif
    deallocate(rmultipfr)

    if (myrank .eq. 0) then
        if (lvalence) then
            write(6,"(/,5x,'Non-vanishing atomic multipolar moments of electron valence (absolute value higher than 10^-10)')")
            write(6,"(5x,'defined as the coefficients that multiply the UNNORMALIZED irregular harmonics in the expansion')")
            write(6,"(5x,'of the long-range potential multiplied by sqrt((1+delta(m,0)) * (l+|m|)! / (l-|m|)!) to keep them')")
            write(6,"(5x,'rotationally invariant except in case of l = 0, in which case the valence electron charge is quoted')")
        else
            write(6,"(/,5x,'Non-vanishing atomic multipolar moments of electron cloud (absolute value higher than 10^-10)')")
            write(6,"(5x,'defined as the coefficients that multiply the UNNORMALIZED irregular harmonics in the expansion')")
            write(6,"(5x,'of the long-range potential multiplied by sqrt((1+delta(m,0)) * (l+|m|)! / (l-|m|)!) to keep them')")
            write(6,"(5x,'rotationally invariantexcept in case of l = 0, in which case the electron charge is quoted')")
        endif
        write(6,"(/13x,'  atom     la    ma  ', 13x, 'value' &
                ,/13x,8('-'),2x,4('-'),2x,4('-'),4x,24('-'))")
        do ia = 1, ncen
            kntlm = 0
            lprint = .true.
            do l = 0, lmultmx
                do m = -l, l
                    kntlm = kntlm+1
                    if (m .eq. 0 .and. l .ne. 0) then
                        bux = dos
                    else
                        bux = uno
                    endif
                    aux = sqrt(bux * fact(l+abs(m)) * facti(l-abs(m)))
                    if (abs(rmultip(kntlm,ia)) * aux .gt. 1.d-10) then
                        if (lprint) then
                            write(6,"(/13x,a2, 1x, i8, 2x, i3, 3x, i3, 6x,e22.15)") atmnam(ia), ia, l, m, &
                                    -rmultip(kntlm,ia) * aux
                            lprint = .false.
                        else
                            write(6,"(26x, i3, 3x, i3, 6x,e22.15)") l, m, -rmultip(kntlm,ia) * aux
                        endif
                    endif
                enddo
            enddo
        enddo
!		Computes the total molecular multipolar moments from the atomic moments
        call multmolec(qlm, qlmnuc)
        if (lvalence) then
            write(6,"(/12x, ' molecular multipole components (nuclei+core electrons, valence electrons, total)', /1x, 100('='))")
        else
            write(6,"(/12x, ' molecular multipole components (nuclei, electrons, total)', /1x, 100('='))")
        endif
        kntlm = 0
        do l = 0, mxmult
            write(6,"(/57x,'L = ', i2,/57x,6('='),/)") l
            do m = -l, l
                kntlm = kntlm + 1
                qn = qlmnuc(kntlm)
                if (abs(qn) .lt. 1.d-13) qn = cero
                qe = qlm(kntlm)
                if (abs(qe) .lt. 1.d-13) qe = cero
                qt = qlm(kntlm)+qlmnuc(kntlm)
                if (abs(qt) .lt. 1.d-13) qt = cero
                write(6,"(5x,'q(',i2,',',i3,'): ',8x,3(2x,d22.15))") l, m, qn, qe, qt
            enddo
        enddo
    endif
    call MPI_BARRIER(MPI_COMM_WORLD, ierr)
    tiempo = dtime(tarray)
!    write(6,"(1x,'Timing in seconds of processor ', i2, ' (user, system, total):',5x,'(',e12.5,',',e12.5,',',e12.5')')") &
!            myrank, tarray(1), tarray(2), tarray(1)+tarray(2)
    if (ltimeprocs) then
        CALL MPI_GATHER(tarray, 2, mpi_real4, timeprocs, 2, mpi_real4, 0, MPI_COMM_WORLD, ierr)
        if (ierr .eq. 0 .and. myrank .eq. 0) then
            write(6,"(/30x,'TIMING (in seconds)',/)")
            do i = 0, nprocs-1
                write(6,"(1x,'Processor ', i2, ' (user, system, total):',5x,'(',e12.5,',',e12.5,',',e12.5')')") &
                    i, timeprocs(2*i+1), timeprocs(2*i+2), timeprocs(2*i+1)+timeprocs(2*i+2)
            enddo
            write(6,"(' ')")
        endif
    endif
    if (myrank .eq. 0) then
        call system("cat "//trim(projectname)//"_2016.damqt_?? > "//trim(projectname)//"_2016.damqt")
        call system("rm -f "//trim(projectname)//"_2016.damqt_??")
        call system("cat "//trim(projectname)//"_2016.dmqtv_?? > "//trim(projectname)//"_2016.dmqtv")
        call system("rm -f "//trim(projectname)//"_2016.dmqtv_??")
        call system("cat "//trim(projectname)//".mltmod_?? > "//trim(projectname)//".mltmod")
        call system("rm -f "//trim(projectname)//".mltmod_??")
        call system("rm -f "//trim(projectname)//".den_??")
    endif
    call MPI_FINALIZE(ierr)
    stop
    end
!
!   ***************************************************************
!
  subroutine gencontract
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE GAUSS
    USE GENCONTRACTMOD
    implicit none
    logical lfound
    integer(KINT) :: i, icaps, ierr, j, k, m, n
    integer(KINT)  :: iexprim(lmaxbase+1), kcontrshell(lmaxbase+1), ncontrshell(lmaxbase+1), nprimshell(lmaxbase+1)
!    write(6,*) 'entra en gencontract'

    allocate(basis(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating basis. Stop')
    icaps = 0
    do i = 1, ncen
       basis(i)%nshells = 1
       ncontrshell = 0
       nprimshell = 0
       do j = 1, ncontr(i)
          basis(i)%nshells = max(basis(i)%nshells,ll(icaps+j)+1)
          ncontrshell(ll(icaps+j)+1) = ncontrshell(ll(icaps+j)+1) + 1
          if (nprimit(icaps+j) .gt. nprimshell(ll(icaps+j)+1)) then
             nprimshell(ll(icaps+j)+1) = max(nprimshell(ll(icaps+j)+1), nprimit(icaps+j))
             iexprim(ll(icaps+j)+1) = icaps+j
          endif
       enddo
       basis(i)%lmax = basis(i)%nshells - 1
       basis(i)%ncontractions = ncontr(i)
       allocate(basis(i)%shells(basis(i)%nshells), stat = ierr)
       if (ierr .ne. 0) call error(1,'Memory error when allocating basis(i)%shells. Stop')
       do j = 1, basis(i)%nshells
          basis(i)%shells(j)%nprim = nprimshell(j)
          basis(i)%shells(j)%lval = j-1
          allocate(basis(i)%shells(j)%exp(nprimshell(j)), &
             basis(i)%shells(j)%coef(nprimshell(j),ncontrshell(j)), &
             stat = ierr)
          if (ierr .ne. 0) call error(1,'Memory error when allocating basis(i)%shells(j)%(exp and coef). Stop')
          basis(i)%shells(j)%coef = cero
          basis(i)%shells(j)%ncontr = 0
          k = iexprim(j)
          basis(i)%shells(j)%exp = xxg(ipntprim(k):ipntprim(k) + nprimit(k) - 1)
       enddo
       do j = 1, ncontr(i)
          k = ll(icaps+j)+1
          basis(i)%shells(k)%ncontr = basis(i)%shells(k)%ncontr + 1
          dom: do m = 1, nprimit(icaps+j)
             lfound = .false.
             do n = 1, size(basis(i)%shells(k)%exp)
                if (abs(xxg(ipntprim(icaps + j)+m-1) - basis(i)%shells(k)%exp(n)) .lt. 1.d-10) then
                   basis(i)%shells(k)%coef(n,basis(i)%shells(k)%ncontr) = cfcontr(ipntprim(icaps+j)+m-1)
                   lfound = .true.
                   cycle dom
                endif
             enddo
             if (.not. lfound) then
                call error(1,'Error identifying primitive exponent. Stop')
             endif
          enddo dom
       enddo
!        do j = 1, basis(i)%nshells
!           write(6,"('atom # ', i3, '    shell # ', i3)") i, j
!           do k = 1, basis(i)%shells(j)%ncontr
!              write(6,"('coeficients of contraction # ', i2, ' = ', 10(1x,e12.5))") k, basis(i)%shells(j)%coef(:,k)
!           enddo
!        enddo
       icaps = icaps + ncontr(i)
    enddo

    return
    end
!
!	***************************************************************
!
  subroutine escribebase
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE GAUSS
    implicit none
    integer(KINT) :: i, ia, icarga, ierr, j, k, knt, lm
    real(KREAL) :: aux
!	Writes basis set information to file  'projectname'_2016.damqt

!	first record:
!			ncen: number of centers
!			nbas: number of basis functions
!			ncaps: number of shells in the basis set
    write(10) ncen, nbas, ncaps
!	Geometry and nuclear charges
    do ia = 1, ncen
        write(10) rcen(1,ia), rcen(2,ia), rcen(3,ia), zn(ia)
    enddo
!	End of geometry and nuclear charges

!	Basis set information
    write(10) .false.	! .false. means GTO basis, .true. means STO basis
    write(10) nprimitot
    knt = 0
    icarga = 0
    do ia = 1, ncen
        write(10) ncontr(ia)
        if (ncontr(ia) .le. 0) cycle
!               if (longoutput) write(6,"(/,'center = ', i8,' number of contractions = ', i4)") ia,  ncontr(ia)
        do j = 1, ncontr(ia)
            knt = knt + 1
! 			if (longoutput) write(6,"('Contraction no. ', i4, ' no. primitives = ', i3, ' l = ', i3)") j, nprimit(knt), ll(knt)
            write(10) nprimit(knt), ll(knt)
! 			if (longoutput) write(6,"('Primitive exponents = ', 8(1x,e12.5))") xxg(icarga+1:icarga+nprimit(knt))
            write(10) xxg(icarga+1:icarga+nprimit(knt))
! 			if (longoutput) write(6,"('Contraction coefficients = ', 8(1x,e12.5))") cfcontr(icarga+1:icarga+nprimit(knt))
            write(10) cfcontr(icarga+1:icarga+nprimit(knt))
            icarga = icarga + nprimit(knt)
        enddo
    enddo

!	End of basis set information

    return
    end
!
!	***************************************************************
!
  subroutine readggbs
    USE MPI
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE GAUSS
    USE PARALELO
    implicit none
    integer(KINT) :: i, ia, icarga, ierr, indnf, indng, ios, j, k, k1, k2, knt, nbasis, ncapserr
    real(KREAL) :: aux, bux
    real(KREAL) :: xaux(mxprimit), cfaux(mxprimit)
    logical     :: lfound
!	Reads the number of centers
    open(15,file=trim(projectname)//".ggbs",form='formatted', iostat=ierr)
    if (ierr .ne. 0) then
        write(6,"('Cannot open file ', a, ' in processor ',i8)") trim(projectname)//".ggbs", myrank
        abort = 1
        return
    endif
    read(15,*) ncen

!	Allocates memory for geometry and basis set
    ncaps = mxcap ! just for allocating


    allocate(atmnam(ncen), ipntprim(ncaps), isort(mxprimit), ll(ncaps), lmaxc(ncen), ncontr(ncen), nf(ncaps), &
            nfcen(0:ncen), ngini(ncen), ngfin(ncen), nprimit(ncaps), nzn(ncen), nbasesac(0:ncen), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating atmnam, ipntprim, isort(, ll, lmaxc, ncontr, nf, &
            &nfcen, ngini, ngfin, nprimit, nzn, nbasesac, in processor ', i8)") myrank
        abort = 1
        return
    endif

    allocate(cfcontr0(mxcap*mxprimit), rcen(3,ncen), rnor(ncaps), xxg0(mxcap*mxprimit), zn(ncen), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rcen, rnor, xx, zn in processor ',i8)") myrank
        abort = 1
        return
    endif

!	Reads the number of centers, geometry and basis set 
    do ia = 1, ncen
        read(15,*) rcen(1,ia), rcen(2,ia), rcen(3,ia), zn(ia)
        if (abs(zn(ia)-re(int(zn(ia) + umbrzn))) .gt. umbrzn) then
            nzn(ia) = 0
        else
            nzn(ia) = int(zn(ia) + umbrzn)
        endif
        atmnam(ia) = atmnms(nzn(ia))
    enddo

!     Basis set::
!         for each center:
!              number of contractions
!              for each contraction:
!                   number of primitives
!                   l  quantum number
!                   exponents of the primitives
!                   contraction coefficients
!     Primitives are sorted in increasing order of exponents.
!     An array is created with pointers to the beginning of
!     exponents and coefficients of a contracted function.
!     Arrays  nf, ngini  and  ngfin are initialized.
!
!	Contraction coefficients correspond to the expansion in UNNORMALIZED primitives

    lmaxbase = 0
    ncaps = 0
    icarga = 0
    indnf = 1
    indng = 1
    ncaps = 0
    ncapserr = 0
    lmaxbase = 0
    nbasesac(0) = 0
    nfcen(0) = 0
    do ia = 1, ncen
        read(15,*) ncontr(ia)
        if (ncontr(ia) .le. 0) then
            ngini(ia) = -1
            ngfin(ia) = -1
            cycle
        endif
        ngini(ia) = indng
        ngfin(ia) = indng + ncontr(ia) - 1
        indng = indng + ncontr(ia)
        lmaxc(ia) = 0
        do j = 1, ncontr(ia)
            ncaps = ncaps + 1
            if (ncaps .gt. mxcap) then
                write(6,"('Error: maximum number of shells in basis set exceeded in processor ',i8)") myrank
                abort = 1
                return
            endif
            read(15,*) nprimit(ncaps), ll(ncaps)
            if (icarga+nprimit(ncaps) .gt. mxcap*mxprimit)  then
                write(6,"('Error: maximum number of total primitives exceeded. &
                        &\nChange parameter mxcap in DAMGLOBALxxxx.F90 and remake')")
                abort = 1
                return
            endif
            if (ll(ncaps) .gt. lmaxbase) lmaxbase = ll(ncaps)
            if (ll(ncaps) .gt. lmaxc(ia)) lmaxc(ia) = ll(ncaps)
            nf(ncaps) = indnf
            indnf = indnf + 2*ll(ncaps) + 1
            if(nprimit(ncaps) .gt. mxprimit) then
                write(6,"('Error: maximum number of primitives per contraction exceeded in processor ',i8)") myrank
                abort = 1
                return
            endif
            ipntprim(ncaps) = icarga+1
            read(15,*) (xaux(k), k = 1, nprimit(ncaps))
            read(15,*) (cfaux(k), k = 1, nprimit(ncaps))
!			sorts primitives
            call sort(nprimit(ncaps),xaux)
            do k = 1, nprimit(ncaps)
                xxg0(icarga+k) = xaux(k)
                cfcontr0(icarga+k) = cfaux(isort(k))
            enddo
! 			kntprim = kntprim + nprimit(ncaps)
!			computes and stores the radial normalization factor
            aux = cero
            bux = ll(ncaps) + 1.5d0
            do k1 = 1, nprimit(ncaps)
                do k2 = 1, k1-1
                    aux=aux + dos*cfcontr0(icarga+k1)*cfcontr0(icarga+k2)/(xaux(k1)+xaux(k2))**bux
                enddo
                aux = aux + cfcontr0(icarga+k1) * cfcontr0(icarga+k1) / (dos*xaux(k1))**bux
            enddo
            rnor(ncaps) = sqrt( dos / (facts(ll(ncaps))*aux) )
!			actualizes the index for loading
            icarga = icarga+nprimit(ncaps)
        enddo
        nfcen(ia) = indnf-1
        nbasesac(ia) = ncaps
    enddo
    nprimitot = icarga
    nbas = indnf-1

    allocate(xxg(nprimitot), cfcontr(nprimitot), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating xxg and cfcontr in processor ',i8)") myrank
        abort = 1
        return
    endif

    xxg(1:nprimitot) = xxg0(1:nprimitot)
    cfcontr(1:nprimitot) = cfcontr0(1:nprimitot)
    deallocate(xxg0, cfcontr0)

    if (ncaps .gt. mxcap .and. myrank .eq. 0) then
        if (myrank .eq. 0) then
                    write(6,"('Number of function shells = ', i8, ' higher  than maximum allowed = ',i8)")  ncaps, mxcap
                    write(6,"('Modify parameter  mxcap  in module DAM320_D of file DAM320_GLOBAL.F90 and recompile.')")
        endif
        abort = 1
        return
    endif
    if (lmaxbase .gt. mxl .and. myrank .eq. 0) then
        if (myrank .eq. 0) then
                write(6,"('Basis functions with not allowed values of  l. ')")
                write(6,"('Highest allowed value: ', i2 , ' Highest value in basis set: ', i2)") mxl, lmaxbase
        endif
        abort = 1
        return
    endif

    lgencontract = .true.
    icarga = 0
    knt = 0
    call flush(6)
    doia: do ia = 1, ncen
       if (ncontr(ia) .le. 0) cycle
       if (allocated(xxg0)) deallocate(xxg0)
       allocate(xxg0(nprimit(knt+1)))
       xxg0 = xxg(icarga+1:icarga+nprimit(knt+1))
       do j = 1, ncontr(ia)
          knt = knt + 1
          if (j .gt. 1) then
             if (ll(knt) .ne. ll(knt-1)) then
                deallocate(xxg0)
                allocate(xxg0(nprimit(knt)))
                xxg0 = xxg(icarga+1:icarga+nprimit(knt+1))
                icarga = icarga+nprimit(knt)
                cycle
             endif
             dok: do k = 1, nprimit(knt)
                lfound = .false.
                do k1 = 1, size(xxg0)
                   if (abs(xxg0(k1)-xxg(icarga+k)) .lt. 1.e-10) then
                      lfound = .true.
                      cycle dok
                   endif
                enddo
                if (.not. lfound) then
                   lgencontract = .false.
                   exit doia
                endif
             enddo dok
          endif
          icarga = icarga+nprimit(knt)
       enddo
    enddo doia

!	prints out the input data
    if (myrank .eq. 0) then
        write(6,"(/24x,'GEOMETRY (BOHR)')")
        write(6,"(/t1, ' no. of center:', t20, 'x', t32, 'y', t44, 'z', t56, 'charge', t67, 'n. of shells')")
        do ia = 1, ncen
            write(6,"(t4, i5, t13, f12.7, t25, f12.7, t37, f12.7, t51, f10.5, t73, i5)") &
                    ia, rcen(1,ia), rcen(2,ia), rcen(3,ia) , zn(ia), ngfin(ia)-ngini(ia)+1
        enddo
        write(6,"(27x,'GTO BASIS SET')")
        if (longoutput) then
            icarga = 0
            knt = 0
            do ia = 1, ncen
                if (ncontr(ia) .le. 0) cycle
                write(6,"(/1x,'atom no.',1x,i8,'(',a2,')')") ia, atmnam(ia)
                write(6,"(1x,'number of contractions = ',i4)") ncontr(ia)
                do j = 1, ncontr(ia)
                    knt = knt + 1
                    write(6,"(/1x,'contraction no. ',i4,' ; l = ',i2)") j,  ll(knt)
                    write(6,"('exponents: ', 8(1x,e12.5))") (xxg(icarga+k), k = 1, nprimit(knt))
                    write(6,"('coefficients: ', 8(1x,e12.5))") (cfcontr(icarga+k),k=1,nprimit(knt))
                    icarga = icarga+nprimit(knt)
                enddo
            enddo
        endif
        write(6,"(/'Is a general contracted BS: ',l)") lgencontract
        write(6,"('Number of basis functions = ', i8)") nbas
        write(6,"('Number of primitive functions = ', i8)") nprimitot
    endif
    return
    end
!
!	***************************************************************
!
  subroutine readden
    USE MPI
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE GAUSS
    USE PARALELO
    implicit none
    integer(KINT) :: i, ia, icarga, ierr, ios, j, k, k1, k2, knt, nbasis
    real(KREAL) :: aux, bux

!	Allocates the array containing the density matrix
    
    allocate(dmat(nbas,nbas), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating dmat.')")
        abort = 1
        return
    endif
    if (myrank .eq. 0 .and. longoutput) write(6,"('Estimated highest size of dmat   = ', i15, ' bytes')") size(dmat)

!	Reads the density matrix in lower triangle form:  read ((dmat(i,j), j = 1, i), i = 1, nbasis)

    open(16,file=trim(projectname)//".den",form='formatted', iostat=ierr)
    if (ierr .ne. 0) then
        write(6,"('Cannot open file ', a, ' in processor ',i8)") trim(projectname)//".den", myrank
        abort = 1
        return
    endif
    read(16,*, iostat = ios) nbasis, ((dmat(i,j),j=1,i),i=1,nbasis)
    if ( ios .ne. 0 .or. nbas .ne. nbasis  .and. myrank .eq. 0) then
        write(6,"('nbas = ', i5,' nbasis = ', i5)") nbas, nbasis
        write(6,"('ERROR reading density matrix. Check whether the density matrix correspond to this basis set.')")
        abort = 1
        return
    endif
    close(16)
    do i = 2, nbasis
        do j = 1, i-1
            dmat(j,i) = dmat(i,j)
        enddo
    enddo

    return
    end
!
!	***************************************************************
!
  subroutine readdensprsbin
    USE MPI
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE GAUSS
    USE PARALELO
    implicit none
    integer(KINT) :: i, ierr, ios

!	Reads the density matrix in lower triangle form:  read ((dmat(i,j), j = 1, i), i = 1, nbas)

#if _WIN32
    open (unit=16, file=trim(projectname)//".densprsbin", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0) call error(1,'Memory error when opening file '//trim(projectname)//".densprsbin")
#elif __INTEL_COMPILER
    open (unit=16, file=trim(projectname)//".densprsbin", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0) call error(1,'Memory error when opening file '//trim(projectname)//".densprsbin")
#else
    open (unit=16, file=trim(projectname)//".densprsbin", form='unformatted', action = 'read', access='stream', iostat=ierr)
    if (ierr .ne. 0) call error(1,'Memory error when opening file '//trim(projectname)//".densprsbin")
#endif

!	Allocates the array containing the density matrix
    allocate(dvec(nbas*(nbas+1)/2), ivec(nbas*(nbas+1)/2), jvec(nbas*(nbas+1)/2), dmat(nbas,nbas), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error ', i6,' when allocating dvec, ivec, jvec and dmat. Stop')") ierr
        abort = 1
        return
    endif

    do i=1,nbas*(nbas+1)/2
        read(16,end = 100, err = 100, iostat = ios) ivec(i), jvec(i), dvec(i)
    enddo

100 continue
    if (ios .eq. -1) then
        numdvec = i-1
        if (longoutput) write(6,"('Number of elements of density matrix read = ', i16)") numdvec
    else if ( ios .ne. 0 ) then
        write(6,"('ERROR ', i6, ' reading density matrix. Stop')") ios
        abort = 1
        return
    endif
    close(16)
    
    if ( maxval(ivec) .gt. nbas .or. maxval(jvec) .gt. nbas ) then
        write(6,"('Index on density matrix higher than number of basis functions.',& 
            &/'Check whether the density matrix correspond to this basis set.')")
        write(6,*) 'maxval(ivec) = ', maxval(ivec)
        write(6,*) 'maxval(jvec) = ', maxval(jvec)
        write(6,*) 'nbas = ', nbas
        abort = 1
        return
    endif
    
    write(6,"(/'Sparse density matrix read from binary file', a,/)") trim(projectname)//".densprsbin"
        
    dmat = cero
    do i = 1, numdvec
        dmat(ivec(i), jvec(i)) = dvec(i)
        dmat(jvec(i), ivec(i)) = dvec(i)
    enddo
    deallocate(dvec)
    return
    end
!
!	***************************************************************
!
!     Creates files with chuncks of density matrix to be used by the processors.
!     the elements of the density matrix are stored in the same order as they will be used
!     in the subroutine ajusta
  subroutine createdenprocs
    USE MPI
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D, kntblock_ori => kntblock
    USE GAUSS
    USE PARALELO, istart_ori => istart, iend_ori => iend
    implicit none
    integer(KINT) :: i1, i2, ia, ib, ierr, irank, istart, iend, iuni, knt, kntblock, ktot, la, lb, ma, mb, nfa, nfb, nelemden
    logical, allocatable :: lblockaux(:)
    character*4 :: strbux
    
    ktot = 0
    do irank = 0, nprocs-1
        write(strbux,'(i4.2)') irank
        iuni = 18 + irank
#if _WIN32
        open (unit=iuni, file=trim(projectname)//".den_"//trim(adjustl(strbux)), form='binary', &
                action = 'write', carriagecontrol='NONE', iostat=ierr)
        if (ierr .ne. 0)  then
            write(6,"('Memory error when opening file ', a,'.den_', a,'  in processor ',i8)") &
                    trim(projectname), trim(adjustl(strbux)), myrank
            abort = 1
            return
        endif
#elif __INTEL_COMPILER
        open (unit=iuni, file=trim(projectname)//".den_"//trim(adjustl(strbux)), form='binary', &
                action = 'write', carriagecontrol='NONE', iostat=ierr)
        if (ierr .ne. 0)  then
            write(6,"('Memory error when opening file ', a,'.den_', a,'  in processor ',i8)") &
                    trim(projectname), trim(adjustl(strbux)), myrank
            abort = 1
            return
        endif
#else
        open (unit=iuni, file=trim(projectname)//".den_"//trim(adjustl(strbux)), form='unformatted', &
                action = 'write', access='stream', iostat=ierr)
        if (ierr .ne. 0)  then
            write(6,"('Memory error when opening file ', a,'.den_', a,'  in processor ',i8)") &
                    trim(projectname), trim(adjustl(strbux)), myrank
            abort = 1
            return
        endif
#endif  
        istart = istav(irank)
        iend = iendv(irank)
        if (ioptaj .eq. 1) then
            if (nprocs .eq. 1) then
                nelemden = nbas * nbas
            elseif (irank .eq. 0) then
                nelemden = (nf(ngini(iend+1)) - 1) * nbas
            elseif (irank .eq. nprocs-1) then
                nelemden = (nbas - nf(ngini(istart)) + 1) * nbas
            else
                nelemden = (nf(ngini(iend+1)) - nf(ngini(istart))) * nbas
            endif
        else if (ioptaj .eq. 2) then
            nelemden = 0
            do ia = istart, iend
                do i1 = ngini(ia), ngfin(ia)
                    do i2 = ngini(ia), ngfin(ia)
                        nelemden = nelemden + (2*ll(i1)+1) * (2*ll(i2)+1)
                    enddo
                enddo
            enddo
        else if (ioptaj .eq. 3) then
            nelemden = 0
            do ia = istart, iend
                do ib = 1, ncen
                    if (ia .eq. ib) cycle
                    do i1 = ngini(ia), ngfin(ia)
                        do i2 = ngini(ib), ngfin(ib)
                            nelemden = nelemden + (2*ll(i1)+1) * (2*ll(i2)+1)
                        enddo
                    enddo
                enddo
            enddo
        endif
        write(iuni) nelemden
        knt = 0
        kntblock = 0
        allocate(lblockaux(ncen*(iend-istart+1)), stat = ierr)
        if (ierr .ne. 0) then
            write(6,"('Memory error when allocating lblockaux.')")
            abort = 1
            return
        endif
        do ia = istart, iend       ! Do over centers (ia) assigned to processor
            if (ngini(ia) .le. 0) cycle
            if (ioptaj .ne. 3) then
!             One-center block
!                 lblock(ia,ia) = .true.
                do i1 = ngini(ia), ngfin(ia)
                    la = ll(i1)
                    nfa = nf(i1)
                    do i2 = ngini(ia), ngfin(ia)
                        lb = ll(i2)
                        nfb = nf(i2)
                        do mb = -lb, lb
                            write(iuni) dmat(nfa:nfa+2*la,nfb+lb+mb)
                        enddo
                        knt = knt + (2*la+1) * (2*lb+1)
                    enddo
                enddo
            endif
            if (ioptaj .ne. 2) then
!             Two-center blocks                
                do ib = 1, ncen          		! Do over centers (ib)
                    kntblock = kntblock + 1
                    if (ia .eq. ib .or. ngini(ib) .le. 0) then
                        lblockaux(kntblock) = .false.
                        cycle
                    endif
                    lblockaux(kntblock) = .true.
!                     lblock(ia,ib) = .true.
                    do i1 = ngini(ia), ngfin(ia)
                        la = ll(i1)
                        nfa = nf(i1)
                        do i2 = ngini(ib), ngfin(ib)
                            lb = ll(i2)
                            nfb = nf(i2)
                            do ma = -la, la
                                write(iuni) dmat(ma+la+nfa,nfb:nfb+2*lb)
                            enddo
                            knt = knt + (2*la+1) * (2*lb+1)
                        enddo
                    enddo
                enddo
            endif
        enddo
        write(iuni) kntblock, lblockaux(1:kntblock)
        deallocate(lblockaux)
        ktot = ktot + knt
        close(iuni)
        write(6,"('proc num = ', i8, ' nelemden = ', i10, ' knt = ', i10)") irank, nelemden, knt
    enddo
!     deallocate(lblock)
! write(6,*) 'nbas**2 = ', nbas*nbas, ' ktot = ', ktot
    return
    end
!
!	***************************************************************
!
!     Creates files with chuncks of density matrix to be used by the processors.
!     the elements of the density matrix are stored in the same order as they will be used
!     in the subroutine ajusta
  subroutine createdensprsbinprocs
    USE MPI
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D, kntblock_ori => kntblock
    USE GAUSS
    USE PARALELO, istart_ori => istart, iend_ori => iend
    implicit none
    integer(KINT) :: i1, i2, ia, ib, ierr, irank, istart, iend, iuni, knt, kntblock, ktot, la, lb, ma, mb, nfa, nfb, nelemden
    logical, allocatable :: lblockaux(:)
    character*4 :: strbux
    
    ktot = 0
    do irank = 0, nprocs-1
        write(strbux,'(i4.2)') irank
        iuni = 18 + irank
#if _WIN32
        open (unit=iuni, file=trim(projectname)//".den_"//trim(adjustl(strbux)), form='binary', &
                action = 'write', carriagecontrol='NONE', iostat=ierr)
        if (ierr .ne. 0)  then
            write(6,"('Memory error when opening file ', a,'.den_', a,'  in processor ',i8)") &
                    trim(projectname), trim(adjustl(strbux)), myrank
            abort = 1
            return
        endif
#elif __INTEL_COMPILER
        open (unit=iuni, file=trim(projectname)//".den_"//trim(adjustl(strbux)), form='binary', &
                action = 'write', carriagecontrol='NONE', iostat=ierr)
        if (ierr .ne. 0)  then
            write(6,"('Memory error when opening file ', a,'.den_', a,'  in processor ',i8)") &
                    trim(projectname), trim(adjustl(strbux)), myrank
            abort = 1
            return
        endif
#else
        open (unit=iuni, file=trim(projectname)//".den_"//trim(adjustl(strbux)), form='unformatted', &
                action = 'write', access='stream', iostat=ierr)
        if (ierr .ne. 0)  then
            write(6,"('Memory error when opening file ', a,'.den_', a,'  in processor ',i8)") &
                    trim(projectname), trim(adjustl(strbux)), myrank
            abort = 1
            return
        endif
#endif  
        istart = istav(irank)
        iend = iendv(irank)
        if (nprocs .eq. 1) then
            nelemden = nbas * nbas
        elseif (irank .eq. 0) then
            nelemden = (nf(ngini(iend+1)) - 1) * nbas
        elseif (irank .eq. nprocs-1) then
            nelemden = (nbas - nf(ngini(istart)) + 1) * nbas
        else
            nelemden = (nf(ngini(iend+1)) - nf(ngini(istart))) * nbas
        endif

        knt = 0
        kntblock = 0
        allocate(dvec(nelemden), lblockaux(ncen*(iend-istart+1)), stat = ierr)
        if (ierr .ne. 0) then
            write(6,"('Memory error when allocating dvec and lblockaux.')")
            abort = 1
            return
        endif
        do ia = istart, iend       ! Do over centers (ia) assigned to processor
            if (ngini(ia) .le. 0) cycle
            if (ioptaj .ne. 3) then
!             One-center block
                do i1 = ngini(ia), ngfin(ia)
                    la = ll(i1)
                    nfa = nf(i1)
                    do i2 = ngini(ia), ngfin(ia)
                        lb = ll(i2)
                        nfb = nf(i2)
                        do mb = -lb, lb
                            do ma = -la, la
                                knt = knt + 1
                                dvec(knt) =  dmat(nfa+la+ma,nfb+lb+mb)
                            enddo
                        enddo
                    enddo
                enddo
            endif
            if (ioptaj .ne. 2) then
!             Two-center blocks                
                do ib = 1, ncen          		! Do over centers (ib)
                    kntblock = kntblock + 1
                    if (ia .eq. ib .or. ngini(ib) .le. 0) then
                        lblockaux(kntblock) = .false.
                    else
                        lblockaux(kntblock) = lblock(ia,ib)
                    endif
                    if (.not. lblockaux(kntblock)) cycle
                    do i1 = ngini(ia), ngfin(ia)
                        la = ll(i1)
                        nfa = nf(i1)
                        do i2 = ngini(ib), ngfin(ib)
                            lb = ll(i2)
                            nfb = nf(i2)
                            do ma = -la, la
                                do mb = -lb, lb
                                    knt = knt + 1
                                    dvec(knt) = dmat(ma+la+nfa,nfb+lb+mb)
                                enddo
                            enddo
                        enddo
                    enddo
                enddo
            endif
        enddo
        write(iuni) knt, dvec(1:knt), kntblock, lblockaux(1:kntblock)
        deallocate(dvec, lblockaux)
        ktot = ktot + knt
        close(iuni)
        write(6,"('proc num = ', i8, ' total density elements = ', i10, ' elements in non-null blocks  = ', i10, ' istart = ',&
            &i6, ' iend = ', i6)") irank, nelemden, knt, istart, iend
    enddo

    deallocate(lblock)
! write(6,*) 'nbas**2 = ', nbas*nbas, ' ktot = ', ktot
    return
    end
!
!	***************************************************************
!
!	Subroutine for the piecewise fitting of the density of an atom in a molecule. 
!		ioptaj .eq. 1: fits the total density
!		ioptaj .eq. 2: fits only the one-center terms of the density
!		otherwise:     fits only the two-center terms of the density
  subroutine ajusta
    USE MPI
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D, kntblock_ori => kntblock
    USE GAUSS
    USE PARALELO
    implicit none
    integer(KINT) :: i, i1, i12p, i1p, i1pini, i1pfin, i2, i2p, i2pini, i2pfin, ia, ib, ierr, ii, ir, irinf, irshft, irsup
    integer(KINT) :: ishift, j, k, kj, kml, knt, kntblock, kntden, knticf, kntlm
    integer(KINT) :: l, la, lb, lenpol, lk, lm, lma, lmax, lmb, lmin, lrotar, m, ma, maxltot, mb
    integer(KINT) :: n, na, nb, nfa, nfb, nga1, nga2, ngb1, ngb2, nelemden
    real(KREAL) :: aux, bux, cosal, cosbet, cosga, cux, den, dosx, exa, exb, expajust, fabs, factor, fmax
    real(KREAL) :: rab, rabinv, rdif, res, rn, rna, rnab, rnb, rp2, sinal, sinbet, singa, suma, tchb0, tchb1, umbralres2
    real(KREAL) :: x, x12inv, xa, xab, xb, xinv, xy, ya, yab, yb, za, zab, zb, umbraux
    logical :: lf0, lmultmod
    real(KREAL), allocatable :: cf12(:), faux(:), fbux(:), fk0(:), denvec(:), r2l2(:), r2v(:), x12(:)
    real(KREAL) :: roaux(-mxl:mxl,-mxl:mxl), bvec(0:mxlenpol-1), qlm1c(0:mxldst)
    character*4 :: strbux

    lrotar = max(lmaxbase,lmaxexp)
    umbralres2 = umbralres * umbralres

!	Allocates memory for arrays icfpos, cfajust, rmultipfr,and xajust
    allocate(icfpos(nintervaj*lmtop+1), stat = ierr)
    if (ierr .ne. 0) then
            write(6,"('Memory error when allocating icfpos in processor ',i8)") myrank
            abort = 1
            return
    endif
    allocate(cfajust(lmtop * nintervaj * mxlenpol), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating cfajust in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(rmultipfr(max(25,lmtop),iend-istart+1), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rmultipfr in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(xajust(nintervaj), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating xajust in processor ',i8)") myrank
        abort = 1
        return
    endif

!	Allocates memory for Hypergeometrics 2F1 and overlap integrals between generalized gaussians < g(n,L,M)| g(0,L',M') >
    allocate(h2f1(-mxl:(lmaxexp+mxl)/2,0:lmaxexp+mxl+(lmaxexp+mxl)/2,-(lmaxexp+mxl)/2:0), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating h2f1 in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(sint(0:(lmaxexp+mxl)/2,(lmaxexp+mxl+1)**2,0:mxl), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating sint in processor ',i8)") myrank
        abort = 1
        return
    endif

!	Allocates memory for arrays QGpart, qppart
    allocate(QGpart(nintervaj*lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating QGpart in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(qppart(nintervaj*lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating qppart in processor ',i8)") myrank
        abort = 1
        return
    endif

!	Allocates memory for arrays dl, fa, ftab, rl, rlt
    allocate(dl(-lrotar:lrotar,-lrotar:lrotar,0:lrotar), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating dl in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(fa(npntaj,(lmaxexp + 2*lmaxbase+1)**2), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating fa in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(ftab(npntaj,(max(2*lmaxbase,lmaxexp)+1)**2), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating ftab in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(rl(-lrotar:lrotar,-lrotar:lrotar,0:lrotar), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rl in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(rlt((lrotar+1)*(2*lrotar+1)*(2*lrotar+3)/3), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rlt in processor ',i8)") myrank
        abort = 1
        return
    endif

!	Allocates memory for arrays tchvec0, tchvec1, tchvec0a, xcheb, fkvec0
    allocate(tchvec0(npntintr), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating tchvec0 in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(tchvec1(npntintr), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating tchvec1 in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(tchvec0a(npntintr), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating tchvec0a in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(xcheb(npntintr), dosxcheb(npntintr), fk0(npntintr), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating xcheb, dosxcheb and fk0 in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(fkvec0(npntintr), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating fkvec0 in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(cf12(mxprimit*mxprimit), expvec(npntintr), expvinv(npntintr), f0(npntaj,0:mxltot), faux(npntintr), &
            fbux(npntintr), r2l2(npntintr), r2v(npntintr), residuals(nintervaj), rpntaj(npntaj), rpow(npntaj,0:2*mxn), &
            vaux1c(npntaj,0:mxldst), x12(mxprimit*mxprimit), stat = ierr )
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating  cf12, expvec, expvinv, f0, faux, fbux, r2l2, r2v, residuals, rpntaj, &
                &rpow, vaux1c. in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(ha(npntaj,(lmaxexp+mxl+1)*(lmaxexp+mxl+1)), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating ha in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(r2pow(npntaj,0:(lmaxexp+3*mxl)/2), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating r2pow in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(qlm2c(lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating qlm2c in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(ymat1(npntintr,lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating ymat1 in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(ymat2(npntintr,lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating ymat2 in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(rintr1(lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rintr1 in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(rintr2l2(lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rintr2l2 in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(rmultipmod(0:lmultmx), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rmultipmod in processor ',i8)") myrank
        abort = 1
        return
    endif

!	opens files 'projectname'_2016.damqt_?? and 'projectname'_2016.dmqtv_?? to store data for the remaining programs
!	(?? stays for current processor myrank)
!	The files are unformatted. The content of 'projectname'_2016.damqt can be retrieved int a plain text file with the program
!		readdamqt.exe included in the package
    write(strbux,'(i4.2)') myrank
#if _WIN32
    open (unit=10, file=trim(projectname)//"_2016.damqt_"//trim(adjustl(strbux)), form='binary', &
            action = 'write', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'_2016.damqt_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
    open (unit=11, file=trim(projectname)//"_2016.dmqtv_"//trim(adjustl(strbux)), form='binary', &
            action = 'write', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'_2016.dmqtv_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
    open (unit=12, file=trim(projectname)//".den_"//trim(adjustl(strbux)), form='binary', &
                action = 'read', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'.den_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
#elif __INTEL_COMPILER
    open (unit=10, file=trim(projectname)//"_2016.damqt_"//trim(adjustl(strbux)), form='binary', &
            action = 'write', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'_2016.damqt_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
    open (unit=11, file=trim(projectname)//"_2016.dmqtv_"//trim(adjustl(strbux)), form='binary', &
            action = 'write', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'_2016.dmqtv_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
    open (unit=12, file=trim(projectname)//".den_"//trim(adjustl(strbux)), form='binary', &
                action = 'read', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'.den_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
#else
    open (unit=10, file=trim(projectname)//"_2016.damqt_"//trim(adjustl(strbux)), form='unformatted', &
            action = 'write', access='stream', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'_2016.damqt_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
    open (unit=11, file=trim(projectname)//"_2016.dmqtv_"//trim(adjustl(strbux)), form='unformatted', &
            action = 'write', access='stream', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'_2016.dmqtv_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
    open (unit=12, file=trim(projectname)//".den_"//trim(adjustl(strbux)), form='unformatted', &
                action = 'read', access='stream', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'.den_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
#endif
    if (longoutput) then
        write(6,"('in proc ', i8, ' file 10 = ', a)") myrank, trim(projectname)//"_2016.damqt_"//trim(adjustl(strbux))
        write(6,"('in proc ', i8, ' file 11 = ', a)") myrank, trim(projectname)//"_2016.dmqtv_"//trim(adjustl(strbux))
        write(6,"('in proc ', i8, ' file 12 = ', a)") myrank, trim(projectname)//".den_"//trim(adjustl(strbux))
    endif

    allocate(besselint(0:mxldst,0:lmaxexp+mxldst), stat = ierr )
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating besselint in processor ',i8)") myrank
        abort = 1
        return
    endif

!	writes basis set to 'projectname'_2016.damqt_00 (main processor's damqt file)
    if (myrank .eq. 0) then
        call escribebase
        write(10) lmaxexp	! length of expansions on l of the atomic fragments
    endif

    xcheb(1:npntintr) = - cos(pi*(re(1:npntintr)-umed) * ri(npntintr))
    dosxcheb = dos * xcheb
! write(6,"('xcheb = ', 7(1x,e17.10))") uno + xcheb
! write(6,"('dif = ', e17.10, ' r0 = ', e17.10)") (rinterv(1) - rinterv(0)), rinterv(0)
! 	Tabulation points
    do i = 1, nintervaj
        rpntaj((i-1)*npntintr+1:i*npntintr) = (rinterv(i) - rinterv(i-1)) * umed * (uno + xcheb) + rinterv(i-1)
    enddo
! write(6,"('rpntaj = ', 7(1x,e17.10))") rpntaj(1:npntintr)
    rpow(1:npntaj,0) = uno
    do j = 1, 2*mxl
        rpow(1:npntaj,j) = rpow(1:npntaj,j-1) * rpntaj
    enddo

    rmultipfr = cero

    open(19,file=trim(projectname)//".mltmod_"//trim(adjustl(strbux)),form='formatted', iostat=ierr)
    if (ierr .ne. 0) then
        write(6,"('Cannot open file ', a)") trim(projectname)//".mltmod_"//trim(adjustl(strbux))
        lmultmod = .false.
    else
        lmultmod = .true.
    endif
    
    read(12) nelemden
    
    allocate(denvec(nelemden), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating denvec in processor ',i8)") myrank
        abort = 1
        return
    endif
    
    read(12) denvec(1:nelemden)
    read(12) kntblock

    call flush(6)
    
    allocate(lblockproc(kntblock), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating lblockproc.')")
        abort = 1
        return
    endif
    
    read(12) lblockproc(1:kntblock)
    
    kntden = 0
    kntblock = 0

    do ia = istart, iend       ! Do over centers (ia) assigned to processor
        if (ngini(ia) .le. 0) cycle	! If center without associated basis set, cycles
!	Initializes vectors and matrices
        ftab = cero
        fa = cero
        nga1 = ngini(ia)
        nga2 = ngfin(ia)
        xa = rcen(1,ia)
        ya = rcen(2,ia)
        za = rcen(3,ia)

!	ONE-CENTER CONTRIBUTIONS
        if (ioptaj .ne. 3) then
            do i1 = nga1, nga2
                la = ll(i1)
                rna= rnor(i1)
                nfa = nf(i1)
                do i2 = nga1, nga2
                    lb = ll(i2)
                    rn = rnor(i2) * rna
                    nfb = nf(i2)
                    lmin = abs(la-lb)
                    lmax = la + lb
                    i1pini = ipntprim(i1)
                    i2pini = ipntprim(i2)
                    i1pfin = ipntprim(i1)+nprimit(i1)-1
                    i2pfin = ipntprim(i2)+nprimit(i2)-1
                    i12p = 0
                    qlm1c = cero
                    do i1p = i1pini, i1pfin
                        do i2p = i2pini, i2pfin
                            i12p = i12p + 1
                            cf12(i12p) = cfcontr(i1p)*cfcontr(i2p)
                            x12(i12p) = xxg(i1p)+xxg(i2p)
                            x12inv = uno / x12(i12p)
                            aux = cf12(i12p) * facts(0) * x12inv * sqrt(x12inv)
                            qlm1c(0) = qlm1c(0) + aux
                            do l = 1, la+lb
                                aux = aux * umed * dosl1(l) * x12inv
                                qlm1c(l) = qlm1c(l) + aux
                            enddo
                        enddo
                    enddo
                    qlm1c(0:la+lb) = rn * dos * pi * qlm1c(0:la+lb) 	! includes the factor 1/2 of the radial integrals
                    do ir = 1 , npntaj
                        rp2 = rpow(ir,2)
                        factor = cero
                        do j = 1, i12p
                            factor = factor + cf12(j) * exp(-x12(j)*rp2)
                        enddo
                        factor = factor * rn
                        do l = 0, min(la,lb)
                            vaux1c(ir,l) = factor * rpow(ir,l+l)
                        enddo
                    enddo
                    do mb = -lb, lb
                        lmb = lb*(lb+1)+mb+1
                        doma: do ma = -la, la
                            lma = la*(la+1)+ma+1
                            kntden = kntden + 1
                            aux = ang(ind(la)+abs(ma)+1) * ang(ind(lb)+abs(mb)+1) * denvec(kntden)
                            do j = i1l1l2(lma,lmb), i2l1l2(lma,lmb)
                                if (lml1l2(j) .gt. lmtop) cycle doma
                                bux = ccl1l2(j) * aux
                                rmultipfr(lml1l2(j),ia-istart+1) = rmultipfr(lml1l2(j),ia-istart+1) &
                                         + bux * qlm1c((llm(lml1l2(j))+la+lb)/2) * dosl1i(llm(lml1l2(j)))
                                fa(1:npntaj,lml1l2(j)) = fa(1:npntaj,lml1l2(j)) + bux * vaux1c(1:npntaj,npl1l2(j))
                            enddo
                        enddo doma
                    enddo
                enddo
            enddo
            ftab(1:npntaj,1:(2*lmaxc(ia)+1)*(2*lmaxc(ia)+1)) = fa(1:npntaj,1:(2*lmaxc(ia)+1)*(2*lmaxc(ia)+1))
        endif

!	TWO-CENTER CONTRIBUTIONS
        if (ioptaj .ne. 2) then		! In case ioptaj .eq. 3, only takes one-center distributions
            do ib = 1, ncen          		! Do over centers (ib)
                kntblock = kntblock + 1
                if (.not. lblockproc(kntblock)) cycle    	! skips to next center ib
                fa = cero
                ngb1 = ngini(ib)
                ngb2 = ngfin(ib)
                xb = rcen(1,ib)
                yb = rcen(2,ib)
                zb = rcen(3,ib)
!	Computes Euler angles and rotation matrices from the AB aligned axis system to the molecular system and conversely
                xab = xb - xa
                yab = yb - ya
                zab = zb - za
                xy = sqrt(xab*xab + yab*yab)
                rab = sqrt(xab*xab + yab*yab + zab*zab)
                if (rab .lt. 1.d-10) then
                    write(6,"('Error in proc ', i8, ' Centers ',i8,' and ',i8,' coincide')") myrank, ia, ib
                    abort = 1
                    return
                endif
                if (xy .gt. 1.d-10) then
                    sinal = yab / xy
                    cosal = xab / xy
                else
                    sinal = cero
                    cosal = uno
                endif
                rabinv = uno / rab
                sinbet = xy * rabinv
                cosbet = zab * rabinv
                singa = cero
                cosga = uno
                call rotar (lrotar, cosal, sinal, cosbet, sinbet, cosga, singa)
                knt = 0
                do i = 0, lmaxexp	! Stores the transpose of rl multiplied and divided by suitable normalization factors
                    do k = -i, i
                        do j = -i, i
                            knt = knt + 1
                            rlt(knt) = rl(k,j,i) * ang(ind(i)+abs(k)+1) / ang(ind(i)+abs(j)+1)
                        enddo
                    enddo
                enddo
                qlm2c = cero	! Initializes qlm2c
                do i1 = nga1, nga2
                    la = ll(i1)
                    rna= rnor(i1)
                    nfa = nf(i1)
                    do i2 = ngb1, ngb2
                        lb = ll(i2)
                        rnb= rnor(i2)
                        nfb = nf(i2)
!	Determines an approximation to the sigma overlap to see whether the integrals can be neglected
                        i1pini = ipntprim(i1)
                        i2pini = ipntprim(i2)
                        i1pfin = ipntprim(i1) + nprimit(i1) - 1
                        i2pfin = ipntprim(i2) + nprimit(i2) - 1
                        aux = cero
                        bux = la + lb + 1.5d0
                        do i1p = i1pini, i1pfin
                            do i2p = i2pini, i2pfin
                                cux = xxg(i1p) * xxg(i2p) * rab * rab / (xxg(i1p)+xxg(i2p))
                                if(cux .le. 300.d0) aux = aux+cfcontr(i1p)*cfcontr(i2p)*exp(-cux)/(xxg(i1p)+xxg(i2p))**bux
                            enddo
                        enddo
                        if (mod(la+lb,2) .eq. 0) then
                            aux = facts(la+lb) * abs(aux) * rna * rnb
                        else
                            aux = fact((la+lb+1)/2) * abs(aux) * rna * rnb
                        endif
                        if (abs(aux) .lt. 1.d-20) then
                            kntden = kntden + (2*la+1) * (2*lb+1)
                            cycle
                        endif
!	Reads the pertinent block of density matrix and rotates it to the AB alligned system. Loads the result in vector  rov.
!	Angular normalization factors are introduced at the end of the loading process.
                        do i = -la, la
                            ishift = i+la+nfa
                            do j = -lb, lb
                                kntden = kntden + 1
                                roblk(i,j) = denvec(kntden)
                            enddo
                        enddo
!	Rotation on center B
                        do i = -la, la
                            do j = -lb, lb
                                roaux(i,j) = dot_product(roblk(i,-lb:lb),rl(-lb:lb,j,lb))
                            enddo
                        enddo
!	Rotation on center A and introduction of the angular normalization
                        rnab = rna * rnor(i2) * dos
                        do i = -la, la
                            ii = abs(i)+1
                            do j = -lb, lb
                                roblk(i,j) = ang(ind(la)+abs(i)+1) * ang(ind(lb)+abs(j)+1) * rnab &
                                        * dot_product(roaux(-la:la,j), rl(-la:la,i,la))
                            enddo
                        enddo
!	Computes the multipolar moments in the lined-up axis system:
!		multfrg2cgauss: translation method (Bessel I expansion)
!		multfrg2cgaussnw: shift operators method (overlap between generalized Gaussians)
                        call multfrg2cgauss(i1, i2, rab)
! 						call multfrg2cgaussnw(i1, i2, rab)

!	Tabulation of A fragment
                        lf0 = .true.	! null f0 -> lf0 = .false.  (set in frgsiggauss)
                        call frgsiggauss(lf0, i1, i2, rab)	! Sigma part
                        if (lf0) call dsczazbnew(la, lb, rab)	! Factors for La,Ma,Lb,Mb
                    enddo
                enddo
!	Rotates the radial factors back to the molecular axis system
                lm = 0
                kml = 0
                do l = 0, lmaxexp
                    do m = -l, l
                        lm = lm + 1
                        lk = l*(l+1)+1
                        do k = -l, l
                            kml = kml + 1
                            rmultipfr(lm,ia-istart+1) = rmultipfr(lm,ia-istart+1) + qlm2c(lk+k) * rlt(kml)
                            ftab(1:npntaj,lm) = ftab(1:npntaj,lm) + fa(1:npntaj,lk+k) * rlt(kml)
                        enddo
                    enddo
                enddo
            enddo    ! End of Do over centers (ib)
!			Computes the modules of multipolar moments and stores them in file  filename.mltmod
!			Since the multipolar moments, are defined as the coefficients that multiply the unnormalized irregular spherical harmonics 
!			in the long-range potential, they are multipied here by sqrt((1+delta(m,0)) * (l+|m|)!/(l-|m|)! ) to keep them invariant under rotations
            if (lmultmod) then
                lm = 0
                do l = 0, lmultmx
                    aux = 0.d0
                    do m = -l, l
                        lm = lm + 1
                        if (m .eq. 0) then
                            bux = dos
                        else
                            bux = uno
                        endif
                        aux = aux + rmultipfr(lm,ia-istart+1) * rmultipfr(lm,ia-istart+1) * bux * fact(l+abs(m)) * facti(l-abs(m))
                    enddo
                    rmultipmod(l) = sqrt(aux)
                enddo
                write(19,"(a, 2x, i5, 2x, 25(e22.15,1x))") atmnam(ia), ia, rmultipmod(0:lmultmx)
            endif
        endif
!
!	Fits the radial factors	
!
        knticf = 1
        ishift = (istart-1)*(lmtop*nintervaj+1)
        icfpos(1) = 1
        do i = 1, nintervaj
            irshft = (i-1) * npntintr
!			Optimizes exponent
            if (min(abs(ftab(irshft+npntintr,1)),abs(ftab(irshft+1,1))) .lt. umbral) then
                xajust(i) = cero
            else
                xajust(i) = (log(abs(ftab(irshft+npntintr,1)))-log(abs(ftab(irshft+1,1)))) &
                        / (rpntaj(irshft+1)-rpntaj(irshft+npntintr))
            endif
            if (xajust(i) .lt. uno) then
                xajust(i) = cero
                expvec = uno
                expvinv = uno
            else
                expvec = exp(rpntaj(irshft+1:irshft+npntintr) * xajust(i))
                expvinv = uno / expvec
            endif
            kntlm = 0
            r2v = rpntaj(irshft+1:irshft+npntintr) * rpntaj(irshft+1:irshft+npntintr)
            r2l2 = uno
            do l = 0, lmaxexp
                r2l2 = r2l2 * r2v
                do m = -l, l
                    kntlm = kntlm+1
                    knticf = knticf + 1
!	Checks whether the radial factor is negligible or not. If it is, marks it and avoids fitting.
                    aux = maxval(abs(ftab(irshft+1:irshft+npntintr,kntlm)))
                    bux = maxval(abs(ftab(irshft+1:irshft+npntintr,kntlm))*r2l2)
                    cux = fact(l+abs(m)) * umedpow(abs(m)) * facti(l-abs(m)) * facti(abs(m))
                    fmax = max(aux,bux) * cux
                    if (fmax .lt. umbral) then    ! Test: is the fragment negligible ?
                        icfpos(knticf) = icfpos(knticf-1)
                    else
                        lenpol = 0
                        fk0 = ftab(irshft+1:irshft+npntintr,kntlm) * expvec
                        tchvec0 = uno
                        tchvec1 = xcheb
                        bvec(0) = sum(fk0) * ri(npntintr)
                        bvec(1) = dot_product(fk0,tchvec1) * dos * ri(npntintr)
                        fkvec0 = bvec(0) * tchvec0 + bvec(1) * tchvec1
                        if (aux .gt. bux) then
                            faux = ftab(irshft+1:irshft+npntintr,kntlm)
                            fbux = expvinv
                        else
                            faux = ftab(irshft+1:irshft+npntintr,kntlm) * r2l2
                            fbux = expvinv * r2l2
                        endif
                        do j = 2, mxlenpol-1
                            tchvec0a = tchvec0
                            tchvec0 = tchvec1
                            tchvec1 = dosxcheb * tchvec1 - tchvec0a
                            bvec(j) = dot_product(fk0,tchvec1) * dos * ri(npntintr)
                            fkvec0 = fkvec0 + bvec(j) * tchvec1
                            res = cux * cux * dot_product( ( faux - fkvec0 * fbux), (faux - fkvec0 * fbux))
                            if (res .lt. umbralres2) then
                                lenpol = j+1
                                exit
                            endif
                        enddo
                        if (lenpol .eq. 0) then
                            lenpol = mxlenpol
                        endif
                        icfpos(knticf) = icfpos(knticf-1) + lenpol
                        cfajust(icfpos(knticf-1):icfpos(knticf)-1) = bvec(0:lenpol-1)
                    endif	! End of Test: is the fragment negligible ?
                enddo	! End of loop on m
! 				r2l2 = r2l2 * rpntaj(irshft+1:irshft+npntintr)
            enddo		! End of loop on l
        enddo	! End of loop on intervals

!	Computes the atomic multipolar moments from the fit and some auxiliary integrals
        call multipolos(ia)

!	Fitting coefficients 

!	Allocates memory for arrays cfrint1, cfrint2l2
        allocate(cfrint1(icfpos(knticf)-1), cfrint2l2(icfpos(knticf)-1), stat = ierr)
        if (ierr .ne. 0) then
            write(6,"('Memory error when allocating cfrint1 and cfrint2l2 in processor ',i8)") myrank
            abort = 1
            return
        endif
        if (longoutput) write(6,"('Size of cfrint1 and cfrint2l2  = ', i15, ' bytes')") size(cfrint1)
!	Fits the auxiliary integrals 
!         rintr1(la,ma) =  Integrate[ r * fradtr[la,ma,r], {r,r0,l_k}]
!         rintr2l2 = Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(k-1),r0}]
        call fitrint(ia)
! 	writes data of center ia to file 'projectname'_2016.damqt
        write(10) icfpos(1:knticf)	! pointers to expansion coefficients of radial factors of center ia
        write(10) xajust(1:nintervaj)	! fitting exponents
!    fitting coeficients 
        write(10) cfajust(1:icfpos(knticf)-1)	! Expansion coefficients
!	multipolar moments
        write(11) rmultipfr(1:lmtop,ia-istart+1)		! multipolar moments of center ia
!	Partial integrals for electrostatic potential and field
        write(11) QGpart(1:nintervaj*lmtop)
        write(11) qppart(1:nintervaj*lmtop)
!    fitting coeficients of auxiliary integrals for electrostatic potential and field
        write(11) cfrint1(1:icfpos(knticf)-1)	! Expansion coefficients of auxiliary integrals rint1
        write(11) cfrint2l2(1:icfpos(knticf)-1)	! Expansion coefficients of auxiliary integrals rint2l2
        deallocate (cfrint1,cfrint2l2)
    enddo	! End of Do over centers (ia)
    close(19)
    close(10)
    close(11)
    close(12)
    deallocate(besselint, cf12, dl, dosxcheb, expvec, expvinv, f0, fa, faux, fk0, ftab, fkvec0, h2f1, ha, qlm2c, &
            r2pow, rintr1, rintr2l2, rl, rlt, rpntaj, rpow, sint, tchvec0, tchvec1, tchvec0a, vaux1c, x12, xcheb, ymat1, ymat2)
    return
    end
!
!	***************************************************************
!
!	Subroutine for the piecewise fitting of the density of an atom in a molecule. Version for general contractions.
!		ioptaj .eq. 1: fits the total density
!		ioptaj .eq. 2: fits only the one-center terms of the density
!		otherwise:     fits only the two-center terms of the density
  subroutine ajustagencontract
    USE MPI
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D, kntblock_ori => kntblock
    USE GAUSS
    USE GENCONTRACTMOD
    USE PARALELO
    implicit none
    integer(KINT) :: i, i1, i12p, i1p, i1pini, i1pfin, i2, i2p, i2pini, i2pfin, ia, ib, ierr, ii, ir, irinf, irshft, irsup
    integer(KINT) :: ishift, j, k, kj, kml, knt, kntblock, kntden, knticf, kntlm
    integer(KINT) :: l, la, lb, lenpol, lk, lm, lma, lmax, lmb, lmin, lrotar, m, ma, maxltot, mb
    integer(KINT) :: n, na, nb, nfa, nfb, nga1, nga2, ngb1, ngb2, nelemden
    real(KREAL) :: aux, bux, cosal, cosbet, cosga, cux, den, dosx, exa, exb, expajust, fabs, factor, fmax
    real(KREAL) :: rab, rabinv, rdif, res, rn, rna, rnab, rnb, rp2, sinal, sinbet, singa, suma, tchb0, tchb1, umbralres2
    real(KREAL) :: x, x12inv, xa, xab, xb, xinv, xy, ya, yab, yb, za, zab, zb, umbraux
    logical :: lf0, lmultmod
    real(KREAL), allocatable :: cf12(:), faux(:), fbux(:), fk0(:), denvec(:), r2l2(:), r2v(:), x12(:)
    real(KREAL) :: roaux(-mxl:mxl,-mxl:mxl), bvec(0:mxlenpol-1), qlm1c(0:mxldst)
    character*4 :: strbux

    lrotar = max(lmaxbase,lmaxexp)
    umbralres2 = umbralres * umbralres

!	Allocates memory for arrays icfpos, cfajust, rmultipfr,and xajust
    allocate(icfpos(nintervaj*lmtop+1), stat = ierr)
    if (ierr .ne. 0) then
            write(6,"('Memory error when allocating icfpos in processor ',i8)") myrank
            abort = 1
            return
    endif
    allocate(cfajust(lmtop * nintervaj * mxlenpol), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating cfajust in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(rmultipfr(max(25,lmtop),iend-istart+1), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rmultipfr in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(xajust(nintervaj), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating xajust in processor ',i8)") myrank
        abort = 1
        return
    endif

!	Allocates memory for Hypergeometrics 2F1 and overlap integrals between generalized gaussians g(n,L,M)| g(0,L',M') >
    allocate(h2f1(-mxl:(lmaxexp+mxl)/2,0:lmaxexp+mxl+(lmaxexp+mxl)/2,-(lmaxexp+mxl)/2:0), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating h2f1 in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(sint(0:(lmaxexp+mxl)/2,(lmaxexp+mxl+1)**2,0:mxl), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating sint in processor ',i8)") myrank
        abort = 1
        return
    endif

!	Allocates memory for arrays QGpart, qppart
    allocate(QGpart(nintervaj*lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating QGpart in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(qppart(nintervaj*lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating qppart in processor ',i8)") myrank
        abort = 1
        return
    endif

!	Allocates memory for arrays dl, fa, ftab, rl, rlt
    allocate(dl(-lrotar:lrotar,-lrotar:lrotar,0:lrotar), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating dl in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(fa(npntaj,(lmaxexp + 2*lmaxbase+1)**2), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating fa in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(ftab(npntaj,(max(2*lmaxbase,lmaxexp)+1)**2), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating ftab in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(rl(-lrotar:lrotar,-lrotar:lrotar,0:lrotar), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rl in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(rlt((lrotar+1)*(2*lrotar+1)*(2*lrotar+3)/3), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rlt in processor ',i8)") myrank
        abort = 1
        return
    endif

!	Allocates memory for arrays tchvec0, tchvec1, tchvec0a, xcheb, fkvec0
    allocate(tchvec0(npntintr), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating tchvec0 in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(tchvec1(npntintr), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating tchvec1 in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(tchvec0a(npntintr), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating tchvec0a in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(xcheb(npntintr), dosxcheb(npntintr), fk0(npntintr), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating xcheb, dosxcheb and fk0 in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(fkvec0(npntintr), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating fkvec0 in processor ',i8)") myrank
        abort = 1
        return
    endif
    allocate(cf12(mxprimit*mxprimit), expvec(npntintr), expvinv(npntintr), f0(npntaj,0:mxltot), faux(npntintr), &
            fbux(npntintr), r2l2(npntintr), r2v(npntintr), residuals(nintervaj), rpntaj(npntaj), rpow(npntaj,0:2*mxn), &
            vaux1c(npntaj,0:mxldst), x12(mxprimit*mxprimit), stat = ierr )
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating  cf12, expvec, expvinv, f0, faux, fbux, r2l2, r2v, residuals, rpntaj, &
                &rpow, vaux1c. in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(ha(npntaj,(lmaxexp+mxl+1)*(lmaxexp+mxl+1)), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating ha in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(r2pow(npntaj,0:(lmaxexp+3*mxl)/2), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating r2pow in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(qlm2c(lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating qlm2c in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(ymat1(npntintr,lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating ymat1 in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(ymat2(npntintr,lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating ymat2 in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(rintr1(lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rintr1 in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(rintr2l2(lmtop), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rintr2l2 in processor ',i8)") myrank
        abort = 1
        return
    endif

    allocate(rmultipmod(0:lmultmx), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating rmultipmod in processor ',i8)") myrank
        abort = 1
        return
    endif

!	opens files 'projectname'_2016.damqt_?? and 'projectname'_2016.dmqtv_?? to store data for the remaining programs
!	(?? stays for current processor myrank)
!	The files are unformatted. The content of 'projectname'_2016.damqt can be retrieved int a plain text file with the program
!		readdamqt.exe included in the package
    write(strbux,'(i4.2)') myrank
#if _WIN32
    open (unit=10, file=trim(projectname)//"_2016.damqt_"//trim(adjustl(strbux)), form='binary', &
            action = 'write', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'_2016.damqt_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
    open (unit=11, file=trim(projectname)//"_2016.dmqtv_"//trim(adjustl(strbux)), form='binary', &
            action = 'write', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'_2016.dmqtv_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
    open (unit=12, file=trim(projectname)//".den_"//trim(adjustl(strbux)), form='binary', &
                action = 'read', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'.den_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
#elif __INTEL_COMPILER
    open (unit=10, file=trim(projectname)//"_2016.damqt_"//trim(adjustl(strbux)), form='binary', &
            action = 'write', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'_2016.damqt_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
    open (unit=11, file=trim(projectname)//"_2016.dmqtv_"//trim(adjustl(strbux)), form='binary', &
            action = 'write', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'_2016.dmqtv_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
    open (unit=12, file=trim(projectname)//".den_"//trim(adjustl(strbux)), form='binary', &
                action = 'read', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'.den_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
#else
    open (unit=10, file=trim(projectname)//"_2016.damqt_"//trim(adjustl(strbux)), form='unformatted', &
            action = 'write', access='stream', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'_2016.damqt_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
    open (unit=11, file=trim(projectname)//"_2016.dmqtv_"//trim(adjustl(strbux)), form='unformatted', &
            action = 'write', access='stream', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'_2016.dmqtv_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
    open (unit=12, file=trim(projectname)//".den_"//trim(adjustl(strbux)), form='unformatted', &
                action = 'read', access='stream', iostat=ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when opening file ', a,'.den_', a,'  in processor ',i8)") &
                trim(projectname), trim(adjustl(strbux)), myrank
        abort = 1
        return
    endif
#endif
    if (longoutput) then
        write(6,"('in proc ', i8, ' file 10 = ', a)") myrank, trim(projectname)//"_2016.damqt_"//trim(adjustl(strbux))
        write(6,"('in proc ', i8, ' file 11 = ', a)") myrank, trim(projectname)//"_2016.dmqtv_"//trim(adjustl(strbux))
        write(6,"('in proc ', i8, ' file 12 = ', a)") myrank, trim(projectname)//".den_"//trim(adjustl(strbux))
    endif

    allocate(besselint(0:mxldst,0:lmaxexp+mxldst), stat = ierr )
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating besselint in processor ',i8)") myrank
        abort = 1
        return
    endif

!	writes basis set to 'projectname'_2016.damqt_00 (main processor's damqt file)
    if (myrank .eq. 0) then
        call escribebase
        write(10) lmaxexp	! length of expansions on l of the atomic fragments
    endif

    xcheb(1:npntintr) = - cos(pi*(re(1:npntintr)-umed) * ri(npntintr))
    dosxcheb = dos * xcheb
! write(6,"('xcheb = ', 7(1x,e17.10))") uno + xcheb
! write(6,"('dif = ', e17.10, ' r0 = ', e17.10)") (rinterv(1) - rinterv(0)), rinterv(0)
! 	Tabulation points
    do i = 1, nintervaj
        rpntaj((i-1)*npntintr+1:i*npntintr) = (rinterv(i) - rinterv(i-1)) * umed * (uno + xcheb) + rinterv(i-1)
    enddo
! write(6,"('rpntaj = ', 7(1x,e17.10))") rpntaj(1:npntintr)
    rpow(1:npntaj,0) = uno
    do j = 1, 2*mxl
        rpow(1:npntaj,j) = rpow(1:npntaj,j-1) * rpntaj
    enddo

    rmultipfr = cero

    open(19,file=trim(projectname)//".mltmod_"//trim(adjustl(strbux)),form='formatted', iostat=ierr)
    if (ierr .ne. 0) then
        write(6,"('Cannot open file ', a)") trim(projectname)//".mltmod_"//trim(adjustl(strbux))
        lmultmod = .false.
    else
        lmultmod = .true.
    endif

    read(12) nelemden

    allocate(denvec(nelemden), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating denvec in processor ',i8)") myrank
        abort = 1
        return
    endif

    read(12) denvec(1:nelemden)
    read(12) kntblock

    call flush(6)

    allocate(lblockproc(kntblock), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating lblockproc.')")
        abort = 1
        return
    endif

    read(12) lblockproc(1:kntblock)

    kntden = 0
    kntblock = 0

    do ia = istart, iend       ! Do over centers (ia) assigned to processor
        if (ngini(ia) .le. 0) cycle	! If center without associated basis set, cycles
!	Initializes vectors and matrices
        ftab = cero
        fa = cero
        nga1 = ngini(ia)
        nga2 = ngfin(ia)
        xa = rcen(1,ia)
        ya = rcen(2,ia)
        za = rcen(3,ia)

!	ONE-CENTER CONTRIBUTIONS
        if (ioptaj .ne. 3) then
            do i1 = nga1, nga2
                la = ll(i1)
                rna= rnor(i1)
                nfa = nf(i1)
                do i2 = nga1, nga2
                    lb = ll(i2)
                    rn = rnor(i2) * rna
                    nfb = nf(i2)
                    lmin = abs(la-lb)
                    lmax = la + lb
                    i1pini = ipntprim(i1)
                    i2pini = ipntprim(i2)
                    i1pfin = ipntprim(i1)+nprimit(i1)-1
                    i2pfin = ipntprim(i2)+nprimit(i2)-1
                    i12p = 0
                    qlm1c = cero
                    do i1p = i1pini, i1pfin
                        do i2p = i2pini, i2pfin
                            i12p = i12p + 1
                            cf12(i12p) = cfcontr(i1p)*cfcontr(i2p)
                            x12(i12p) = xxg(i1p)+xxg(i2p)
                            x12inv = uno / x12(i12p)
                            aux = cf12(i12p) * facts(0) * x12inv * sqrt(x12inv)
                            qlm1c(0) = qlm1c(0) + aux
                            do l = 1, la+lb
                                aux = aux * umed * dosl1(l) * x12inv
                                qlm1c(l) = qlm1c(l) + aux
                            enddo
                        enddo
                    enddo
                    qlm1c(0:la+lb) = rn * dos * pi * qlm1c(0:la+lb) 	! includes the factor 1/2 of the radial integrals
                    do ir = 1 , npntaj
                        rp2 = rpow(ir,2)
                        factor = cero
                        do j = 1, i12p
                            factor = factor + cf12(j) * exp(-x12(j)*rp2)
                        enddo
                        factor = factor * rn
                        do l = 0, min(la,lb)
                            vaux1c(ir,l) = factor * rpow(ir,l+l)
                        enddo
                    enddo
                    do mb = -lb, lb
                        lmb = lb*(lb+1)+mb+1
                        doma: do ma = -la, la
                            lma = la*(la+1)+ma+1
                            kntden = kntden + 1
                            aux = ang(ind(la)+abs(ma)+1) * ang(ind(lb)+abs(mb)+1) * denvec(kntden)
                            do j = i1l1l2(lma,lmb), i2l1l2(lma,lmb)
                                if (lml1l2(j) .gt. lmtop) cycle doma
                                bux = ccl1l2(j) * aux
                                rmultipfr(lml1l2(j),ia-istart+1) = rmultipfr(lml1l2(j),ia-istart+1) &
                                         + bux * qlm1c((llm(lml1l2(j))+la+lb)/2) * dosl1i(llm(lml1l2(j)))
                                fa(1:npntaj,lml1l2(j)) = fa(1:npntaj,lml1l2(j)) + bux * vaux1c(1:npntaj,npl1l2(j))
                            enddo
                        enddo doma
                    enddo
                enddo
            enddo
            ftab(1:npntaj,1:(2*lmaxc(ia)+1)*(2*lmaxc(ia)+1)) = fa(1:npntaj,1:(2*lmaxc(ia)+1)*(2*lmaxc(ia)+1))
        endif

!	TWO-CENTER CONTRIBUTIONS
        if (ioptaj .ne. 2) then		! In case ioptaj .eq. 3, only takes one-center distributions
            do ib = 1, ncen          		! Do over centers (ib)
                kntblock = kntblock + 1
                if (.not. lblockproc(kntblock)) cycle    	! skips to next center ib
                fa = cero
                ngb1 = ngini(ib)
                ngb2 = ngfin(ib)
                xb = rcen(1,ib)
                yb = rcen(2,ib)
                zb = rcen(3,ib)
!	Computes Euler angles and rotation matrices from the AB aligned axis system to the molecular system and conversely
                xab = xb - xa
                yab = yb - ya
                zab = zb - za
                xy = sqrt(xab*xab + yab*yab)
                rab = sqrt(xab*xab + yab*yab + zab*zab)
                if (rab .lt. 1.d-10) then
                    write(6,"('Error in proc ', i8, ' Centers ',i8,' and ',i8,' coincide')") myrank, ia, ib
                    abort = 1
                    return
                endif

                call bivsub(ia, ib, rab)

                if (xy .gt. 1.d-10) then
                    sinal = yab / xy
                    cosal = xab / xy
                else
                    sinal = cero
                    cosal = uno
                endif
                rabinv = uno / rab
                sinbet = xy * rabinv
                cosbet = zab * rabinv
                singa = cero
                cosga = uno
                call rotar (lrotar, cosal, sinal, cosbet, sinbet, cosga, singa)
                knt = 0
                do i = 0, lmaxexp	! Stores the transpose of rl multiplied and divided by suitable normalization factors
                    do k = -i, i
                        do j = -i, i
                            knt = knt + 1
                            rlt(knt) = rl(k,j,i) * ang(ind(i)+abs(k)+1) / ang(ind(i)+abs(j)+1)
                        enddo
                    enddo
                enddo
                qlm2c = cero	! Initializes qlm2c

                kntcoefa = 0
                do i1 = nga1, nga2
                    la = ll(i1)
                    kntcoefa(la) = kntcoefa(la)+1
                    rna= rnor(i1)
                    nfa = nf(i1)
                    kntcoefb = 0
                    do i2 = ngb1, ngb2
                        lb = ll(i2)
                        kntcoefb(lb) = kntcoefb(lb)+1
                        rnb= rnor(i2)
                        nfb = nf(i2)
!	Determines an approximation to the sigma overlap to see whether the integrals can be neglected
                        i1pini = ipntprim(i1)
                        i2pini = ipntprim(i2)
                        i1pfin = ipntprim(i1) + nprimit(i1) - 1
                        i2pfin = ipntprim(i2) + nprimit(i2) - 1
                        aux = cero
                        bux = la + lb + 1.5d0
                        do i1p = i1pini, i1pfin
                            do i2p = i2pini, i2pfin
                                cux = xxg(i1p) * xxg(i2p) * rab * rab / (xxg(i1p)+xxg(i2p))
                                if(cux .le. 300.d0) aux = aux+cfcontr(i1p)*cfcontr(i2p)*exp(-cux)/(xxg(i1p)+xxg(i2p))**bux
                            enddo
                        enddo
                        if (mod(la+lb,2) .eq. 0) then
                            aux = facts(la+lb) * abs(aux) * rna * rnb
                        else
                            aux = fact((la+lb+1)/2) * abs(aux) * rna * rnb
                        endif
                        if (abs(aux) .lt. 1.d-20) then
                            kntden = kntden + (2*la+1) * (2*lb+1)
                            cycle
                        endif
!	Reads the pertinent block of density matrix and rotates it to the AB alligned system. Loads the result in vector  rov.
!	Angular normalization factors are introduced at the end of the loading process.
                        do i = -la, la
                            ishift = i+la+nfa
                            do j = -lb, lb
                                kntden = kntden + 1
                                roblk(i,j) = denvec(kntden)
                            enddo
                        enddo
!	Rotation on center B
                        do i = -la, la
                            do j = -lb, lb
                                roaux(i,j) = dot_product(roblk(i,-lb:lb),rl(-lb:lb,j,lb))
                            enddo
                        enddo
!	Rotation on center A and introduction of the angular normalization
                        rnab = rna * rnor(i2) * dos
                        do i = -la, la
                            ii = abs(i)+1
                            do j = -lb, lb
                                roblk(i,j) = ang(ind(la)+abs(i)+1) * ang(ind(lb)+abs(j)+1) * rnab &
                                        * dot_product(roaux(-la:la,j), rl(-la:la,i,la))
                            enddo
                        enddo
!	Computes the multipolar moments in the lined-up axis system:
!		multfrg2cgauss: translation method (Bessel I expansion)
!		multfrg2cgaussnw: shift operators method (overlap between generalized Gaussians)
                        call multfrg2cgauss(i1, i2, rab)
! 						call multfrg2cgaussnw(i1, i2, rab)

!	Tabulation of A fragment
                        lf0 = .true.	! null f0 -> lf0 = .false.  (set in frgsiggauss)
                        call frgsiggencontr(lf0, ia, ib, i1, i2, rab)   ! Sigma part
                        if (lf0) call dsczazbnew(la, lb, rab)	! Factors for La,Ma,Lb,Mb
                    enddo
                enddo
!	Rotates the radial factors back to the molecular axis system
                lm = 0
                kml = 0
                do l = 0, lmaxexp
                    do m = -l, l
                        lm = lm + 1
                        lk = l*(l+1)+1
                        do k = -l, l
                            kml = kml + 1
                            rmultipfr(lm,ia-istart+1) = rmultipfr(lm,ia-istart+1) + qlm2c(lk+k) * rlt(kml)
                            ftab(1:npntaj,lm) = ftab(1:npntaj,lm) + fa(1:npntaj,lk+k) * rlt(kml)
                        enddo
                    enddo
                enddo
            enddo    ! End of Do over centers (ib)
!			Computes the modules of multipolar moments and stores them in file  filename.mltmod
!			Since the multipolar moments, are defined as the coefficients that multiply the unnormalized irregular spherical harmonics
!			in the long-range potential, they are multipied here by sqrt((1+delta(m,0)) * (l+|m|)!/(l-|m|)! ) to keep them invariant under rotations
            if (lmultmod) then
                lm = 0
                do l = 0, lmultmx
                    aux = 0.d0
                    do m = -l, l
                        lm = lm + 1
                        if (m .eq. 0) then
                            bux = dos
                        else
                            bux = uno
                        endif
                        aux = aux + rmultipfr(lm,ia-istart+1) * rmultipfr(lm,ia-istart+1) * bux * fact(l+abs(m)) * facti(l-abs(m))
                    enddo
                    rmultipmod(l) = sqrt(aux)
                enddo
                write(19,"(a, 2x, i5, 2x, 6(e22.15,1x))") atmnam(ia), ia, rmultipmod(0:lmultmx)
            endif
        endif
!
!	Fits the radial factors
!
        knticf = 1
        ishift = (istart-1)*(lmtop*nintervaj+1)
        icfpos(1) = 1
        do i = 1, nintervaj
            irshft = (i-1) * npntintr
!			Optimizes exponent
            if (min(abs(ftab(irshft+npntintr,1)),abs(ftab(irshft+1,1))) .lt. umbral) then
                xajust(i) = cero
            else
                xajust(i) = (log(abs(ftab(irshft+npntintr,1)))-log(abs(ftab(irshft+1,1)))) &
                        / (rpntaj(irshft+1)-rpntaj(irshft+npntintr))
            endif
            if (xajust(i) .lt. uno) then
                xajust(i) = cero
                expvec = uno
                expvinv = uno
            else
                expvec = exp(rpntaj(irshft+1:irshft+npntintr) * xajust(i))
                expvinv = uno / expvec
            endif
            kntlm = 0
            r2v = rpntaj(irshft+1:irshft+npntintr) * rpntaj(irshft+1:irshft+npntintr)
            r2l2 = uno
            do l = 0, lmaxexp
                r2l2 = r2l2 * r2v
                do m = -l, l
                    kntlm = kntlm+1
                    knticf = knticf + 1
!	Checks whether the radial factor is negligible or not. If it is, marks it and avoids fitting.
                    aux = maxval(abs(ftab(irshft+1:irshft+npntintr,kntlm)))
                    bux = maxval(abs(ftab(irshft+1:irshft+npntintr,kntlm))*r2l2)
                    cux = fact(l+abs(m)) * umedpow(abs(m)) * facti(l-abs(m)) * facti(abs(m))
                    fmax = max(aux,bux) * cux
                    if (fmax .lt. umbral) then    ! Test: is the fragment negligible ?
                        icfpos(knticf) = icfpos(knticf-1)
                    else
                        lenpol = 0
                        fk0 = ftab(irshft+1:irshft+npntintr,kntlm) * expvec
                        tchvec0 = uno
                        tchvec1 = xcheb
                        bvec(0) = sum(fk0) * ri(npntintr)
                        bvec(1) = dot_product(fk0,tchvec1) * dos * ri(npntintr)
                        fkvec0 = bvec(0) * tchvec0 + bvec(1) * tchvec1
                        if (aux .gt. bux) then
                            faux = ftab(irshft+1:irshft+npntintr,kntlm)
                            fbux = expvinv
                        else
                            faux = ftab(irshft+1:irshft+npntintr,kntlm) * r2l2
                            fbux = expvinv * r2l2
                        endif
                        do j = 2, mxlenpol-1
                            tchvec0a = tchvec0
                            tchvec0 = tchvec1
                            tchvec1 = dosxcheb * tchvec1 - tchvec0a
                            bvec(j) = dot_product(fk0,tchvec1) * dos * ri(npntintr)
                            fkvec0 = fkvec0 + bvec(j) * tchvec1
                            res = cux * cux * dot_product( ( faux - fkvec0 * fbux), (faux - fkvec0 * fbux))
                            if (res .lt. umbralres2) then
                                lenpol = j+1
                                exit
                            endif
                        enddo
                        if (lenpol .eq. 0) then
                            lenpol = mxlenpol
                        endif
                        icfpos(knticf) = icfpos(knticf-1) + lenpol
                        cfajust(icfpos(knticf-1):icfpos(knticf)-1) = bvec(0:lenpol-1)
                    endif	! End of Test: is the fragment negligible ?
                enddo	! End of loop on m
! 				r2l2 = r2l2 * rpntaj(irshft+1:irshft+npntintr)
            enddo		! End of loop on l
        enddo	! End of loop on intervals

!	Computes the atomic multipolar moments from the fit and some auxiliary integrals
        call multipolos(ia)

!	Fitting coefficients

!	Allocates memory for arrays cfrint1, cfrint2l2
        allocate(cfrint1(icfpos(knticf)-1), cfrint2l2(icfpos(knticf)-1), stat = ierr)
        if (ierr .ne. 0) then
            write(6,"('Memory error when allocating cfrint1 and cfrint2l2 in processor ',i8)") myrank
            abort = 1
            return
        endif
        if (longoutput) write(6,"('Size of cfrint1 and cfrint2l2  = ', i15, ' bytes')") size(cfrint1)
!	Fits the auxiliary integrals
!         rintr1(la,ma) =  Integrate[ r * fradtr[la,ma,r], {r,r0,l_k}]
!         rintr2l2 = Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(k-1),r0}]
        call fitrint(ia)
! 	writes data of center ia to file 'projectname'_2016.damqt
        write(10) icfpos(1:knticf)	! pointers to expansion coefficients of radial factors of center ia
        write(10) xajust(1:nintervaj)	! fitting exponents
!    fitting coeficients
        write(10) cfajust(1:icfpos(knticf)-1)	! Expansion coefficients
!	multipolar moments
        write(11) rmultipfr(1:lmtop,ia-istart+1)		! multipolar moments of center ia
!	Partial integrals for electrostatic potential and field
        write(11) QGpart(1:nintervaj*lmtop)
        write(11) qppart(1:nintervaj*lmtop)
!    fitting coeficients of auxiliary integrals for electrostatic potential and field
        write(11) cfrint1(1:icfpos(knticf)-1)	! Expansion coefficients of auxiliary integrals rint1
        write(11) cfrint2l2(1:icfpos(knticf)-1)	! Expansion coefficients of auxiliary integrals rint2l2
        deallocate (cfrint1,cfrint2l2)
    enddo	! End of Do over centers (ia)
    close(19)
    close(10)
    close(11)
    close(12)
    deallocate(besselint, cf12, dl, dosxcheb, expvec, expvinv, f0, fa, faux, fk0, ftab, fkvec0, h2f1, ha, qlm2c, &
            r2pow, rintr1, rintr2l2, rl, rlt, rpntaj, rpow, sint, tchvec0, tchvec1, tchvec0a, vaux1c, x12, xcheb, ymat1, ymat2)
    return
    end

!	---------------------------------------------------------------------------

  subroutine dsczazbnew(la, lb, Rab)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    real(KREAL) :: aux, bux, cux, Rab
    integer(KINT) :: i, j, k, kmb, l, la, labexp, lb, lbexp, lm, lma, lmbexp, ma, mb, mba
    real(KREAL), parameter :: umbraux = 1.d-20
! 	parameter (umbraux = 1.d-20) 
    real(KREAL) :: Rabpow(0:mxl)

    Rabpow(0) = uno	! Rabpow(i) = (-Rab)**i
    do i = 1, lb
        Rabpow(i) = -Rabpow(i-1) * Rab
    enddo
    lbexp = lmaxexp+lb
    lmbexp = (lbexp+1)*(lbexp+1)
    labexp = lbexp+la
    lmtop = (lmaxexp+1)*(lmaxexp+1)
    r2pow(1:npntaj,0) = uno		! r2pow(ir,l) = rpuntos(ir)**(2l)
    do l = 1, (labexp+max(la,lb))/2
        r2pow(1:npntaj,l) = r2pow(1:npntaj,l-1) * rpntaj(1:npntaj) * rpntaj(1:npntaj)
    enddo
    ha(1:npntaj,1:lmbexp) = cero
!	decomposes the product:  f0(l) * zlm(l,0) * zlmA(La,Ma) --> ha(lp,Ma) * zlm(lp,Ma)
    do ma = -la, la
        lma = la*(la+1)+ma+1
        dol1: do l = 0, labexp
            lm = l*(l+1) + 1
            do j = i1l1l2(lma,lm), i2l1l2(lma,lm)
                if (lml1l2(j) .gt. lmbexp) cycle dol1
                ha(1:npntaj,lml1l2(j)) = ha(1:npntaj,lml1l2(j)) + ccl1l2(j) * r2pow(1:npntaj,npl1l2(j)) * f0(1:npntaj,l)
            enddo
        enddo dol1
    enddo
!	decomposes the product:  ha(lp,Ma) * zlm(lp,Ma) * zlm(Lb,Mb) --> fa(l,m) * zlm(l,m)
    do mb = -lb, lb
        mba = abs(mb)
        do k = mba, lb
            bux = bin(ind(lb+mba)+k+mba+1) * Rabpow(lb-k)
            kmb = k*(k+1)+mb+1
            do ma = -la, la
                cux = bux * roblk(ma,mb)
                if (abs(cux) .lt. umbraux) cycle
                dol2: do l = abs(ma), lbexp
                    lma = l*(l+1)+ma+1
                    do j = i1l1l2(lma,kmb), i2l1l2(lma,kmb)
                        aux = cux * ccl1l2(j)
                        if (lml1l2(j) .gt. lmtop) cycle dol2
                        fa(1:npntaj,lml1l2(j)) = fa(1:npntaj,lml1l2(j)) + aux * r2pow(1:npntaj,npl1l2(j)) * ha(1:npntaj,lma)
                    enddo
                enddo dol2
            enddo
        enddo
    enddo
    return
    end

!   ***************************************************************

   subroutine frgsiggauss(lf0, i1, i2, rab)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE GAUSS
    implicit double precision (a-h,o-z)
    logical :: lf0
    real(KREAL) :: vaux(mxprimit), vbux(0:mxltot), bi(0:mxltot), rieqj(mxprimit)
    integer(KINT) :: igtj(mxprimit)
    lsup = lmaxexp + ll(i1) + ll(i2)
    lsupbi = max(lsup,5)
    lsup2 = lsupbi+lsupbi
    nprimi = nprimit(i1)
    nprimj = nprimit(i2)
    i1ini = ipntprim(i1)
    i2ini = ipntprim(i2)
    i1fin = ipntprim(i1)+nprimi-1
    i2fin = ipntprim(i2)+nprimj-1
    do ii = 1, nprimj
            igtj(ii) = nprimi+1
    enddo
    k = 0
    rieqj = cero
    rieqj(1) = uno
    lf0 = .false.
    do i = i1ini, i1fin
        k = k + 1
        if (xxg(i2ini) .le. xxg(i)) then
            igtj(1) = k
            if (xxg(i2ini) .eq. xxg(i)) rieqj(1) = umed
            lf0 = .true.
            exit
        endif
    enddo
    if (.not. lf0)	 return	! Not xxg(i) >= xxg(j) => Null radial factor => returns  lf0 = .false.
    jfinal = nprimj
    doj: do j = 2, nprimj
        rieqj(j) = uno
        do i = max(1,igtj(j-1)), nprimi
            if (xxg(j+i2ini-1) .le. xxg(i+i1ini-1)) then
                igtj(j) = i
                if (xxg(j+i2ini-1) .eq. xxg(i+i1ini-1)) rieqj(j) = umed
                cycle doj
            endif
        enddo
        jfinal = j-1     ! last value of j for which some xxg(i) >= xxg(j) exists
        exit
    enddo doj
    do ipunt = 1, npntaj
!	Loads vaux with the values of the primitives of A in the tabulation point
        r = rpntaj(ipunt)
        r2 = r*r
        k = 0
        do i = i1ini, i1fin
                k = k + 1
                vaux(k) = cfcontr(i) * exp(-xxg(i)*r2)
        enddo
!	Loads zeroes in the array of partial sums
        do i = 0, lsup
                vbux(i) = 0.d0
        enddo
!    Computes BesselI functions  times the factor
!       Exp(-xxg(j)*(r**2+rab**2) * Sqrt[Pi/(r*rab*xxg(j))] * cfcontr(j)
        argcorte = 3.d0 * max(lsup,10)
        do jj = 1, jfinal
            j = jj+i2ini-1
            aux = xxg(j) * (r-rab)*(r-rab)
            if (aux .lt. 100.d0) then   ! Test on the argument of the exponential
                argi = 2.d0 * xxg(j) * r * rab
                arginv = 1.d0 / argi
                if (argi .ge. argcorte) then   ! Usa la formula cerrada
                    expaux = dexp(-aux)
                    sum1 = 1.d0 - arginv
                    sum0 = 1.d0 - arginv
                    bux = .5d0 * arginv
                    do k = 1, lsupbi-2
                        sum1 = facti(k+1) - re(lsup2-k) * ri(lsupbi-k) * sum1 * bux
                        sum0 = facti(k+1) - re(lsup2-2-k)* ri(lsupbi-1-k) * sum0 * bux
                    enddo
                    sum0 = fact(lsupbi-1) * sum0
                    sum1 = 1.d0-fact(lsupbi)*re(lsupbi+1)*sum1*bux
                    bi(lsupbi) = sum1 * arginv * expaux * cfcontr(j)
                    bi(lsupbi-1) = sum0 * arginv * expaux * cfcontr(j)
                else                           ! Usa la serie
                    expaux = dexp(-xxg(j)*(r*r+rab*rab))
                    bux = .5d0 * argi * argi
                    sum1 = 1.d0
                    sum0 = 1.d0
                    kmax = lsupbi + 41
                    do k = 0, kmax-1
                        sum1 = 1.d0 + ri(kmax-k)* ri(2*(lsupbi+kmax-k)+1) * bux * sum1
                        sum0 = 1.d0 + ri(kmax-k)* ri(2*(lsupbi-1+kmax-k)+1) * bux * sum0
                    enddo
                    aux = (.5d0 * argi)**(lsupbi-1)*expaux*cfcontr(j)*raizpi
                    bi(lsupbi)=(.5d0*argi)*aux*sum1/facts(lsupbi)
                    bi(lsupbi-1)=aux*sum0/facts(lsupbi-1)
                endif
                do k = lsupbi-1, 1, -1
                    bi(k-1) = bi(k+1) + re(k+k+1) * arginv * bi(k)
                enddo
!    Loads matrix vbux
                aux = rieqj(jj) * vaux(igtj(jj))
                do l = 0, lsup
                    vbux(l) = vbux(l) + aux * bi(l)
                enddo
                do i = igtj(jj)+1, nprimi
                    do l = 0, lsup
                        vbux(l) = vbux(l) + vaux(i) * bi(l)
                    enddo
                enddo
            endif    ! End of Test on the argument of the exponential
        enddo     ! End of loop on jj
        rinv = 1.d0 / r
        aux = 0.5d0
        do l = 0, lsup
            f0(ipunt,l) = vbux(l) * aux * re(l+l+1)
            aux = aux * rinv
        enddo
    enddo     ! End of loop on ipunt
    return
    end

!   ***************************************************************

  subroutine bivsub(ia, ib, rab)
    USE MPI
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE GAUSS
    USE GENCONTRACTMOD
    USE PARALELO
    implicit none
    integer(KINT) :: i, ia, iashells, ib, ibshells, ierr, ii, ipunt, j, ja, jb, jfinal
    integer(KINT) :: k, knti1i2, kmax, lsup, lsup2, lsupbi, nprimi, nprimj
    integer(KINT) :: igtj(mxprimit)
    real(KREAL)   :: argcorte, argi, arginv, aux, bux, expaux, r, r2, rab, sum0, sum1
    real(KREAL)   :: bi(0:mxltot)
    logical       :: lf0

    iashells = basis(ia)%nshells
    ibshells = basis(ib)%nshells
    lsup = lmaxexp + basis(ia)%lmax + basis(ib)%lmax
    lsupbi = max(lsup,5)

    if(allocated(biv)) deallocate(biv)
    if(allocated(knti1i2v)) deallocate(knti1i2v)
    allocate(biv(0:lsupbi,npntaj*iashells*ibshells*mxprimit), knti1i2v(iashells,ibshells), stat = ierr)
    if (ierr .ne. 0) then
       call error(1,'Memory error when allocating biv. Stop')
       write(6,"('Memory error when allocating biv  in processor ',i8)") myrank
       abort = 1
       return
    endif

    knti1i2 = 0
    do ja = 1, iashells
       do jb = 1, ibshells
          knti1i2v(ja,jb) = knti1i2
          lsup2 = lsupbi+lsupbi
          nprimi = basis(ia)%shells(ja)%nprim
          nprimj = basis(ib)%shells(jb)%nprim
          do ii = 1, nprimj
             igtj(ii) = nprimi+1
          enddo
          k = 0
          lf0 = .false.
          do i = 1, nprimi
             k = k + 1
             if (basis(ib)%shells(jb)%exp(1) .le. basis(ia)%shells(ja)%exp(i)) then
                igtj(1) = k
                lf0 = .true.
                exit
             endif
          enddo
          if (.not. lf0) then   ! No xxg(i,ia) >= xxg(j,ib) => Null radial factor => returns  lf0 = .false.
             knti1i2v(ja,jb) = -1
             cycle
          endif
          jfinal = nprimj
          doj: do j = 2, nprimj
             do i = max(1,igtj(j-1)), nprimi
                if (basis(ib)%shells(jb)%exp(j) .le. basis(ia)%shells(ja)%exp(i)) then
                   igtj(j) = i
                   cycle doj
                endif
             enddo
             jfinal = j-1     ! last value of j for which some xxg(i) >= xxg(j) exists
             exit
          enddo doj
          do ipunt = 1, npntaj
!   Loads vaux with the values of the primitives of A in the tabulation point
             r = rpntaj(ipunt)
             r2 = r*r
!    Computes Bessel I functions of argument 2*r*rab*xxg(j) times the factor
!       Exp(-xxg(j)*(r**2+rab**2) * Sqrt[Pi/(r*rab*xxg(j))]
             argcorte = 3.d0 * max(lsup,10)
             do j = 1, jfinal
                knti1i2 = knti1i2 + 1
                aux = basis(ib)%shells(jb)%exp(j) * (r-rab)*(r-rab)
                if (aux .ge. 100.d0) then   ! Test on the argument of the exponential
                   biv(:,knti1i2) = cero
                else
                   argi = 2.d0 * basis(ib)%shells(jb)%exp(j) * r * rab
                   arginv = 1.d0 / argi
                   if (argi .ge. argcorte) then   ! Usa la formula cerrada
                      expaux = dexp(-aux)
                      sum1 = 1.d0 - arginv
                      sum0 = 1.d0 - arginv
                      bux = .5d0 * arginv
                      do k = 1, lsupbi-2
                            sum1 = facti(k+1) - re(lsup2-k) * ri(lsupbi-k) * sum1 * bux
                            sum0 = facti(k+1) - re(lsup2-2-k)* ri(lsupbi-1-k) * sum0 * bux
                      enddo
                      sum0 = fact(lsupbi-1) * sum0
                      sum1 = 1.d0-fact(lsupbi)*re(lsupbi+1)*sum1*bux
                      biv(lsupbi,knti1i2) = sum1 * arginv * expaux
                      biv(lsupbi-1,knti1i2) = sum0 * arginv * expaux
                   else                           ! Usa la serie
                      expaux = dexp(-basis(ib)%shells(jb)%exp(j)*(r*r+rab*rab))
                      bux = .5d0 * argi * argi
                      sum1 = 1.d0
                      sum0 = 1.d0
                      kmax = lsupbi + 41
                      do k = 0, kmax-1
                            sum1 = 1.d0 + ri(kmax-k)* ri(2*(lsupbi+kmax-k)+1) * bux * sum1
                            sum0 = 1.d0 + ri(kmax-k)* ri(2*(lsupbi-1+kmax-k)+1) * bux * sum0
                      enddo
                      aux = (.5d0 * argi)**(lsupbi-1)*expaux*raizpi
                      biv(lsupbi,knti1i2)=(.5d0*argi)*aux*sum1/facts(lsupbi)
                      biv(lsupbi-1,knti1i2)=aux*sum0/facts(lsupbi-1)
                   endif
                   do k = lsupbi-1, 1, -1
                      biv(k-1,knti1i2) = biv(k+1,knti1i2) + re(k+k+1) * arginv * biv(k,knti1i2)
                   enddo
                endif    ! End of Test on the argument of the exponential
             enddo     ! End of loop on j
          enddo     ! End of loop on ipunt
       enddo     ! End of loop on ib
    enddo     ! End of loop on ia
    return
    end

!   ***************************************************************

  subroutine frgsiggencontr(lf0, ia, ib, i1, i2, rab)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE GAUSS
    USE GENCONTRACTMOD
    implicit none
    integer(KINT) :: i, i1, i2, ia, ib, ii, ipunt, j, ja, jb, jini, jfinal
    integer(KINT) :: k, knti1i2, l, la, lb, lsup, lsup2, lsupbi, nprimi, nprimj
    real(KREAL) :: aux, r, r2, rab, rinv
    logical :: lf0
    real(KREAL) :: vaux(mxprimit), vbux(0:mxltot), bi(0:mxltot), rieqj(mxprimit)
    integer(KINT) :: igtj(mxprimit)

    la = ll(i1)
    lb = ll(i2)


    knti1i2 = knti1i2v(la+1,lb+1)
    if (knti1i2 .lt. 0) then
       lf0 = .false.
       return
    endif

    ja = kntcoefa(la)
    jb = kntcoefb(lb)

    lsup = lmaxexp + la + lb
    lsupbi = max(lsup,5)

    nprimi = basis(ia)%shells(la+1)%nprim
    nprimj = basis(ib)%shells(lb+1)%nprim

    jini = 0
    do ii = 1, nprimj
       igtj(ii) = nprimi+1
       if (jini .eq. 0 .and. abs(basis(ib)%shells(lb+1)%coef(ii,jb)) .gt. 1.d-20) then
          jini = ii
       endif
    enddo

    k = 0
    rieqj = cero
    rieqj(1) = uno
    lf0 = .false.
    do i = 1, nprimi
       k = k + 1
       if (abs(basis(ia)%shells(la+1)%coef(i,ja)) .lt.  1.d-20) cycle
       if (basis(ib)%shells(lb+1)%exp(jini) .le. basis(ia)%shells(la+1)%exp(i)) then
          if (basis(ib)%shells(lb+1)%exp(jini) .eq. basis(ia)%shells(la+1)%exp(i)) rieqj(jini) = umed
          igtj(jini) = k
          lf0 = .true.
          exit
       endif
    enddo
    if (.not. lf0)    return   ! No xxg(i,ia) >= xxg(j,ib) => Null radial factor => returns  lf0 = .false.

    jfinal = nprimj
    doj: do j = jini+1, nprimj
       rieqj(j) = uno
       do i = max(1,igtj(j-1)), nprimi
          if (basis(ib)%shells(lb+1)%exp(j) .le. basis(ia)%shells(la+1)%exp(i)) then
             if (basis(ib)%shells(lb+1)%exp(j) .eq. basis(ia)%shells(la+1)%exp(i)) rieqj(j) = umed
             igtj(j) = i
             cycle doj
          endif
       enddo
       jfinal = j-1     ! last value of j for which some xxg(i) >= xxg(j) exists
       exit
    enddo doj

    do ipunt = 1, npntaj
!   Loads vaux with the values of the primitives of A in the tabulation point
        r = rpntaj(ipunt)
        r2 = r*r
        vaux(1:nprimi) = basis(ia)%shells(la+1)%coef(:,ja)  * exp(-basis(ia)%shells(la+1)%exp(:)*r2)
!   Loads zeroes in the array of partial sums
        vbux(0:lsup) = 0.d0
        if (jini .gt. 1) knti1i2 = knti1i2 + jini - 1
        do j = jini, jfinal
            knti1i2 = knti1i2 + 1
            if (igtj(j) .gt. nprimi .or. abs(basis(ib)%shells(lb+1)%coef(j,jb)) .lt. 1.d-20) cycle
            if (basis(ib)%shells(lb+1)%exp(j) * (r-rab)*(r-rab) .lt. 100.d0) then   ! Test on the argument of the exponential
                bi(0:lsup) = biv(0:lsup,knti1i2) * basis(ib)%shells(lb+1)%coef(j,jb)
                vbux(0:lsup) = vbux(0:lsup) + rieqj(j) * vaux(igtj(j)) * bi(0:lsup)
                do i = igtj(j)+1, nprimi
                   vbux(0:lsup) = vbux(0:lsup) + vaux(i) * bi(0:lsup)
                enddo
            endif    ! End of Test on the argument of the exponential
        enddo     ! End of loop on j
        rinv = 1.d0 / r
        aux = 0.5d0
        do l = 0, lsup
            f0(ipunt,l) = vbux(l) * aux * re(l+l+1)
            aux = aux * rinv
        enddo
    enddo     ! End of loop on ipunt
    return
    end
!
!   ***************************************************************
!
!	Subroutine for computing the total atomic multipolar moments and the integrals:
!		qppart(la,ma,i;ia) = 
!			Integrate[ r * fradtr[la,ma,r], {r,l_(i-1),l_i}]
!		QGpart(la,ma,i;ia) = 
!			Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(i-1),l_i}]
!     where  ia  labels the center (atom),
!	 fradtr[la,ma,r]  stands for the piecewise representation
!     of the corresponding radial factor, and  (l_(i-1), l_i)  are the
!     (lower,upper) bounds of the i-th interval..
!     These integrals are useful for computing the potential,
!     field and Hellmann-Feynman forces generated by the corresponding component of 
!     the atomic electron density (see programs DAMPOT, DAMFIELD, DAMFORCES)

   subroutine multipolos(ia)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    real(KREAL) :: ai, aiinv, argdlt, argsg, aux, auxa, auxb, bux, dlt2, dlti, dosdltsg
    real(KREAL) :: pi4d2l1, rinf, rl12, rl32, rl52, rsup, sgi, sg2, suma, sumb, w, zz
    integer(KINT) :: i, i1, ia, icflm, kchb, kk, knt, kntcf, kntlm, kntq, l, l2, la, lk, m, ma, n, ntpow
    real(KREAL) :: cfpows(0:mxlenpol-1), gl(0:mxtpw+2), rint(0:mxtpw)
    if (ngini(ia) .le. 0) return
    knt = 0
    ntpow = 2*lmaxexp + 2 + mxlenpol + 1
    rinf = cero
    do i = 1, nintervaj      ! Do over intervals
        rsup = rinterv(i)
        dlti = umed * (rsup - rinf)
        sgi = umed * (rsup + rinf)
        if (xajust(i) .gt. udec) then	! Non null exponent: computes the integrals:  Integral[dlti * t**j * Exp[-xi*r(t)],{t,-1,1}]
            argdlt = xajust(i) * dlti
            argsg = xajust(i) * sgi
            w = dlti * exp(-argsg)
!				Computes the integrals:   Int[ Exp[-argdlt * t] * LegendreP[l,t], {t,-1,1}]
!    			by means of:   Int[ Exp[-z * t] * LegendreP[l,t], {t,-1,1}] = (-1)**l 2 z**l * 0F1[l+3/2,z**2/4] / (2l+1)!!
!    			starting with the hypergeometrics 0F1[...] corresponding to  l = ntpow  and  l = ntpow-1
!    			the remaining ones being obtained by means of:  0F1[l-1,z] = 0F1[l,z] + 0F1[l+1,z] * z / ( l (l-1) )
!				hypergeometrics 0F1[ntpow,z**2/4] and  0F1[ntpow-1,z**2/4]
            auxa = uno
            auxb = uno
            suma = uno
            sumb = uno
            ai = uno
            rl32 = ntpow + umed + uno
            rl52 = ntpow + umed + dos
            zz = pt25 * argdlt * argdlt
            do i1 = 1, 1000
                aiinv = uno / ai
                auxa = auxa * zz * aiinv / rl32
                auxb = auxb * zz * aiinv / rl52
                suma = suma + auxa
                sumb = sumb + auxb
                rl32 = rl32 + uno
                rl52 = rl52 + uno
                ai = ai + uno
                if (auxa .lt. (1.d-15*suma) ) go to 234
            enddo
            write(6,"(/,'WARNING: The computation of the hypergeometrics 0F1 does not converge in subroutine multipolos' &
                    ,/, 'suma = ', e22.15, ' auxa = ', e22.15, ' sumb = ', e22.15, ' auxb = ', e22.15,/)") suma, auxa, sumb, auxb
234				continue
            gl(ntpow+1) = sumb
            gl(ntpow)   = suma
!    			backwards recursion of the hypergeometrics 0F1
                rl32 = ntpow + umed + uno
                rl12 = ntpow + umed
                do l = ntpow, 1, -1
                gl(l-1) = gl(l) + zz * gl(l+1) / (rl32 * rl12)
                rl32 = rl12
                rl12 = rl12 - uno
            enddo
!				transforms the hypergeometrics into integrals over Legendre polynomials
            aux = dos
            do l = 0, ntpow+1
                gl(l) = aux * gl(l)
                aux = - aux * argdlt * dosl1i(l+1)
            enddo
!     		transforms the integrals over Legendre polynomials into integrals over powers of  t
            rint(0) = gl(0) * w
            do l = 1, ntpow
                aux = cero
                do lk = 0, ntpow-l
                        bux = ri(lk+lk+1) * (re(lk+1) * gl(lk+1) + re(lk) * aux )
                        aux = gl(lk)
                        gl(lk) = bux
                enddo
                rint(l) = gl(0) * w
            enddo
        else		! Null exponent: Computes the integrals: Integral[dlti * t**j,{t,-1,1}]
            aux = rsup - rinf
            do l = 0, ntpow-1, 2
                rint(l) = aux * ri(l+1)
                rint(l+1) = cero
            enddo
            if (mod(ntpow,2) .eq. 0) rint(ntpow) = aux * ri(ntpow+1)
        endif
!-------------------------------------------------------------------------------
!	 Integrals:
!		qppart(la,ma,i) = Integrate[ r * fradtr[la,ma,r], {r,l_(i-1),l_i}]
!-------------------------------------------------------------------------------
        kntq = knt
        kntlm = 0
        do la = 0, lmaxexp
            do ma = -la, la
                kntlm = kntlm + 1
                kntq = kntq + 1
                if (icfpos(kntlm+(i-1)*lmtop+1) .le. icfpos(kntlm+(i-1)*lmtop)) then ! If the radial factor is null
                    qppart(kntq) = cero
                else
!					Converts the expansion coefficients from Chebyshev T polynomials to powers
                    kchb = 0
                    cfpows = cero
                    do kk = 0, icfpos(kntlm+(i-1)*lmtop+1)-icfpos(kntlm+(i-1)*lmtop)-1
                        do n = 0, kk/2
                            kchb = kchb + 1
                            cfpows(kk-n-n) = cfpows(kk-n-n) + chebTcf(kchb) * cfajust(icfpos(kntlm+(i-1)*lmtop)+kk)
                        enddo
                    enddo
                    aux = cero
                    do kk = 0, icfpos(kntlm+(i-1)*lmtop+1)-icfpos(kntlm+(i-1)*lmtop)-1
                        aux = aux + cfpows(kk) * ( dlti*rint(kk+1) + sgi * rint(kk) )
                    enddo
                    qppart(kntq) = aux
                endif
            enddo	! End of Do on ma
        enddo	! End of Do on la
!	 Recursion on  l  of the integrals with powers of  t  to yield integrals  with powers of  r
        dlt2 = dlti*dlti
        sg2 = sgi * sgi
        dosdltsg = dos * dlti * sgi
        kntlm = 0
        do la = 0, lmaxexp
            l2 = la+la+2
            do kk = 0, ntpow-l2
                rint(kk) = dlt2*rint(kk+2) + dosdltsg*rint(kk+1) + sg2 * rint(kk)
            enddo
!-------------------------------------------------------------------------------
!	 Integrals:
!		QGpart(la,ma,i;ia) = Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(i-1),l_i}]
!-------------------------------------------------------------------------------
            pi4d2l1 = cuatro * pi * dosl1i(la)
            do ma = -la, la
                kntlm = kntlm + 1
                knt = knt + 1
                if (icfpos(kntlm+(i-1)*lmtop+1) .le. icfpos(kntlm+(i-1)*lmtop)) then ! If the radial factor is null
                    QGpart(knt) = cero
                else
!					Converts the expansion coefficients from Chebyshev T polynomials to powers
                    kchb = 0
                    cfpows = cero
                    do kk = 0, icfpos(kntlm+(i-1)*lmtop+1)-icfpos(kntlm+(i-1)*lmtop)-1
                        do n = 0, kk/2
                            kchb = kchb + 1
                            cfpows(kk-n-n) = cfpows(kk-n-n) + chebTcf(kchb) * cfajust(icfpos(kntlm+(i-1)*lmtop)+kk)
                        enddo
                    enddo
                    aux = cero
                    do kk = 0, icfpos(kntlm+(i-1)*lmtop+1)-icfpos(kntlm+(i-1)*lmtop)-1
                        aux = aux + cfpows(kk) * rint(kk)
                    enddo
                    QGpart(knt) = aux
                endif
            enddo  ! End of Do on ma
        enddo  ! End of Do on la
        rinf = rsup
    enddo   ! End of loop over intervals
    return
    end
	
!   ***************************************************************

!     Subroutine for fitting the  integrals:
!          rintr1(la,ma) = Integrate[ r * fradtr[la,ma,r], {r,r0,l_k}] ) 
!          rintr2l2(la,ma) = Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(k-1),r0}]
!     with    l_(k-1) < r0 < l_k
!     where   fradtr[la,ma,r]  stands for the piecewise representation
!     of the corresponding radial factor, and  (l_(i-1), l_i)  are the
!     (lower,upper) bounds of the i-th interval.

  subroutine fitrint(ia)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    integer(KINT) :: i, ia, j, k, knt, knticf, lm
    real(KREAL) :: rk, rkmrinfi, rsupmrki
    knticf = 0
    do i = 1, nintervaj
        do k = 1, npntintr
            rk = (rinterv(i)-rinterv(i-1)) * umed * (uno + xcheb(k)) + rinterv(i-1)
            call integfradk(i, ia, rk, xajust(i))
            rkmrinfi = uno / (rk - rinterv(i-1))
            rsupmrki = uno / (rinterv(i) - rk)
            ymat1(k,1:lmtop) = rintr1 * rsupmrki
            ymat2(k,1:lmtop) = rintr2l2 * rkmrinfi
        enddo
        do lm = 1, lmtop
            knticf = knticf + 1
            knt = icfpos(knticf)
            if ( knt .lt. icfpos(knticf+1)) then
                tchvec0 = uno
                tchvec1 = xcheb
                cfrint1(knt) = sum(ymat1(1:npntintr,lm)) * ri(npntintr)
                cfrint2l2(knt) = sum(ymat2(1:npntintr,lm)) * ri(npntintr)
                cfrint1(knt+1) = dot_product(ymat1(1:npntintr,lm), tchvec1) * dos * ri(npntintr)
                cfrint2l2(knt+1) = dot_product(ymat2(1:npntintr,lm), tchvec1) * dos * ri(npntintr)
                do j = 2, icfpos(knticf+1)-icfpos(knticf)-1
                    tchvec0a = tchvec0
                    tchvec0 = tchvec1
                    tchvec1 = dosxcheb * tchvec1 - tchvec0a
                    cfrint1(knt+j) = dot_product(ymat1(1:npntintr,lm), tchvec1) * dos * ri(npntintr)
                    cfrint2l2(knt+j) = dot_product(ymat2(1:npntintr,lm), tchvec1) * dos * ri(npntintr)
                enddo
            endif
        enddo
    enddo
    return
    end

!   ***************************************************************

!     Subroutine for computing the  integrals:
!          rintr1(la,ma) = Integrate[ r * fradtr[la,ma,r], {r,r0,l_k}] ) 
!          rintr2l2(la,ma) = Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(k-1),r0}]
!     with    l_(k-1) < r0 < l_k
!     where   fradtr[la,ma,r]  stands for the piecewise representation
!     of the corresponding radial factor, and  (l_(i-1), l_i)  are the
!     (lower,upper) bounds of the i-th interval.
  subroutine integfradk(interv, ia, r0, xaj)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    real(KREAL) :: aiinv, ai, argdlt, argsg, aux, auxa, auxb, auxj, auxp, bux, dlt2, dltbar, dlti, dltip, dosdltsg
    real(KREAL) :: r0, rl12, rl32, rl52, sg2, sgbar, sgi, sgip, suma, sumb, xaj, xi, w, zz
    integer(KINT) :: i1, ia, icflm, interv, intshft, ip, j, kchb, kk, kntcf, kntlm, l, l2, la, lenpol, lk, ma, n, ntpow
    real(KREAL) :: cfpows(0:mxlenpol-1), coef(0:mxlenpol-1), gl(0:mxtpw+2), rint(0:mxtpw)
!----------------------------------------------------------------------------------
!     Integrals:  rintr1(la,ma) =  Integrate[ r * fradtr[la,ma,r], {r,r0,l_k}] )
!----------------------------------------------------------------------------------
    ntpow = mxlenpol + 2
    dltip = umed * (rinterv(interv) - r0)
    sgip = umed * (rinterv(interv) + r0)
    intshft = (interv-1)*lmtop
    if (xaj .gt. cero) then	! Interval with exponential
!    	Starts with the integrals:  Integral[t**j * Exp[-xi*r(t)],{t,-1,1}]
        argdlt = xaj * dltip
        argsg = xaj * sgip
        w = dltip * exp(-argsg)
!     Computes the integrals:   Int[ Exp[-argdlt * t] * LegendreP[l,t], {t,-1,1}]
!     by means of:   Int[ Exp[-z * t] * LegendreP[l,t], {t,-1,1}] = (-1)**l 2 z**l * 0F1[l+3/2,z**2/4] / (2l+1)!!
!     starting with the hypergeometrics 0F1[...] corresponding to  l = ntpow  and  l = ntpow-1
!     the remaining ones being obtained by means of:  0F1[l-1,z] = 0F1[l,z] + 0F1[l+1,z] * z / ( l (l-1) )
!
!	 hypergeometrics 0F1[ntpow,z**2/4] and  0F1[ntpow-1,z**2/4]
        auxa = uno
        auxb = uno
        suma = uno
        sumb = uno
        ai = uno
        rl32 = ntpow + umed + uno
        rl52 = ntpow + umed + dos
        zz = pt25 * argdlt * argdlt
        do i1 = 1, 1000
            aiinv = uno / ai
            auxa = auxa * zz * aiinv / rl32
            auxb = auxb * zz * aiinv / rl52
            suma = suma + auxa
            sumb = sumb + auxb
            rl32 = rl32 + uno
            rl52 = rl52 + uno
            ai = ai + uno
            if (auxa .lt. (1.d-15*suma) ) go to 334
        enddo
        write(6,"('WARNING: The computation of the hypergeometrics 0F1 does not converge in subroutine integfradk' &
                ,/, 'suma = ', e22.15, ' auxa = ', e22.15, ' sumb = ', e22.15, ' auxb = ', e22.15)") suma, auxa, sumb, auxb
334			continue
        gl(ntpow+1) = sumb
        gl(ntpow)   = suma
!    backwards recursion of the hypergeometrics  0F1
        rl32 = ntpow + uno + umed
        rl12 = ntpow + umed
        do l = ntpow, 1, -1
            gl(l-1) = gl(l) + zz * gl(l+1) / (rl32 * rl12)
            rl32 = rl12
            rl12 = rl12 - uno
        enddo
!     transforms the hypergeometrics into integrals over Legendre polynomials
        aux = dos
        do l = 0, ntpow+1
            gl(l) = aux * gl(l)
            aux = - aux * argdlt * dosl1i(l+1)
        enddo
!     transforms the integrals over Legendre polynomials into integrals over powers of  t
        rint(0) = gl(0) * w
        do l = 1, ntpow
            aux = cero
            do lk = 0, ntpow-l
                    bux = ri(lk+lk+1) * (re(lk+1) * gl(lk+1) + re(lk) * aux )
                    aux = gl(lk)
                    gl(lk) = bux
            enddo
            rint(l) = gl(0) * w
        enddo
    else	!	Interval with zero exponent in the exponential (only polynomial)
!			Computes the integrals: Integral[dlti * t**j,{t,-1,1}]
        do l = 0, ntpow-1, 2
            rint(l) = (dltip+dltip) * ri(l+1)
            rint(l+1) = cero
        enddo
        if (mod(ntpow,2) .eq. 0) rint(ntpow) = dltip * ri(ntpow+1)
    endif

    kntlm = 0
    do la = 0, lmaxexp
        do ma = -la, la
            kntlm = kntlm + 1
            icflm = icfpos(kntlm+intshft)
            if (icfpos(kntlm+intshft+1) .le. icflm) then   ! If the radial factor is null, loads zeroes and jumps to next
                rintr1(kntlm) = cero
            else
!			Converts the expansion coefficients from Chebyshev T polynomials to powers
                kchb = 0
                cfpows = cero
                lenpol = icfpos(kntlm+intshft+1)-icflm
                kntcf = icflm
                do kk = 0, lenpol-1
                    do n = 0, kk/2
                        kchb = kchb + 1
                        cfpows(kk-n-n) = cfpows(kk-n-n) + chebTcf(kchb) * cfajust(kntcf)
                    enddo
                    kntcf = kntcf + 1
                enddo
                aux = cero
!    		Transforms the coefficients
                dltbar=(rinterv(interv)-r0) / (rinterv(interv)-rinterv(interv-1))
                sgbar=(r0-rinterv(interv-1)) / (rinterv(interv)-rinterv(interv-1))
                auxj = uno
                do j = 0, lenpol-1
                    suma = cero
                    auxp = uno
                    do ip = 0, lenpol-1-j
                        suma = suma + cfpows(ip+j) * auxp
                        auxp = auxp * sgbar * re(ip+j+1) * ri(ip+1)
                    enddo
                    coef(j) = suma * auxj
                    auxj = auxj * dltbar
                enddo
!			Computes the integral
                do kk = 0, lenpol-1
                    aux = aux + coef(kk) * ( dltip*rint(kk+1) + sgip * rint(kk) )
                enddo
                rintr1(kntlm) = aux
            endif
        enddo    ! End of Do on ma
    enddo    ! End of Do on la
!-----------------------------------------------------------------------------------
!     Integral:  rintr2l2 = Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(k-1),r0}]
!-----------------------------------------------------------------------------------
    ntpow = 2*lmaxexp + 2 + mxlenpol + 1
    dlti = umed * (r0 - rinterv(interv-1))
    sgi = umed * (r0 + rinterv(interv-1))
    if (xaj .gt. cero) then	! Interval with exponential
        argdlt = xaj * dlti
        argsg = xaj * sgi
        w = dlti * exp(-argsg)
!     Computes the integrals:   Int[ Exp[-argdlt * t] * LegendreP[l,t], {t,-1,1}]
!     by means of:   Int[ Exp[-z * t] * LegendreP[l,t], {t,-1,1}] = (-1)**l 2 z**l * 0F1[l+3/2,z**2/4] / (2l+1)!!
!     starting with the hypergeometrics 0F1[...] corresponding to  l = ntpow  and  l = ntpow-1
!     the remaining ones being obtained by means of:  0F1[l-1,z] = 0F1[l,z] + 0F1[l+1,z] * z / ( l (l-1) )
!
!	 hypergeometrics 0F1[ntpow,z**2/4] and  0F1[ntpow-1,z**2/4]
        auxa = uno
        auxb = uno
        suma = uno
        sumb = uno
        ai = uno
        rl32 = ntpow + uno + umed
        rl52 = ntpow + dos + umed
        zz = pt25 * argdlt * argdlt
        do i1 = 1, 1000
            aiinv = uno / ai
            auxa = auxa * zz * aiinv / rl32
            auxb = auxb * zz * aiinv / rl52
            suma = suma + auxa
            sumb = sumb + auxb
            rl32 = rl32 + uno
            rl52 = rl52 + uno
            ai = ai + uno
            if (auxa .lt. (1.d-15*suma) ) go to 234
        enddo
        write(6,"('WARNING: The computation of the hypergeometrics 0F1 does not converge in subroutine integfradk' &
                ,/, 'suma = ', e22.15, ' auxa = ', e22.15, ' sumb = ', e22.15, ' auxb = ', e22.15)") suma, auxa, sumb, auxb
234     continue
        gl(ntpow+1) = sumb
        gl(ntpow)   = suma
!		backwards recursion of the hypergeometrics  0F1
        rl32 = ntpow + uno + umed
        rl12 = ntpow + umed
        do l = ntpow, 1, -1
            gl(l-1) = gl(l) + zz * gl(l+1) / (rl32 * rl12)
            rl32 = rl12
            rl12 = rl12 - uno
        enddo
!	    	 transforms the hypergeometrics into integrals over Legendre polynomials
        aux = dos
        do l = 0, ntpow+1
            gl(l) = aux * gl(l)
            aux = - aux * argdlt * dosl1i(l+1)
        enddo
!	   		transforms the integrals over Legendre polynomials into integrals over powers of  t
        rint(0) = gl(0) * w
        do l = 1, ntpow
            aux = cero
            do lk = 0, ntpow-l
                bux = ri(lk+lk+1) * (re(lk+1) * gl(lk+1) + re(lk) * aux )
                aux = gl(lk)
                gl(lk) = bux
            enddo
            rint(l) = gl(0) * w
        enddo
    else	!	Interval with zero exponent in the exponential (only polynomial)
!			Computes the integrals: Integral[dlti * t**j,{t,-1,1}]
        do l = 0, ntpow-1, 2
            rint(l) = (dlti+dlti) * ri(l+1)
            rint(l+1) = cero
        enddo
        if (mod(ntpow,2) .eq. 0) rint(ntpow) = dlti * ri(ntpow+1)
    endif
!	Recursion on  l  of the integrals with powers of  t  to yield integrals  with powers of  r
    kntlm = 0
    do la = 0, lmaxexp
        l2 = 2*la+2
        dlt2 = dlti*dlti
        sg2 = sgi * sgi
        dosdltsg = dos * dlti * sgi
        do kk = 0, ntpow-l2
                rint(kk) = dlt2*rint(kk+2) + dosdltsg*rint(kk+1) + sg2 * rint(kk)
        enddo
        do ma = -la, la
            kntlm = kntlm + 1
            icflm = icfpos(kntlm+intshft)
            if (icfpos(kntlm+intshft+1) .le. icflm) then 	! If the radial factor is null, loads zeroes and jumps to next
                rintr2l2(kntlm) = cero
            else
                kntcf = icflm
                lenpol = icfpos(kntlm+intshft+1)-icflm
!			Converts the expansion coefficients from Chebyshev T polynomials to powers
                kchb = 0
                cfpows = cero
                do kk = 0, lenpol-1
                    do n = 0, kk/2
                        kchb = kchb + 1
                        cfpows(kk-n-n) = cfpows(kk-n-n) + chebTcf(kchb) * cfajust(kntcf)
                    enddo
                    kntcf = kntcf + 1
                enddo
!    		Transforms the coefficients
                dltbar = (r0-rinterv(interv-1)) / (rinterv(interv)-rinterv(interv-1))
                sgbar = (r0-rinterv(interv)) / (rinterv(interv)-rinterv(interv-1))
                auxj = uno
                do j = 0, lenpol-1
                    suma = cero
                    auxp = uno
                    do ip = j, lenpol-1
                        suma = suma + cfpows(ip) * auxp
                        auxp = auxp * sgbar * re(ip+1) * ri(ip+1-j)
                    enddo
                    coef(j) = suma * auxj
                    auxj = auxj * dltbar
                enddo
                aux = cero
                do kk = 0, lenpol-1
                    aux = aux + coef(kk) * rint(kk)
                enddo
                rintr2l2(kntlm) = aux
            endif
        enddo   ! End of Do on ma
    enddo   ! End of Do on la
    return
    end
!
!	********************************************************
!
!	Subroutine for computing multipolar moments of the fragments of a two-center
!	charge distribution of CGTO
  subroutine multfrg2cgauss(i1, i2, R)
    USE MPI
    USE DAM320_D
    USE DAM320_DATA_D
    USE DAM320_CONST_D
    USE GAUSS
    USE PARALELO
    implicit none
    integer(KINT) :: i, i1, i1p, i2, i2p, i1ini, i1fin, i2ini, i2fin, ip, ipp, kmb, kp
    integer(KINT) :: l, la, lb, llpm, lma, lmlt, lmtot, ma, mb, n, nprimi, nprimj
    real(KREAL) :: ai, aux, b2d4a, bux, cux, dux, h1f1, R
    lmtot = (mxltot+1)**2
    la = ll(i1)
    lb = ll(i2)
    nprimi = nprimit(i1)
    nprimj = nprimit(i2)
    i1ini = ipntprim(i1)
    i2ini = ipntprim(i2)
    if (i1ini .le. 0 .or. i2ini .le. 0) return
    i1fin = ipntprim(i1)+nprimi-1
    i2fin = ipntprim(i2)+nprimj-1
    besselint = cero
    do i2p = i2ini, i2fin
        dux = cfcontr(i2p) * raizpi
        do i1p = i1ini, i1fin
            if (xxg(i1p) .lt. xxg(i2p)) cycle
            ai = uno / (xxg(i1p)+xxg(i2p))
            b2d4a = xxg(i2p) * xxg(i2p) * R * R * ai
            if (xxg(i1p) * xxg(i2p) * R * R * ai .gt. 200.d0) cycle
            aux = umed * ai * sqrt(ai) * exp(-xxg(i1p) * xxg(i2p) * R * R * ai)
            if (xxg(i1p) .eq. xxg(i2p)) aux = umed * aux
            do l = 0, lmaxexp+la+lb
                bux = umed * dosl1(l) * aux	! incluye el factor (l+1/2)
                do n = 0, la + lb
                    cux = uno
                    h1f1 = uno
                    do i = 1, n
                        cux = cux * re(n+1-i) * dos * ri(l+l+i+i+1) * b2d4a * ri(i)
                        h1f1 = h1f1 + cux
                    enddo
                    besselint(n,l) = besselint(n,l) + cfcontr(i1p) * bux * dux * h1f1
                    bux = umed * re(l+l+n+n+3) * ai * bux
                enddo
                aux = xxg(i2p) * R * ai * aux
            enddo
        enddo
    enddo

    aux = cuatro * pi
    do mb = -lb, lb
        do ma = -la, la
            lma = la*(la+1)+ma+1
            cux = aux * roblk(ma,mb)	! Introduces the normalization factors and the density matrix elements
            do kp = lb, abs(mb), -1
                kmb = kp*(kp+1)+mb+1
                dux = cux * bin(ind(lb+abs(mb))+kp+abs(mb)+1)
                do l = 0, lmaxexp+la+lb
                    do ip = i1l1l2(lma,l*(l+1)+1), i2l1l2(lma,l*(l+1)+1)
                        if (llm(lml1l2(ip)) .lt. abs(ma)) cycle
                        llpm = llm(lml1l2(ip))*(llm(lml1l2(ip))+1)+ma+1
                        if (llpm .gt. lmtot) cycle
                        do ipp = i1l1l2(llpm,kmb), i2l1l2(llpm,kmb)
                            lmlt = llm(lml1l2(ipp))
                            if (lmlt .gt. lmaxexp) cycle
                            qlm2c(lmlt*(lmlt+1)+mlm(lml1l2(ipp))+1) = qlm2c(lmlt*(lmlt+1)+mlm(lml1l2(ipp))+1) &
                                    + dux * ccl1l2(ip) * ccl1l2(ipp) * dosl1i(lmlt) &
                                    * besselint(la+kp-npl1l2(ip)-npl1l2(ipp),l)
                        enddo
                    enddo
                enddo
                cux = - cux * R
            enddo
        enddo
    enddo
    return
    end
!
!	********************************************************
!
!	Subroutine for computing multipolar moments of the fragments of a two-center
!	charge distribution of CGTO
!	Version based on the shift-operators technique
!
  subroutine multfrg2cgaussnw(i1, i2, R)
    USE DAM320_D
    USE DAM320_DATA_D
    USE DAM320_CONST_D
    USE GAUSS
    implicit none
    integer(KINT) :: i, i1, i1p, i2, i2p, i1ini, i1fin, i2ini, i2fin, ip, ipp, j, k, kmb, knt, kp
    integer(KINT) :: l, la, lb, llpm, lm, lma, lmax, lmlt, ln, m, ma, maxl, mb, minl, n, nmax, nprimi, nprimj
    real(KREAL) :: ai, aux, b2d4a, bux, cux, dux, h1f1, R, R2, sumk, sump, xiabinv, w, z
    real(KREAL) :: phi(-(lmaxexp+mxl)/2:0), rpw(0:lmaxexp+mxldst), xikv(0:mxl)
    la = ll(i1)
    lb = ll(i2)
    nprimi = nprimit(i1)
    nprimj = nprimit(i2)
    i1ini = ipntprim(i1)
    i2ini = ipntprim(i2)
    if (i1ini .le. 0 .or. i2ini .le. 0) return
    i1fin = ipntprim(i1)+nprimi-1
    i2fin = ipntprim(i2)+nprimj-1
    lmax = lmaxexp + la
    R2 = R*R
    Rpw(0) = uno
    do l = 1, lmax+lb
        Rpw(l) = Rpw(l-1) * R
    enddo
    sint = cero
    nmax = max(2,lmax/2)
    do i2p = i2ini, i2fin
        do i1p = i1ini, i1fin
            if (xxg(i1p) .lt. xxg(i2p)) cycle
            dux = cfcontr(i2p) * cfcontr(i1p)
            if (xxg(i1p) .eq. xxg(i2p)) dux = umed * dux
            z = (xxg(i1p)+xxg(i2p)) / xxg(i1p)
            w = -xxg(i2p)*xxg(i2p)*R2 / (xxg(i1p)+xxg(i2p))
            if (xxg(i1p)*xxg(i2p)*R2 / (xxg(i1p)+xxg(i2p)) .gt. 200.d0) cycle
            h2f1(:,:,-nmax:-1) = cero
            h2f1(:,:,0) = uno

            do n = -1, -nmax, -1	! Downwards recursion with eq 9.137.8 of Gradshteyn and Ryzhik
                do j = 0, lmax+nmax+n
                    do i = -lb, nmax+n
                        h2f1(i,j,n) = ((n-j-umed) * h2f1(i,j,n+1) + i * (uno-z) * h2f1(i+1,j+1,n+1) ) / (n+i-j-umed)
                    enddo
                enddo
            enddo
            phi(0) = uno
            phi(-1) = uno - umed * w
            do i = -1, -nmax+2, -1
                phi(i-1) = (i * phi(i+1) - (w + i+i -2) * phi(i)) / (dos-i)
            enddo
            xikv(0) = uno
            do l = 1, lb
                xikv(l) = -umed * xikv(l-1) * (xxg(i1p)+xxg(i2p)) / (xxg(i1p)*xxg(i2p))
            enddo
            xiabinv = uno / (xxg(i1p)+xxg(i2p))
            aux = (-xxg(i1p))**lb * sqrt(pi)**3 * exp(-xxg(i1p)*xxg(i2p)*R2*xiabinv) * sqrt(xiabinv)**(lb+lb+3)
            do l = 0, lmax
                maxl = max(l, lb)
                minl = min(l, lb)
                knt = ipntpolP(maxl,minl)
                do mb = 0, min(l,lb)
                    bux = aux
                    do n = 0, (lmax-mb)/2
                        sumk = cero
                        do k = mb, min(l,lb)
                            sump = cero
                            do ip = 1, n
                                sump = sump + fact(n) * facts(n+l+lb-k-ip) * facti(n-ip) * factsi(l+lb-k) &
                                        * phi(-ip+1) * h2f1(-lb+k,l,-n+ip)
                            enddo
                            sump = -w * sump + facts(n+l+lb-k) * factsi(l+lb-k) * h2f1(-lb+k,l,-n)
                            sumk = sumk + Rpw(l+lb-k-k) * xikv(k) * polP(knt+k-mb) * sump
                        enddo
                        sint(n, l*(l+1)+mb+1, mb) = sint(n, l*(l+1)+mb+1, mb) + bux * dux * sumk
                        bux = bux * xiabinv
                    enddo
                    knt = knt + minl - mb + 1
                enddo
                aux = aux * xxg(i2p) * xiabinv
            enddo
        enddo
    enddo
    do l = 0, lmax
        do mb = 1, min(l,lb)
            do n = 0, (lmax-mb)/2
                sint(n, l*(l+1)-mb+1, mb) = sint(n, l*(l+1)+mb+1, mb)
            enddo
        enddo
    enddo

    do ma = -la, la
        lma = la*(la+1)+ma+1
        do l = 0, lmaxexp
            do m = -min(l,la+lb), min(l,la+lb)
                aux = fact(l-abs(m)) * facti(l+abs(m))
                if (m .ne. 0) aux = aux + aux
                lm = l*(l+1)+m+1
                do ip = i1l1l2(lm,lma), i2l1l2(lm,lma)
                    if (abs(mlm(lml1l2(ip))) .le. lb) qlm2c(lm) = qlm2c(lm) + roblk(ma,mlm(lml1l2(ip))) * ccl1l2(ip) &
                            * sint(npl1l2(ip), lml1l2(ip), abs(mlm(lml1l2(ip)))) * aux
                enddo
            enddo
        enddo
    enddo
    return
    end
!
!	********************************************************
!
!	Subroutine for computing molecular multipolar moments from the multipolar moments of the &
!	 fragments. Generated with trasladamultipolos2.nb with the procedure described in the &
!	 libro de electrostatica.
!
  subroutine multmolec(qlm, qlmnuc)
    USE DAM320_D
    USE DAM320_DATA_D, zn_orig => zn
    USE DAM320_CONST_D
    implicit none
    real(KREAL) :: rab2, xab, yab, zab
    integer(KINT) :: i, ia, ierr, l, m
    real(KREAL) :: qlm((mxmult+1)**2), qlmnuc((mxmult+1)**2)
    real(KREAL) :: zlm(0:mxmult,-mxmult:mxmult)
    real(KREAL), allocatable :: zn(:)
    allocate(zn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating zn in multmolec. Stop')
    if (lvalence) then
        do i = 1, ncen
            zn(i) = atom_core(zn_orig(i))
        enddo
    else
        zn = zn_orig
    endif
    qlm = cero
    qlmnuc = cero
    do ia = 1, ncen
        xab = rcen(1,ia)
        yab = rcen(2,ia)
        zab = rcen(3,ia)
        rab2 = xab*xab+yab*yab+zab*zab
        zlm(0,0) = uno
        zlm(1,-1) = yab
        zlm(1,0) = zab
        zlm(1,1) = xab
        do l = 1, mxmult-1
            zlm(l+1,l+1) = dosl1(l)*(xab*zlm(l,l)-yab*zlm(l,-l))
            zlm(l+1,-(l+1)) = dosl1(l)*(yab*zlm(l,l)+xab*zlm(l,-l))
            zlm(l+1,l) = dosl1(l)*zab*zlm(l,l)
            zlm(l+1,-l) = dosl1(l)*zab*zlm(l,-l)
            do m = 0, l-1
                zlm(l+1,m)=(dosl1(l)*zab*zlm(l,m)-re(l+m)*rab2*zlm(l-1,m))*ri(l-m+1)
                zlm(l+1,-m)=(dosl1(l)*zab*zlm(l,-m)-re(l+m)*rab2*zlm(l-1,-m))*ri(l-m+1)
            enddo
        enddo
!	Contribution of the nuclear charge of center ia to the multipoles
        qlmnuc(1) = qlmnuc(1) + zn(ia)
        qlmnuc(2) = qlmnuc(2) + zlm(1,-1)*zn(ia)
        qlmnuc(3) = qlmnuc(3) + zlm(1,0)*zn(ia)
        qlmnuc(4) = qlmnuc(4) + zlm(1,1)*zn(ia)
        qlmnuc(5) = qlmnuc(5) + 0.0833333333333333D0*zlm(2,-2)*zn(ia)
        qlmnuc(6) = qlmnuc(6) + 0.3333333333333333D0*zlm(2,-1)*zn(ia)
        qlmnuc(7) = qlmnuc(7) + zlm(2,0)*zn(ia)
        qlmnuc(8) = qlmnuc(8) + 0.3333333333333333D0*zlm(2,1)*zn(ia)
        qlmnuc(9) = qlmnuc(9) + 0.0833333333333333D0*zlm(2,2)*zn(ia)
        qlmnuc(10) = qlmnuc(10) + 0.0027777777777778D0*zlm(3,-3)*zn(ia)
        qlmnuc(11) = qlmnuc(11) + 0.0166666666666667D0*zlm(3,-2)*zn(ia)
        qlmnuc(12) = qlmnuc(12) + 0.1666666666666667D0*zlm(3,-1)*zn(ia)
        qlmnuc(13) = qlmnuc(13) + zlm(3,0)*zn(ia)
        qlmnuc(14) = qlmnuc(14) + 0.1666666666666667D0*zlm(3,1)*zn(ia)
        qlmnuc(15) = qlmnuc(15) + 0.0166666666666667D0*zlm(3,2)*zn(ia)
        qlmnuc(16) = qlmnuc(16) + 0.0027777777777778D0*zlm(3,3)*zn(ia)
        qlmnuc(17) = qlmnuc(17) + 0.0000496031746032D0*zlm(4,-4)*zn(ia)
        qlmnuc(18) = qlmnuc(18) + 0.0003968253968254D0*zlm(4,-3)*zn(ia)
        qlmnuc(19) = qlmnuc(19) + 0.0055555555555556D0*zlm(4,-2)*zn(ia)
        qlmnuc(20) = qlmnuc(20) + 0.1000000000000000D0*zlm(4,-1)*zn(ia)
        qlmnuc(21) = qlmnuc(21) + zlm(4,0)*zn(ia)
        qlmnuc(22) = qlmnuc(22) + 0.1000000000000000D0*zlm(4,1)*zn(ia)
        qlmnuc(23) = qlmnuc(23) + 0.0055555555555556D0*zlm(4,2)*zn(ia)
        qlmnuc(24) = qlmnuc(24) + 0.0003968253968254D0*zlm(4,3)*zn(ia)
        qlmnuc(25) = qlmnuc(25) + 0.0000496031746032D0*zlm(4,4)*zn(ia)
        if (ngini(ia) .le. 0) cycle	! If center without associated basis set, cycles
!	Contribution of the electronic fragments to the multipoles
        qlm(1) = qlm(1) - rmultip(1,ia)
        qlm(2) = qlm(2) - (zlm(1,-1)*rmultip(1,ia)+rmultip(2,ia))
        qlm(3) = qlm(3) - (zlm(1,0)*rmultip(1,ia)+rmultip(3,ia))
        qlm(4) = qlm(4) - (zlm(1,1)*rmultip(1,ia)+rmultip(4,ia))
        qlm(5) = qlm(5) - (0.0833333333333333D0*zlm(2,-2)*rmultip(1,ia)+0.5000000000000000D0*zlm(1,1) &
                *rmultip(2,ia)+0.5000000000000000D0*zlm(1,-1)*rmultip(4,ia)+rmultip(5,ia))
        qlm(6) = qlm(6) - (0.3333333333333333D0*zlm(2,-1)*rmultip(1,ia)+zlm(1,0)*rmultip(2,ia)+zlm(1,-1) &
                *rmultip(3,ia)+rmultip(6,ia))
        qlm(7) = qlm(7) - (zlm(2,0)*rmultip(1,ia)-1.0000000000000000D0*zlm(1,-1)*rmultip(2,ia) &
                +2.0000000000000000D0*zlm(1,0)*rmultip(3,ia)-1.0000000000000000D0*zlm(1,1)*rmultip(4,ia) &
                +rmultip(7,ia))
        qlm(8) = qlm(8) - (0.3333333333333333D0*zlm(2,1)*rmultip(1,ia)+zlm(1,1)*rmultip(3,ia)+zlm(1,0) &
                *rmultip(4,ia)+rmultip(8,ia))
        qlm(9) = qlm(9) - (0.0833333333333333D0*zlm(2,2)*rmultip(1,ia)-0.5000000000000000D0*zlm(1,-1) &
                *rmultip(2,ia)+0.5000000000000000D0*zlm(1,1)*rmultip(4,ia)+rmultip(9,ia))
        qlm(10) = qlm(10) - (0.0027777777777778D0*zlm(3,-3)*rmultip(1,ia)+0.0416666666666667D0*zlm(2,2) &
                *rmultip(2,ia)+0.0416666666666667D0*zlm(2,-2)*rmultip(4,ia)+0.5000000000000000D0*zlm(1,1) &
                *rmultip(5,ia)+0.5000000000000000D0*zlm(1,-1)*rmultip(9,ia)+rmultip(10,ia))
        qlm(11) = qlm(11) - (0.0166666666666667D0*zlm(3,-2)*rmultip(1,ia)+0.1666666666666667D0*zlm(2,1) &
                *rmultip(2,ia)+0.0833333333333333D0*zlm(2,-2)*rmultip(3,ia)+0.1666666666666667D0*zlm(2,-1) &
                *rmultip(4,ia)+zlm(1,0)*rmultip(5,ia)+0.5000000000000000D0*zlm(1,1)*rmultip(6,ia) &
                +0.5000000000000000D0*zlm(1,-1)*rmultip(8,ia)+rmultip(11,ia))
        qlm(12) = qlm(12) - (0.1666666666666667D0*zlm(3,-1)*rmultip(1,ia)+(zlm(2,0)+0.0833333333333333D0 &
                *zlm(2,2))*rmultip(2,ia)+0.6666666666666666D0*zlm(2,-1)*rmultip(3,ia)-0.0833333333333333D0 &
                *zlm(2,-2)*rmultip(4,ia)-1.0000000000000000D0*zlm(1,1)*rmultip(5,ia)+2.0000000000000000D0 &
                *zlm(1,0)*rmultip(6,ia)+zlm(1,-1)*rmultip(7,ia)+zlm(1,-1)*rmultip(9,ia)+rmultip(12,ia))
        qlm(13) = qlm(13) - (zlm(3,0)*rmultip(1,ia)-1.0000000000000000D0*zlm(2,-1)*rmultip(2,ia) &
                +3.0000000000000000D0*zlm(2,0)*rmultip(3,ia)-1.0000000000000000D0*zlm(2,1) &
                *rmultip(4,ia)-3.0000000000000000D0*zlm(1,-1)*rmultip(6,ia)+3.0000000000000000D0*zlm(1,0) &
                *rmultip(7,ia)-3.0000000000000000D0*zlm(1,1)*rmultip(8,ia)+rmultip(13,ia))
        qlm(14) = qlm(14) - (0.1666666666666667D0*zlm(3,1)*rmultip(1,ia)-0.0833333333333333D0*zlm(2,-2) &
                *rmultip(2,ia)+0.6666666666666666D0*zlm(2,1)*rmultip(3,ia)+(zlm(2,0)-0.0833333333333333D0 &
                *zlm(2,2))*rmultip(4,ia)-1.0000000000000000D0*zlm(1,-1)*rmultip(5,ia)+zlm(1,1)*rmultip(7,ia) &
                +2.0000000000000000D0*zlm(1,0)*rmultip(8,ia)-1.0000000000000000D0*zlm(1,1)*rmultip(9,ia) &
                +rmultip(14,ia))
        qlm(15) = qlm(15) - (0.0166666666666667D0*zlm(3,2)*rmultip(1,ia)-0.1666666666666667D0*zlm(2,-1) &
                *rmultip(2,ia)+0.0833333333333333D0*zlm(2,2)*rmultip(3,ia)+0.1666666666666667D0*zlm(2,1) &
                *rmultip(4,ia)-0.5000000000000000D0*zlm(1,-1)*rmultip(6,ia)+0.5000000000000000D0*zlm(1,1) &
                *rmultip(8,ia)+zlm(1,0)*rmultip(9,ia)+rmultip(15,ia))
        qlm(16) = qlm(16) - (0.0027777777777778D0*zlm(3,3)*rmultip(1,ia)-0.0416666666666667D0*zlm(2,-2) &
                *rmultip(2,ia)+0.0416666666666667D0*zlm(2,2)*rmultip(4,ia)-0.5000000000000000D0*zlm(1,-1) &
                *rmultip(5,ia)+0.5000000000000000D0*zlm(1,1)*rmultip(9,ia)+rmultip(16,ia))
        qlm(17) = qlm(17) - (0.0000496031746032D0*zlm(4,-4)*rmultip(1,ia)+0.0013888888888889D0*zlm(3,3) &
                *rmultip(2,ia)+0.0013888888888889D0*zlm(3,-3)*rmultip(4,ia)+0.0416666666666667D0*zlm(2,2) &
                *rmultip(5,ia)+0.0416666666666667D0*zlm(2,-2)*rmultip(9,ia)+0.5000000000000000D0*zlm(1,1) &
                *rmultip(10,ia)+0.5000000000000000D0*zlm(1,-1)*rmultip(16,ia)+rmultip(17,ia))
        qlm(18) = qlm(18) - (0.0003968253968254D0*zlm(4,-3)*rmultip(1,ia)+0.0083333333333333D0*zlm(3,2) &
                *rmultip(2,ia)+0.0027777777777778D0*zlm(3,-3)*rmultip(3,ia)+0.0083333333333333D0*zlm(3,-2) &
                *rmultip(4,ia)+0.1666666666666667D0*zlm(2,1)*rmultip(5,ia)+0.0416666666666667D0*zlm(2,2) &
                *rmultip(6,ia)+0.0416666666666667D0*zlm(2,-2)*rmultip(8,ia)+0.1666666666666667D0*zlm(2,-1) &
                *rmultip(9,ia)+zlm(1,0)*rmultip(10,ia)+0.5000000000000000D0*zlm(1,1)*rmultip(11,ia) &
                +0.5000000000000000D0*zlm(1,-1)*rmultip(15,ia)+rmultip(18,ia))
        qlm(19) = qlm(19) - (0.0055555555555556D0*zlm(4,-2)*rmultip(1,ia)+(0.0833333333333333D0*zlm(3,1) &
                +0.0027777777777778D0*zlm(3,3))*rmultip(2,ia)+0.0333333333333333D0*zlm(3,-2)*rmultip(3,ia) &
                +(0.0833333333333333D0*zlm(3,-1)-0.0027777777777778D0*zlm(3,-3))*rmultip(4,ia)+zlm(2,0) &
                *rmultip(5,ia)+0.3333333333333333D0*zlm(2,1)*rmultip(6,ia)+0.0833333333333333D0*zlm(2,-2) &
                *rmultip(7,ia)+0.3333333333333333D0*zlm(2,-1)*rmultip(8,ia)-1.0000000000000000D0*zlm(1,1) &
                *rmultip(10,ia)+2.0000000000000000D0*zlm(1,0)*rmultip(11,ia)+0.5000000000000000D0*zlm(1,1) &
                *rmultip(12,ia)+0.5000000000000000D0*zlm(1,-1)*rmultip(14,ia)+zlm(1,-1)*rmultip(16,ia) &
                +rmultip(19,ia))
        qlm(20) = qlm(20) - (0.1000000000000000D0*zlm(4,-1)*rmultip(1,ia)+(zlm(3,0)+0.0500000000000000D0 &
                *zlm(3,2))*rmultip(2,ia)+0.5000000000000000D0*zlm(3,-1)*rmultip(3,ia)-0.0500000000000000D0 &
                *zlm(3,-2)*rmultip(4,ia)-1.0000000000000000D0*zlm(2,1)*rmultip(5,ia)+(3.0000000000000000D0 &
                *zlm(2,0)+0.2500000000000000D0*zlm(2,2))*rmultip(6,ia)+zlm(2,-1) &
                *rmultip(7,ia)-0.2500000000000000D0*zlm(2,-2)*rmultip(8,ia)+zlm(2,-1) &
                *rmultip(9,ia)-3.0000000000000000D0*zlm(1,1)*rmultip(11,ia)+3.0000000000000000D0*zlm(1,0) &
                *rmultip(12,ia)+zlm(1,-1)*rmultip(13,ia)+3.0000000000000000D0*zlm(1,-1)*rmultip(15,ia) &
                +rmultip(20,ia))
        qlm(21) = qlm(21) - (zlm(4,0)*rmultip(1,ia)-1.0000000000000000D0*zlm(3,-1)*rmultip(2,ia) &
                +4.0000000000000000D0*zlm(3,0)*rmultip(3,ia)-1.0000000000000000D0*zlm(3,1)*rmultip(4,ia) &
                +zlm(2,-2)*rmultip(5,ia)-4.0000000000000000D0*zlm(2,-1)*rmultip(6,ia)+6.0000000000000000D0 &
                *zlm(2,0)*rmultip(7,ia)-4.0000000000000000D0*zlm(2,1)*rmultip(8,ia)+zlm(2,2) &
                *rmultip(9,ia)-6.0000000000000000D0*zlm(1,-1)*rmultip(12,ia)+4.0000000000000000D0*zlm(1,0) &
                *rmultip(13,ia)-6.0000000000000000D0*zlm(1,1)*rmultip(14,ia)+rmultip(21,ia))
        qlm(22) = qlm(22) - (0.1000000000000000D0*zlm(4,1)*rmultip(1,ia)-0.0500000000000000D0*zlm(3,-2) &
                *rmultip(2,ia)+0.5000000000000000D0*zlm(3,1)*rmultip(3,ia)+(zlm(3,0)-0.0500000000000000D0 &
                *zlm(3,2))*rmultip(4,ia)-1.0000000000000000D0*zlm(2,-1)*rmultip(5,ia)-0.2500000000000000D0 &
                *zlm(2,-2)*rmultip(6,ia)+zlm(2,1)*rmultip(7,ia)+(3.0000000000000000D0 &
                *zlm(2,0)-0.2500000000000000D0*zlm(2,2))*rmultip(8,ia)-1.0000000000000000D0*zlm(2,1) &
                *rmultip(9,ia)-3.0000000000000000D0*zlm(1,-1)*rmultip(11,ia)+zlm(1,1)*rmultip(13,ia) &
                +3.0000000000000000D0*zlm(1,0)*rmultip(14,ia)-3.0000000000000000D0*zlm(1,1)*rmultip(15,ia) &
                +rmultip(22,ia))
        qlm(23) = qlm(23) - (0.0055555555555556D0*zlm(4,2)*rmultip(1,ia)+(-0.0833333333333333D0 &
                *zlm(3,-1)-0.0027777777777778D0*zlm(3,-3))*rmultip(2,ia)+0.0333333333333333D0*zlm(3,2) &
                *rmultip(3,ia)+(0.0833333333333333D0*zlm(3,1)-0.0027777777777778D0*zlm(3,3)) &
                *rmultip(4,ia)-0.3333333333333333D0*zlm(2,-1)*rmultip(6,ia)+0.0833333333333333D0*zlm(2,2) &
                *rmultip(7,ia)+0.3333333333333333D0*zlm(2,1)*rmultip(8,ia)+zlm(2,0) &
                *rmultip(9,ia)-1.0000000000000000D0*zlm(1,-1)*rmultip(10,ia)-0.5000000000000000D0*zlm(1,-1) &
                *rmultip(12,ia)+0.5000000000000000D0*zlm(1,1)*rmultip(14,ia)+2.0000000000000000D0*zlm(1,0) &
                *rmultip(15,ia)-1.0000000000000000D0*zlm(1,1)*rmultip(16,ia)+rmultip(23,ia))
        qlm(24) = qlm(24) - (0.0003968253968254D0*zlm(4,3)*rmultip(1,ia)-0.0083333333333333D0*zlm(3,-2) &
                *rmultip(2,ia)+0.0027777777777778D0*zlm(3,3)*rmultip(3,ia)+0.0083333333333333D0*zlm(3,2) &
                *rmultip(4,ia)-0.1666666666666667D0*zlm(2,-1)*rmultip(5,ia)-0.0416666666666667D0*zlm(2,-2) &
                *rmultip(6,ia)+0.0416666666666667D0*zlm(2,2)*rmultip(8,ia)+0.1666666666666667D0*zlm(2,1) &
                *rmultip(9,ia)-0.5000000000000000D0*zlm(1,-1)*rmultip(11,ia)+0.5000000000000000D0*zlm(1,1) &
                *rmultip(15,ia)+zlm(1,0)*rmultip(16,ia)+rmultip(24,ia))
        qlm(25) = qlm(25) - (0.0000496031746032D0*zlm(4,4)*rmultip(1,ia)-0.0013888888888889D0*zlm(3,-3) &
                *rmultip(2,ia)+0.0013888888888889D0*zlm(3,3)*rmultip(4,ia)-0.0416666666666667D0*zlm(2,-2) &
                *rmultip(5,ia)+0.0416666666666667D0*zlm(2,2)*rmultip(9,ia)-0.5000000000000000D0*zlm(1,-1) &
                *rmultip(10,ia)+0.5000000000000000D0*zlm(1,1)*rmultip(16,ia)+rmultip(25,ia))
    enddo
    return
    end
!**********************************************************************
!    subroutine consta1
!
!	Computes and stores auxiliary constants
!		re(i) = dfloat(i)
!		r1(i) = 1.d0 / dfloat(i)
!		fact(i) = dfloat(i!)
!		facti(i) = 1.d0 / dfloat(i!)
!		facts(i) = dfloat((i+1/2)!)
!
!**********************************************************************
  subroutine consta1
    USE MPI
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE GAUSS
    USE PARALELO
    implicit none
    integer(KINT) :: i, ierr, ikt, j, k, k1, k12, knt, l, l1, l1l1, l2, l2l2, la, lb, lm, lmtot
    integer(KINT) :: m, m1, m1a, m2, m2a, ma, mb, md, ms, n
    real(KREAL) :: aux, sd, sgn, ss
!	auxiliary parameters and functions
    pi = acos(-uno)
    raizpi = sqrt(pi)
    re(0) = cero
    ri(0) = 1.d300
    dosl1(0) = uno
    dosl1i(0) = uno
    do i = 1, mxreal
        re(i) = re(i-1) + uno        ! dfloat(i)
        re(-i) = -re(i)
        ri(i) = uno / re(i)       	! uno / dfloat(i)
        ri(-i) = -ri(i)
        dosl1(i) = re(i) + re(i) + uno	! dfloat(iì)
        dosl1(-i) = -re(i) - re(i) + uno
        dosl1i(i) = uno / dosl1(i)		! dfloat( 1/(i+i+1) )
        dosl1i(-i) = uno / dosl1(-i)
    enddo
    fact(0) = uno
    facti(0) = uno
    facts(-1) = raizpi
    facts(0) = facts(-1) * umed
    factsi(-1) = uno / facts(-1)	! factsi in module GAUSS
    factsi(0) = uno / facts(0)
    do i = 1, mxfact
        fact(i) = fact(i-1) * re(i)   			!  i!
        facts(i) = facts(i-1) * re(i+i+1) * umed	! (i+1/2)!
        facti(i) = uno / fact(i)     				!  uno / i!
        factsi(i) = uno / facts(i)				!  uno / (i+1/2)!
    enddo
    return
    end
!**********************************************************************
!    subroutine consta2
!
!	Computes and stores auxiliary constants
!		ind(i) = i*(i+1)/2
!		root(i) = dfloat(sqrt(i))
!		rooti(i) = 1.d0 / dfloat(sqrt(i))
!		bin(l*(l+1)/2+m+1) = Binomial(l,m)
!    	ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m)
!			/ (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
!
!       and many other
!
!**********************************************************************
  subroutine consta2
    USE MPI
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE GAUSS
    USE PARALELO
    implicit none
    integer(KINT) :: i, ierr, ikt, j, k, k1, k12, knt, l, l1, l1l1, l2, l2l2, la, lb, lm, lmtot
    integer(KINT) :: m, m1, m1a, m2, m2a, ma, mb, md, ms, n
    real(KREAL) :: aux, sd, sgn, ss
!	auxiliary parameters and functions
    mxind = (mxltot+1)*(mxltot+2)/2
    mxbin = max(mxltot,mxlenpol)
    allocate(umedpow(0:lmaxexp), ind(0:mxind), bin((mxbin+1)*(mxbin+2)/2), ang((lmaxexp+1)*(lmaxexp+2)/2), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating umedpow, ind, bin and angl in processor ',i8)") myrank
        abort = 1
        return
    endif
    umedpow(0) = uno							!
    do i = 1, lmaxexp							!
        umedpow(i) = umedpow(i-1) * umed			! 1 / 2^i
    enddo
    ind(0) = 0
    do i = 1, mxind
        ind(i) = ind(i-1) + i         !  i*(i+1)/2
    enddo
    root(0) = cero
    do i = 1, mxroot
        root(i) = sqrt(re(i))        !  sqrt(i)
        rooti(i) = uno / root(i)     !  uno / sqrt(i)
    enddo
    lm = 0
    do l = 0, mxbin
        do m = 0, l
            lm = lm + 1
            bin(lm) = fact(l) * facti(m) * facti(l-m)
        end do
    end do
!    ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m) / (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
    ang(1) = umed / raizpi
    lm = 1
    do l = 1, lmaxexp
        lm = lm + 1
        ang(lm) = ang(1) * sqrt(re(2*l+1))
        aux = ang(lm) * raiz2
        do m = 1, l
            lm = lm + 1
            aux = aux / sqrt(re(l-m+1)*re(l+m))
            ang(lm) = aux
        enddo
    enddo
!     Tabulates the coefficients for the decomposition of products
!     of two functions depending on phi (sin (m*phi), cos (m*phi))
!     into functions of the same type
    mxemes = mxltot
    allocate(ssv(-mxemes:mxemes,-mxemes:mxemes), sdv(-mxemes:mxemes,-mxemes:mxemes), &
            msv(-mxemes:mxemes,-mxemes:mxemes), mdv(-mxemes:mxemes,-mxemes:mxemes), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating ssv, sdv, msv and mdv in processor ',i8)") myrank
        abort = 1
        return
    endif
    do m2 = -mxemes, mxemes
        do m1 = -mxemes, mxemes
            call emes ( m1, m2, ms, md, ss, sd )
            msv(m1,m2) = ms
            mdv(m1,m2) = md
            ssv(m1,m2) = ss
            sdv(m1,m2) = sd
        enddo
    enddo
!	Coefficients for the decomposition of products of regular spherical harmonics into
!	regular spherical harmonics
    mxlcof = mxltot*(mxltot+3)/2
    mxkcof = mxlcof*(mxlcof+3)/2
    allocate(app(0:2*mxltot+1,0:mxkcof), bpp(0:2*mxltot+1,0:mxkcof), stat = ierr)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when allocating app, bbb.')")
        abort = 1
        return
    endif
    if (myrank .eq. 0 .and. longoutput) then
        write(6,"('Size of app   = ', i15, ' bytes')") size(app)
        write(6,"('Size of bpp   = ', i15, ' bytes')") size(bpp)
    endif
    call acof
    call bcof
!	Tabulates some auxiliary indices for locating the previous coefficients
    allocate(indk12((mxltot+1)**2,(mxltot+1)**2), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating indk12 in processor ',i8)") myrank
        abort = 1
        return
    endif
    do l2 = 0,mxltot
        do l1 = 0,mxltot
            do m2 = -l2, l2
                do m1 = -l1, l1
                    l1l1 = ind(l1)
                    l2l2 = ind(l2)
                    m1a = abs(m1)
                    m2a = abs(m2)
                    if ( l1.eq.l2 ) then
                        k1 = l1l1 + max(m1a,m2a)
                        k12 = ind(k1) + l1l1 + min(m1a,m2a)
                    elseif (l1.gt.l2) then
                        k1 = l1l1 + m1a
                        k12 = ind(k1) + l2l2 + m2a
                    else
                        k1 = l2l2 + m2a
                        k12 = ind(k1) + l1l1 + m1a
                    endif
                    indk12(l1*(l1+1)+m1+1,l2*(l2+1)+m2+1) = k12
                end do
            end do
        end do
    end do

!	Polynomials P_k^(L,M;L',M')(0,0,1) of the shift-operators technique in the alligned-axes system

    n = (mxl+1) * (mxl+2) * (mxl+3) * (mxl+4) / 24 + lmaxexp * (mxl+1) * (mxl+2) * (mxl+3) / 6
    allocate(ipntpolP(0:mxl+lmaxexp,0:mxl), polP(n), stat = ierr)	! Pointers to the elements P_0^(L,0;L',0)
    if (ierr .ne. 0)  then
        write(6,"('Memory error when allocating ipntpolP and polP.')")
        abort = 1
        return
    endif
    if (myrank .eq. 0 .and. longoutput) then
        write(6,"('Size of ipntpolP   = ', i15, ' bytes')") size(ipntpolP)
        write(6,"('Size of polP   = ', i15, ' bytes')") size(polP)
    endif

    call subpolP001(mxl+lmaxexp, mxl)
!
!	Arrays  i1l1l2, i2l1l2, lml1l2, npl1l2, llm, mlm, ccl1l2
!	corresponding to the decomposition of the product of two solid spherical harmonics placed in the same center 
!	in terms of spherical harmonics placed at the same center.
!	The meaning of the indices is as follows. 
!	The decomposition of the product is:
!
!		z_l^m(r_A) * z_lp^mp(r_A) = sum_la sum_mu  c_{la,mu}^{l,m;lp,mp} * r_A^(2*la) * z_{l+lp-2*la}^{mu}(r_A)
!
!	the summation on la runs over:	0 <= la <= min(l,lp,(l+lp-|mu|)/2
!	the summation on mu contains two terms at most
!	the values of la and mu, and the corresponding coefficients c_{la,mu}^{l,m;lp,mp} on the r.h.s. are sequentially 
!	stored in arrays:  npl1l2 (for la), mlm (for mu), ccl1l2 (for c_{la,mu}^{l,m;lp,mp}).
!	Besides them, some related indices are stored:  	
!		llm(lm) --> extractsthe value of  l  corresponding to an index lm, 
!		mlm(lm) --> extractsthe value of  m  corresponding to an index lm,  
!		(l+lp-2*la) * (l+lp-2*la+1) + mu + 1 --> lml1l2   (i.e., the contracted index for the indices in the harmonic on the r.h.s.)
!	The arrays i1l1l2, and i2l1l1 contain the positions in the arrays at which
!	the values of la, mu, c_{la,mu}^{l,m;lp,mp}... corresponding to {l,m;lp,mp} start and end
!	The pairs of indices {l,m} are contracted to a single one as:  lm = l*(l+1)+m+1.
!	Therefore, the values of la, mu, c_{la,mu}^{l,m;lp,mp}... corresponding to {l,m;lp,mp} start at
!		i1l1l2(l*(l+1)+m+1,lp*(lp+1)+mp+1)  and end at  i2l1l2(l*(l+1)+m+1,lp*(lp+1)+mp+1)
!	 
!	The next loop block determines the size of the arrays
!
    ikt = 0
    do la = 0, mxltot
        do lb = 0, mxltot
            do ma = -la, la
                do mb = -lb, lb
                    ms = msv(ma,mb)
                    md = mdv(ma,mb)
                    ss = ssv(ma,mb)
                    sd = sdv(ma,mb)
                    if (ss .ne. cero) then
                        do l = la+lb, max(abs(la-lb),abs(ms)), -2
                            ikt = ikt+1
                        enddo
                    endif
                    if (sd .ne. cero) then
                        do l = la+lb, max(abs(la-lb),abs(md)), -2
                            ikt = ikt+1
                        enddo
                    endif
                enddo
            enddo
        enddo
    enddo
    idimlml1l2 = ikt
!	allocates memory for arrays llm, mlm, i1l1l2, i2l1l2, lml1l2, npl1l2, ccl1l2
    lmtot = (2*mxltot+1)*(2*mxltot+1)
    allocate(llm(lmtot), mlm(lmtot), i1l1l2(lmtot,lmtot), i2l1l2(lmtot,lmtot), lml1l2(idimlml1l2), &
            npl1l2(idimlml1l2), ccl1l2(idimlml1l2), stat = ierr)
    if (ierr .ne. 0)  then
            write(6,"('Memory error when allocating llm, mlm, i1l1l2, i2l1l2, lml1l2, npl1l2, ccl1l2.')")
            abort = 1
            return
    endif
    if (myrank .eq. 0 .and. longoutput) then
        write(6,"('Size of llm   = ', i15, ' bytes')") size(llm)
        write(6,"('Size of mlm   = ', i15, ' bytes')") size(mlm)
        write(6,"('Size of i1l1l2   = ', i15, ' bytes')") size(i1l1l2)
        write(6,"('Size of i2l1l2   = ', i15, ' bytes')") size(i2l1l2)
        write(6,"('Size of lml1l2   = ', i15, ' bytes')") size(lml1l2)
        write(6,"('Size of npl1l2   = ', i15, ' bytes')") size(npl1l2)
        write(6,"('Size of ccl1l2   = ', i15, ' bytes')") size(ccl1l2)
    endif
!	Computes and stores  arrays llm, mlm, i1l1l2, i2l1l2, lml1l2, npl1l2, ccl1l2
    lm = 0
    do l = 0, 2*mxltot
        do m = -l, l
            lm = lm + 1
            llm(lm) = l
            mlm(lm) = m
        enddo
    enddo
    ikt = 0
    do la = 0, mxltot
        do lb = 0, mxltot
            do ma = -la, la
                do mb = -lb, lb
                    i1l1l2(la*(la+1)+ma+1, lb*(lb+1)+mb+1) = ikt + 1
                    k12 = indk12(la*(la+1)+ma+1,lb*(lb+1)+mb+1)
                    ms = msv(ma,mb)
                    md = mdv(ma,mb)
                    ss = ssv(ma,mb)
                    sd = sdv(ma,mb)
                    if (ms .ge. md) then
                        do l = abs(la-lb), la+lb, 2
                            if (l .ge. abs(md) .and. sd .ne. cero .and. abs(bpp(l,k12)) .gt. 1.d-13) then
                                ikt = ikt+1
                                lml1l2(ikt) = l*(l+1) + md + 1
                                ccl1l2(ikt) = sd * bpp(l,k12)
                                npl1l2(ikt) = (la+lb-l) / 2
                            endif
                            if (l .ge. abs(ms) .and. ss .ne. cero .and. abs(app(l,k12)) .gt. 1.d-13) then
                                ikt = ikt+1
                                lml1l2(ikt) = l*(l+1) + ms + 1
                                ccl1l2(ikt) = ss * app(l,k12)
                                npl1l2(ikt) = (la+lb-l) / 2
                            endif
                        enddo
                    else
                        do l = abs(la-lb), la+lb, 2
                            if (l .ge. abs(ms) .and. ss .ne. cero .and. abs(app(l,k12)) .gt. 1.d-13) then
                                ikt = ikt+1
                                lml1l2(ikt) = l*(l+1) + ms + 1
                                ccl1l2(ikt) = ss * app(l,k12)
                                npl1l2(ikt) = (la+lb-l) / 2
                            endif
                            if (l .ge. abs(md) .and. sd .ne. cero .and. abs(bpp(l,k12)) .gt. 1.d-13) then
                                ikt = ikt+1
                                lml1l2(ikt) = l*(l+1) + md + 1
                                ccl1l2(ikt) = sd * bpp(l,k12)
                                npl1l2(ikt) = (la+lb-l) / 2
                            endif
                        enddo
                    endif
                    i2l1l2(la*(la+1)+ma+1,lb*(lb+1)+mb+1) = ikt
                enddo
            enddo
        enddo
    enddo
!	Tabulates the coefficients of Chebyshev T polynomials in decreasing powers of the variable
    knt = 0
    do j = 0, mxlenpol-1
        sgn = uno
        do n = 0, j/2
            knt = knt + 1
            chebTcf(knt) = cero
            do k = 0, j/2-n
                chebTcf(knt) = chebTcf(knt) + bin(ind(j)+2*(n+k)+1) * bin(ind(n+k)+k+1)
            enddo
            chebTcf(knt) = sgn * chebTcf(knt)
            sgn = -sgn
        enddo
    enddo
    deallocate(app, bpp)
    return
    end
!
!   *******************************************************************
!
  subroutine acof
	USE DAM320_D
	USE DAM320_DATA_D, only: mxltot
	USE DAM320_CONST_D
	implicit none
	integer(KINT) :: k1, k2, k20, k200, kk, kk0, kk00, l, lp, m, m1, mp, n
	real(KREAL) :: aux, bux
	app = cero
!
!   starting elements app(00,lm)(n) = delta(l,n)
!
	k1 = 0
	do l = 0 , mxltot
            do m = 0 , l
                kk = ind(k1)
                app(l,kk) = uno
                k1 = k1 + 1
            enddo
	enddo
!
!   elements app(lm,m'm')(n)
!
	do mp = 1 , mxltot
            k2 = ind(mp) + mp
            k20 = ind(mp-1) + mp-1
            do l = mp , mxltot
                if ( l.eq.mp ) then
                    m1 = mp
                else
                    m1 = 0
                endif
                do m = m1 , l
                    k1 = ind(l) + m
                    kk = ind(k1) + k2
                    kk0 = ind(k1) + k20
                    do n = l-mp , l+mp , 2
                        if ( n.ge.m+mp) then
                            app(n,kk) = (2*mp-1) * ( app(n-1,kk0) * ri(n+n-1) - app(n+1,kk0) * ri(n+n+3) )
                        endif
                    enddo
                enddo
            enddo
	enddo
!
!   elements app(lm,l'm')(n)
!
	do mp = 0 , mxltot
            k200 = 0
            do lp = mp+1 , mxltot
                k2 = ind(lp) + mp
                k20 = ind(lp-1) + mp
                if ( lp.gt.mp+1 ) k200 = ind(lp-2) + mp
                do l = lp , mxltot
                    if ( l.eq.lp ) then
                        m1 = mp
                    else
                        m1 = 0
                    endif
                    do m = m1 , l
                        k1 = ind(l) + m
                        kk = ind(k1) + k2
                        kk0 = ind(k1) + k20
                        kk00 = ind(k1) + k200
                        do n = l-lp , l+lp , 2
                            if ( n.ge.m+mp) then
                                aux = app(n+1,kk0) * re(n+m+mp+1) * dosl1i(n+1)
                                if ( n.gt.m+mp ) aux = aux + app(n-1,kk0) * re(n-m-mp) * dosl1i(n-1)
                                aux = aux * dosl1(lp-1)
                                if ( lp.gt.mp+1 ) aux = aux - re(lp+mp-1) * app(n,kk00)
                                app(n,kk) = aux * ri(lp-mp)
                            endif
                        enddo
                    enddo
                enddo
            enddo
	enddo
	return
	end
!
!   *******************************************************************
!
  subroutine bcof
    USE DAM320_D
    USE DAM320_DATA_D, only: mxltot
    USE DAM320_CONST_D
    implicit none
    integer(KINT) :: k1, k2, k20, k200, kk, kk0, kk00, l, lp, m, m1, mmp, mp, n
    real(KREAL) :: aux, bux, t1, t2
    bpp = cero
!
!   starting elements bpp(lm,00)(n) = delta(l,n)
!
    k1 = 0
    do l = 0 , mxltot
        do m = 0 , l
            kk = ind(k1)
            bpp(l,kk) = uno
            k1 = k1 + 1
        enddo
    enddo
!
!   elements bpp(lm,m'm')(n)
!
    do mp = 1 , mxltot
        k2 = ind(mp) + mp
        k20 = ind(mp-1) + mp-1
        do l = mp , mxltot
            if ( l.eq.mp ) then
                m1 = mp
            else
                m1 = 0
            endif
            do m = m1 , l
                k1 = ind(l) + m
                kk = ind(k1) + k2
                kk0 = ind(k1) + k20
                do n = l-mp , l+mp , 2
                    if ( mp.gt.m ) then
                        t1 = uno
                        t2 = uno
                    else
                        t1 = -re(n-(m-mp+1)) * re(n-(m-mp+1)+1)
                        t2 = -re(n+(m-mp+1)) * re(n+(m-mp+1)+1)
                    endif
                    if ( n.ge.abs(m-mp)) then
                        if (n.eq.0) then
                            bux=cero
                        else
                            bux=t1*bpp(n-1,kk0) * dosl1i(n-1)
                        endif
                        bpp(n,kk) = dosl1(mp-1) * ( bux - t2 * bpp(n+1,kk0) * dosl1i(n+1) )
                    endif
                enddo
            enddo
        enddo
    enddo
!
!   elements bpp(lm,l'm')(n)
!
    do mp = 0 , mxltot
        k200 = 0
        do lp = mp+1 , mxltot
            k2 = ind(lp) + mp
            k20 = ind(lp-1) + mp
            if ( lp.gt.mp+1 ) k200 = ind(lp-2) + mp
            do l = lp , mxltot
                if ( l.eq.lp ) then
                    m1 = mp
                else
                    m1 = 0
                endif
                do m = m1 , l
                    k1 = ind(l) + m
                    kk = ind(k1) + k2
                    kk0 = ind(k1) + k20
                    kk00 = ind(k1) + k200
                    do n = l-lp , l+lp , 2
                        mmp = abs(m-mp)
                        if ( n.ge.mmp) then
                            aux = bpp(n+1,kk0) * re(n+mmp+1) * dosl1i(n+1)
                            if ( n.gt.mmp ) aux = aux + bpp(n-1,kk0) * re(n-mmp) * dosl1i(n-1)
                            aux = aux * dosl1(lp-1)
                            if ( lp.gt.mp+1 ) aux = aux - re(lp+mp-1) * bpp(n,kk00)
                            bpp(n,kk) = aux * ri(lp-mp)
                        endif
                    enddo
                enddo
            enddo
        enddo
    enddo
    return
    end
!
!   ******************************************************************
!
  subroutine emes ( m1, m2, ms, md, ss, sd )
    USE DAM320_D
    USE DAM320_CONST_D, ONLY: uno, cero, umed
    implicit none
    integer(KINT) :: m1, m1a, m2, m2a, ms, md
    real(KREAL) :: s1, s2, s12, ss, sd
    s1 = sign(1,m1)
    s2 = sign(1,m2)
    s12 = s1 * s2
    m1a = iabs(m1)
    m2a = iabs(m2)
    ms = s12 * ( m1a + m2a )
    md = s12 * iabs( m1a - m2a )
    if ( ms.eq.md ) then
        ss = uno
        sd = cero
        return
    endif
    if ( m1.lt.0 .and. m2.lt.0 ) then
        ss = -umed
    else
        ss = umed
    endif
    if ( s12.gt.cero ) then
        sd = umed
    elseif ( md.eq.0 ) then
        sd = cero
    elseif ( sign(1,m1a-m2a) .eq. s1 ) then
        sd = - umed
    else
        sd = umed
    endif
    return
    end

!**********************************************************************
!
!   subroutine rotar
!
!	this subroutine yields the rotation matrices rl(m',m;l) of reals spherical harmonics
!	receives the trigonometric functions of Euler angles defining the rotation
!
!**********************************************************************
  subroutine rotar(lmax, cosal, sinal, cosbet, sinbet, cosga, singa)
    USE DAM320_D
    USE DAM320_DATA_D
    USE DAM320_CONST_D
    implicit none
    integer(KINT) :: l, lmax
    real(KREAL) :: cosag, cosal, cosamg, cosbet, cosga, sinag, sinal, sinamg, singa, sinbet, tgbet2
!	Initial matrices d0, r0, d1 and r1
    rl(:,:,:) = cero
    dl(:,:,:) = cero
    dl(0,0,0)  = uno
    rl(0,0,0)  = uno
    if(lmax.eq.0) return
    dl(1,1,1)  = (uno + cosbet) * umed
    dl(1,0,1)  =-sinbet/raiz2
    dl(1,-1,1) = (uno - cosbet) * umed
    dl(0,1,1)  =-dl(1,0,1)
    dl(0,0,1)  = dl(1,1,1)-dl(1,-1,1)
    dl(0,-1,1) = dl(1,0,1)
    dl(-1,1,1) = dl(1,-1,1)
    dl(-1,0,1) = dl(0,1,1)
    dl(-1,-1,1)= dl(1,1,1)
    cosag  = cosal * cosga - sinal * singa
    cosamg = cosal * cosga + sinal * singa
    sinag  = sinal * cosga + cosal * singa
    sinamg = sinal * cosga - cosal * singa
    rl(0,0,1)  = dl(0,0,1)
    rl(1,0,1)  = raiz2 * dl(0,1,1) * cosal
    rl(-1,0,1) = raiz2 * dl(0,1,1) * sinal
    rl(0,1,1)  = raiz2 * dl(1,0,1) * cosga
    rl(0,-1,1) =-raiz2 * dl(1,0,1) * singa
    rl(1,1,1)  = dl(1,1,1) * cosag - dl(1,-1,1) * cosamg
    rl(1,-1,1) =-dl(1,1,1) * sinag - dl(1,-1,1) * sinamg
    rl(-1,1,1) = dl(1,1,1) * sinag - dl(1,-1,1) * sinamg
    rl(-1,-1,1)= dl(1,1,1) * cosag + dl(1,-1,1) * cosamg
!	the remaining matrices are calculated using symmetry and recurrence relations by means of the subroutine dlmn.
    if ( abs(sinbet) .lt. 1.d-14 ) then
        tgbet2 = cero
    elseif ( abs(sinbet) .lt. 1.d-10 ) then
        tgbet2 = cero
        write(6,"('WARNING in ROTAR: sinbet = ', e17.10, ' takes  0')") sinbet
    else
        tgbet2 = ( uno - cosbet ) / sinbet
    endif
    do l = 2, lmax
        call dlmn(l, sinal, cosal, cosbet, tgbet2, singa, cosga)
    enddo
    return
    end
!**********************************************************************
!
!   subroutine dlmn
!
!   this subroutine generates the matrices dl(m',m;l) for a fixed value
!   of the orbital quantum number l, and it needs the dl(l-2;m',m) and 
!   dl(l-1;m',m) matrices. this subroutine uses symmetry and recurrence
!   relations. the matrices dl(m',m;l) are the rotation matrices for   
!   complex spherical harmonics
!
!**********************************************************************
  subroutine dlmn(l, sinal, cosal, cosbet, tgbet2, singa, cosga)
    USE DAM320_D
    USE DAM320_DATA_D
    USE DAM320_CONST_D
    implicit none
    integer(KINT) :: iinf, isup, l, ltot, m, mp
    real(KREAL) :: al, al1, ali, aux, cosag, cosagm, cosal, cosaux, cosbet, cosga, cosmal, cosmga, cux, d1, d2
    real(KREAL) :: sgn, sinag, sinagm, sinal, singa, sinmal, sinmga, tal1, tgbet2
    iinf=1-l
    isup=-iinf
!	computation of the dl(m',m;l) matrix, mp is m' and m is m.
!	first row by recurrence: see equations 19 and 20 of reference (6)
    dl(l,l,l) = dl(isup,isup,l-1) * (uno + cosbet) * umed
    dl(l,-l,l) = dl(isup,-isup,l-1) * (uno - cosbet) * umed
    do m = isup, iinf, -1
        dl(l,m,l) = -tgbet2 * root(l+m+1) * rooti(l-m) * dl(l,m+1,l)
    enddo
!	the rows of the upper quarter triangle of the dl(m',m;l) matrix see equation 21 of reference (6)
    al = l
    al1 = al - uno
    tal1 = al + al1
    ali = uno / al1
    cosaux = cosbet * al * al1
    do mp = l-1, 0, -1
        aux = rooti(l+mp) * rooti(l-mp) * ali
        cux = root(l+mp-1) * root(l-mp-1) * al
        do m = isup, iinf, -1
            dl(mp,m,l) = aux * rooti(l+m) * rooti(l-m) * (tal1 * (cosaux - re(m) * re(mp)) * dl(mp,m,l-1) &
                    - root(l+m-1) * root(l-m-1) * cux * dl(mp,m,l-2) )
        enddo
        iinf=iinf+1
        isup=isup-1
    enddo
!	the remaining elements of the dl(m',m;l) matrix are calculated using the corresponding symmetry relations:
!		reflection ---> ((-1)**(m-m')) dl(m,m';l) = dl(m',m;l), m'<=m
!		inversion ---> ((-1)**(m-m')) dl(-m',-m;l) = dl(m',m;l)
!	reflection
    sgn = uno
    iinf = -l
    isup = l-1
    do m = l, 1, -1
        do mp = iinf, isup
            dl(mp,m,l) = sgn * dl(m,mp,l)
            sgn = -sgn
        enddo
        iinf=iinf+1
        isup=isup-1
    enddo
!	inversion
    iinf=-l
    isup=iinf
    do m = l-1, -l, -1
        sgn = -uno
        do mp = isup, iinf,- 1
            dl(mp,m,l) = sgn * dl(-mp,-m,l)
            sgn = -sgn
        enddo
        isup=isup+1
    enddo
!	computation of the rotation matrices rl(m',m;l) for real spherical harmonics using the matrices dl(m',m;l) 
!	for complex spherical harmonics: see equations 10 to 18 of reference (6)
    rl(0,0,l) = dl(0,0,l)
    cosmal = cosal
    sinmal = sinal
    sgn = - uno
    do mp = 1, l
        cosmga = cosga
        sinmga = singa
        aux = raiz2 * dl(0,mp,l)
        rl(mp,0,l) = aux * cosmal
        rl(-mp,0,l)= aux * sinmal
        do m = 1, l
            aux = raiz2 * dl(m,0,l)
            rl(0,m,l) = aux * cosmga
            rl(0,-m,l)=-aux * sinmga
            d1 = dl(-mp,-m,l)
            d2 = sgn * dl(mp,-m,l)
            cosag = cosmal * cosmga - sinmal * sinmga
            cosagm= cosmal * cosmga + sinmal * sinmga
            sinag = sinmal * cosmga + cosmal * sinmga
            sinagm= sinmal * cosmga - cosmal * sinmga
            rl(mp,m,l)  = d1 * cosag + d2 * cosagm
            rl(mp,-m,l) =-d1 * sinag + d2 * sinagm
            rl(-mp,m,l) = d1 * sinag + d2 * sinagm
            rl(-mp,-m,l)= d1 * cosag - d2 * cosagm
            aux    = cosmga * cosga - sinmga * singa
            sinmga = sinmga * cosga + cosmga * singa
            cosmga = aux
        enddo
        sgn = - sgn
        aux    = cosmal * cosal - sinmal * sinal
        sinmal = sinmal * cosal + cosmal * sinal
        cosmal = aux
    enddo
    return
    end

!   ***************************************************************

   subroutine sort(nprim, xsort)
    USE DAM320_D
    USE GAUSS
    USE PARALELO
    implicit none
    integer(KINT) :: i, iux, j, nprim
    real(KREAL) :: aux
    integer(KINT), parameter :: mxsteps = 1000
    real(KREAL) :: xsort(*)
    logical :: lend
    do i = 1, nprim
        isort(i) = i
    enddo
    do i = 1, mxsteps
        lend = .true.
        do j = nprim, 2, -2
            if (xsort(j) .lt. xsort(j-1)) then
                aux = xsort(j)
                xsort(j) = xsort(j-1)
                xsort(j-1) = aux
                iux = isort(j)
                isort(j) = isort(j-1)
                isort(j-1) = iux
                lend = .false.
            endif
        enddo
        do j = nprim-1, 2, -2
            if (xsort(j) .lt. xsort(j-1)) then
                aux = xsort(j)
                xsort(j) = xsort(j-1)
                xsort(j-1) = aux
                iux = isort(j)
                isort(j) = isort(j-1)
                isort(j-1) = iux
                lend = .false.
            endif
        enddo
        if (lend) return
    enddo
    write(6,"('Error in subroutine sort. Highest number of steps (',i4,') exceeded')") mxsteps
    abort = 1
    return
    end
! 	
! 	---------------------------------------------------------------------------------
!
!	Polynomials P_k^(LML'M')(0,0,1) of the shift-operators technique in the axis alligned system:
!
  subroutine subpolP001(la, lb)
    USE DAM320_D
    USE DAM320_CONST_D
    USE GAUSS
    implicit none
    integer(KINT) :: ierr, k, k12, kntpol, l, la, lb, lk, llp, lm, lmp, lp, m, md, mp, ms, naux
    real(KREAL) :: aux, bux, sd, ss, suma, xa, ya, za

    kntpol = 0
    do l = 0, la
        do lp = 0, min(l, lb)
            ipntpolP(l,lp) = kntpol+1
            k12 = indk12(l*(l+1)+1,lp*(lp+1)+1)
            ss = ssv(0,0)
            aux = uno
            do k = 0, lp
                suma = cero
                do lk = k, min(l,lp)
                    suma = suma + fact(lk) * facts(l+lp-lk) * ss * app(l+lp-lk-lk, k12) * facti(lk-k) * factsi(l+lp-lk-k)
                enddo
                kntpol = kntpol+1
                polP(kntpol) = aux * suma
                aux = (aux+aux) * ri(k+1)
            enddo
            bux = dos
            do mp = 1, min(l, lb)
                k12 = indk12(l*(l+1)+mp+1,lp*(lp+1)+mp+1)
                sd = sdv(mp,mp)
                aux = bux
                do k = mp, lp
                    suma = cero
                    do lk = k, min(l,lp)
                        suma = suma + fact(lk) * facts(l+lp-lk) * sd * bpp(l+lp-lk-lk, k12) * facti(lk-k) * factsi(l+lp-lk-k)
                    enddo
                    kntpol = kntpol+1
                    polP(kntpol) = aux * suma
                    aux = (aux+aux) * ri(k+1)
                enddo
                bux = (bux+bux) * ri(mp+1)
            enddo
        enddo
    enddo
    return
    end
!
!	-------------------------------------------------------------------------------------------------------
!
  subroutine totalchargeGTO
    USE DAM320_D
    USE DAM320_DATA_D
    USE DAM320_CONST_D
    USE GAUSS
    USE PARALELO
    implicit none
    integer(KINT) :: i, i1, i2, ia, ib, ierr, ii, ishift, j, la, lb, lrotar, m, nfa, nfb, nga1, nga2, ngb1, ngb2
    real(KREAL) :: charge, cosal, cosbet, cosga, rab, rna, rnab, rnb, sinal, sinbet, singa, xab, xy, yab, zab
    real(KREAL) :: roaux(-mxl:mxl,-mxl:mxl)
    allocate(sol(0:mxl), rl(-mxl:mxl,-mxl:mxl,0:mxl), dl(-mxl:mxl,-mxl:mxl,0:mxl), &
            stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error when allocating sol, av, bv, rl, dl.')")
        abort = 1
        return
    endif
    charge = cero
    do ia = 1, ncen
        nga1 = ngini(ia)
        if (nga1 .le. 0) cycle
        nga2 = ngfin(ia)
        do i1 = nga1, nga2
            la = ll(i1)
            rna= rnor(i1)
            nfa = nf(i1)
            do i2 = nga1, nga2
                lb = ll(i2)
                rnb = rnor(i2)
                nfb = nf(i2)
                call gaussoverlap(i1, i2, cero)
                do m = -min(la,lb), min(la,lb)
                    charge = charge + rna * rnb * dmat(nfb+lb+m,nfa+la+m) * sol(abs(m))
                enddo
            enddo
    enddo
    if (lzdo) cycle
    do ib = 1, ncen
        if (ia .eq. ib .or. ngini(ib) .le. 0) cycle
!	Computes Euler angles and rotation matrices from the AB aligned axis system to the molecular system and conversely
            xab = rcen(1,ib) - rcen(1,ia)
            yab = rcen(2,ib) - rcen(2,ia)
            zab = rcen(3,ib) - rcen(3,ia)
            xy = sqrt(xab*xab + yab*yab)
            rab = sqrt(xab*xab + yab*yab + zab*zab)
            if (rab .lt. 1.d-10) then
                write(6,"('Centers ',i8,' and ',i8,' coincide. Stop')") ia, ib
                abort = 1
                return
            endif
            if (xy .gt. 1.d-10) then
                sinal = yab / xy
                cosal = xab / xy
            else
                sinal = cero
                cosal = uno
            endif
            sinbet = xy / rab
            cosbet = zab / rab
            singa = cero
            cosga = uno
            lrotar = max(lmaxc(ia),lmaxc(ib))
            call rotar (lrotar, cosal, sinal, cosbet, sinbet, cosga, singa)
            ngb1 = ngini(ib)
            ngb2 = ngfin(ib)
            do i1 = nga1, nga2
                la = ll(i1)
                rna= rnor(i1)
                nfa = nf(i1)
                do i2 = ngb1, ngb2
                    lb = ll(i2)
                    rnb = rnor(i2)
                    nfb = nf(i2)
!	Reads the pertinent block of density matrix and rotates it to the AB aligned system. Loads the result in array roblk.
!	Angular normalization factors are introduced at the end of the loading process.
                    do i = -la, la
                        ishift = i+la+nfa
                        do j = -lb, lb
                            roblk(i,j) = dmat(j+lb+nfb,ishift)
                        enddo
                    enddo
!	Rotation on center B
                    do i = -la, la
                        do j = -lb, lb
                            roaux(i,j) = dot_product(roblk(i,-lb:lb),rl(-lb:lb,j,lb))
                        enddo
                    enddo
!	Rotation on center A
                    do i = -la, la
                        do j = -lb, lb
                            roblk(i,j) =  dot_product(roaux(-la:la,j), rl(-la:la,i,la))
                        enddo
                    enddo
                    call gaussoverlap(i1, i2, rab)
                    do m = -min(la,lb), min(la,lb)
                        charge = charge + rna * rnb * roblk(m,m) * sol(abs(m))
                    enddo
                enddo
            enddo
        enddo
    enddo
    if (lzdo) then
        write(6,"(/'Total valence electron charge computed from density matrix = ', e22.15,/)") -charge
    else
        write(6,"(/'Total electron charge computed from density matrix = ', e22.15,/)") -charge
    endif
    write(6,"('Highest value of l in the expansion of atomic densities = ', i4)") lmaxexp
    deallocate(dl, rl, sol)
    return
    end
!
!	-------------------------------------------------------------------------------------------------------
!
  subroutine gaussoverlap(i1, i2, R)
    USE DAM320_D
    USE DAM320_DATA_D
    USE DAM320_CONST_D
    USE GAUSS
    implicit none
    integer(KINT) :: i1, i1ini, i1fin, i1p, i2, i2ini, i2fin, i2p, k, kmax, knt, l, la, lb, m, maxl, minl, nprimi, nprimj
    real(KREAL) :: aux, R, z
    real(KREAL) :: rpw(0:mxldst), sumk, xiabinv, xikv(0:mxl)
    la = ll(i1)
    lb = ll(i2)
    nprimi = nprimit(i1)
    nprimj = nprimit(i2)
    i1ini = ipntprim(i1)
    i2ini = ipntprim(i2)
    if (i1ini .le. 0 .or. i2ini .le. 0) return
    i1fin = ipntprim(i1)+nprimi-1
    i2fin = ipntprim(i2)+nprimj-1
    Rpw(0) = uno
    do l = 1, la+lb
            Rpw(l) = Rpw(l-1) * R
    enddo
    sol = cero
    do i2p = i2ini, i2fin
        do i1p = i1ini, i1fin
            xiabinv = uno / (xxg(i1p)+xxg(i2p))
            xikv(0) = uno
            do l = 1, min(la,lb)
                xikv(l) = -umed * xikv(l-1) * (xxg(i1p)+xxg(i2p)) / (xxg(i1p)*xxg(i2p))
            enddo
            maxl = max(la, lb)
            minl = min(la, lb)
            knt = ipntpolP(maxl,minl)
            aux = cfcontr(i2p) * cfcontr(i1p) * (-xxg(i1p))**lb * xxg(i2p)**la * sqrt(pi)**3 &
                     * exp(-xxg(i1p)*xxg(i2p)*R*R*xiabinv)* sqrt(xiabinv)**(2*(la+lb)+3)
            do m = 0, min(la,lb)
                sumk = cero
                do k = m, min(la,lb)
                    sumk = sumk + Rpw(la+lb-k-k) * xikv(k) * polP(knt)
                    knt = knt + 1
                enddo
                sol(m) = sol(m) + aux * sumk
            enddo
        enddo
    enddo
    do m = 0, min(la,lb)
        sol(m) = sol(m) * ang(ind(la)+abs(m)+1) * ang(ind(lb)+abs(m)+1)
    enddo
    return
    end
!
!	-------------------------------------------------------------------------------------------------------
!
  subroutine para_range_den
    USE DAM320_D
    USE DAM320_DATA_D
    USE PARALELO
    implicit none
    integer(KINT) :: i, iaux, ibasedlt, j
    integer(KINT) :: nbaseproc(0:nprocs-1), idistbs(0:nprocs-1), ibaseproc(0:nprocs-1)
    real(KREAL) rbas, rprocs
    if (nprocs .eq. ncen) then
        do i = 1, ncen
            istav(i-1) = i
            iendv(i-1) = i
        enddo
        return
    endif

    rbas = nbasesac(ncen)
    rprocs = nprocs
    ibasedlt = nint(rbas / rprocs)
    nbaseproc(0) = ibasedlt
    do j = 1, nprocs-1
        nbaseproc(j) = nbaseproc(j-1) + ibasedlt
    enddo

    do j = 0, nprocs-1
        idistbs(j) = abs(nbaseproc(j)-nbasesac(1))
        ibaseproc(j) = 1
        do i = 2, ncen
            iaux = abs(nbaseproc(j)-nbasesac(i))
            if (iaux .lt. idistbs(j)) then
                idistbs(j) = iaux
                ibaseproc(j) = i
            endif
        enddo
    enddo

    istav(0) = 1
    do j = 0, nprocs-2
        iendv(j) = max(ibaseproc(j), istav(j))
        istav(j+1) = iendv(j) + 1
    enddo
    iendv(nprocs-1) = ncen
    return
    end
!
!	-------------------------------------------------------------------------------------------------------
!
  subroutine para_range_densprsbin
    USE DAM320_D
    USE DAM320_DATA_D
    USE PARALELO
    implicit none
    integer :: i, i2, ierr, isum, j, k, k2, kmax, knt, nbs1, nbs2
    integer(KINT) :: nbaseproc(0:nprocs-1), idistbs(0:nprocs-1), ibaseproc(0:nprocs-1)
    real(KREAL) rbas, rprocs
    if (nprocs .eq. ncen) then
        do i = 1, ncen
            istav(i-1) = i
            iendv(i-1) = i
        enddo
        return
    endif
   
    allocate(lblock(ncen,ncen), kntblock(ncen,ncen), iblock(numdvec), jblock(numdvec), icntproc(0:nprocs), nblocks(nprocs), &
            ndstblocks(nprocs), stat = ierr)
    if (ierr .ne. 0) then
        write(6,"('Memory error', i5, ' when allocating lblock, kntblock, iblock, jblock, icntproc, nblocks, ndstblocks.')") ierr
        abort = 1
        return
    endif
    
    lblock = .false.
    kntblock = 0
    do i = 1, numdvec
        do j = 1, ncen
            if (nfcen(j) .ge. ivec(i)) then
                iblock(i) = j
                exit
            endif
        enddo
        do j = 1, ncen
            if (nfcen(j) .ge. jvec(i)) then
                jblock(i) = j
                exit
            endif
        enddo
        kntblock(iblock(i),jblock(i)) = kntblock(iblock(i),jblock(i)) + 1
    enddo
    
!     do i = 1, numdvec
!         write(6,"('(',i4,',',i4,')', 3x, '(',i2,',',i2,')')") ivec(i), jvec(i), iblock(i), jblock(i)
!     enddo
    
    do i = 1, numdvec
        lblock(iblock(i),jblock(i)) = .true.
    enddo
    
    do i = 2, ncen
        do j = 1, i
            lblock(j,i) = lblock(i,j)
            kntblock(j,i) = kntblock(i,j)
        enddo
    enddo
    
!     write(6,"(/'  BLOCK MATRIX ',/)")
!     do i = 1, ncen
!         write(6,"(60(1x,l))") block(i,1:ncen)
!     enddo
    
        
    k = 0
    k2 = 0
    do i = 1, ncen
        nbs1 = nfcen(i) - nfcen(i-1)
        do j = 1, ncen  
            nbs2 = nfcen(j) - nfcen(j-1)
            if (lblock(i,j)) then
                k = k+1
                k2 = k2 + nbs1*nbs2
            endif
        enddo
    enddo

    if (longoutput) write(6,"(/'Number of distributions to be treated = ', i16)") k2

    k2 = k2 / nprocs
    if (longoutput) write(6,"('Average number of distributions per processor = ', i16)") k2

    icntproc = 0
    icntproc(0) = 0
    knt = 0
    i2 = 1
    do i = 1, ncen
        nbs1 = nfcen(i) - nfcen(i-1)
        do j = 1, ncen
            nbs2 = nfcen(j) - nfcen(j-1)
            if (lblock(i,j)) then
!                 knt = knt + 1
                knt = knt + nbs1 * nbs2
            endif
        enddo
        if (knt .ge. i2*k2) then
            icntproc(i2) = i
            i2 = i2 + 1
        endif
    enddo
    
    if (longoutput) write(6,"('Centers for processors = ', 10(1x,i8),/)") icntproc

    istav(:) = icntproc(0:nprocs-1) + 1
    iendv(:) = icntproc(1:nprocs)
            
    do i = 1, nprocs
        isum = 0
        do j = icntproc(i-1)+1, icntproc(i)
            do k = 1, ncen
                if (lblock(j,k)) isum = isum + 1
            enddo
        enddo
        nblocks(i) = isum
    enddo
         
    if (longoutput) write(6,"('Number of blocks for processors = ', 10(1x,i16),/)") nblocks   
                    
    do i = 1, nprocs
        isum = 0
        do j = icntproc(i-1)+1, icntproc(i)
            nbs1 = nfcen(j) - nfcen(j-1)
            do k = 1, ncen
                nbs2 = nfcen(k) - nfcen(k-1)
                if (lblock(j,k)) isum = isum + nbs1 * nbs2
            enddo
        enddo
        ndstblocks(i) = isum
    enddo
         
    if (longoutput) write(6,"('Number of distributions for processors = ', 10(1x,i16),/)") ndstblocks  
    
    deallocate(kntblock, iblock, jblock, icntproc, nblocks, ndstblocks)

    return
    end
!
!	-------------------------------------------------------------------------------------------------------
!
  subroutine error(ierr, msg)
    USE MPI
    USE DAM320_D
    implicit none
    integer(KINT) :: ierr, ierr2
    character(*) :: msg
    write(6,"(a)") msg
    write(6,"('Error code = ', i4)") ierr
    call MPI_FINALIZE(ierr2)
    stop
    end
