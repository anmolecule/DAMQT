!  Copyright 2013-2019, Jaime Fernandez Rico, Rafael Lopez, Ignacio Ema,
!  Guillermo Ramirez, Anmol Kumar, Sachin D. Yeole, Shridhar R. Gadre
! 
!  This file is part of DAM320.
! 
!  DAM320 is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation, either version 3 of the License, or
!  (at your option) any later version.
! 
!  DAM320 is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
! 
!  You should have received a copy of the GNU General Public License
!  along with DAM320.  If not, see <http://www.gnu.org/licenses/>.
!
!------------------------------------------------------------------------
!
! Program for tabulation of the radial factors appearing in the representation of the molecular density performed with
! DAM320
!
!
! Version of September 2018
!
  program DAMFRAD320
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE DAMFORCES320_D
    implicit none
    integer(KINT) :: i, iatom, j, k, knt, kntlist, ltab, mtab, ncntab, nlist, ntab, ntabtot
    real(KREAL) :: dltr, r, rfin, rini
    character(60) :: filename
    integer(KINT), parameter :: mxnlist = 100
    real(KREAL4) :: tarray(2), tiempo, dtime
    real(KREAL) :: rlist(mxnlist)
    real(KREAL), allocatable :: rtab(:)
    logical :: lpblnk, lrlist, lderiv, lderiv2
    namelist / options / dltr, filename, iatomsel, iswindows, lderiv, lderiv2, lrlist, ltab, longoutput, &
            mtab, ncntab, nlist, rini, rfin, rlist
    call consta

! 	defaults for NAMELIST OPTIONS
    longoutput = .false.! If .true. a more detailed output is given
    lderiv = .false.	! If .true. tabulates the first derivative of the radial factors
    lderiv2 = .false.	! If .true. tabulates the second derivative of the radial factors
    rini = cero		! Lower bound of interval for tabulation
    rfin = dos		! Upper bound of interval for tabulation
    dltr = ri(10)		! Step for tabulation
    ncntab = 1		! Number of atoms selected for tabulation (dummy, only used by DAMQT GUI)
    iatomsel(1) = 1	! Atoms selected for tabulation
    iatomsel(2:mxsel) = 0
    ltab = 0			! l  value for tabulation
    mtab = 0			! m  value for tabulation
    lrlist = .false.	! If true, list of r values for tabulation supplied in rlist
    nlist = 0			! Number of elements in rlist
    iswindows = .false.		! .true. if running on a MS-windows system
    filename = ""		! root file name

!	Reads NAMELIST OPTIONS
    read(5,OPTIONS)
    read(5,*) projectname
    write(6,"(1x,'project name : ',a,/,1x,'==============')") projectname
    if (iswindows) then
        dirsep = "\\"
        i = index(projectname,dirsep,.true.)	! Checks position of last directory name separator
        if (i .eq. 0) then	! This is intended for MinGW, whose directory separator in windows is also /
            dirsep = "/"
            i = index(projectname,dirsep,.true.)	! Checks position of last directory name separator
        endif
    else
        dirsep = "/"
        i = index(projectname,dirsep,.true.)	! Checks position of last directory name separator
    end if
    if (len_trim(filename).eq.0) then
        filename = projectname
    else
        filename = projectname(1:i)//trim(filename)
    endif
    if (dltr .le. cero) dltr = ri(10)
    ntab = nint((max(rini,rfin) - min(rini,rfin)) / dltr ) + 1
    if (nlist .gt. mxnlist) then
        write(6,"('Number of values of r supplied in rlist greather than maximum allowed.')")
        write(6,"('Takes the first ', i4, ' values')") mxnlist
        nlist = mxnlist
    endif
    ntabtot = ntab + nlist
    allocate(rtab(ntabtot))
    if (.not. allocated(rtab)) call error(1,'Memory error when allocating rtab. Stop')
    if (longoutput) write(6,"('Size of rtab   = ', i15, ' bytes')") size(rtab)
    call sort(nlist,rlist)
    knt = 0
    kntlist = 1
    r = rini
    do i = 1, ntab
        do j = kntlist, nlist
            if (rlist(j) .ge. r) exit
            kntlist = kntlist + 1
            knt = knt+1
            rtab(knt) = rlist(j)
        enddo
        knt = knt+1
        rtab(knt) = r
        r = r + dltr
    enddo
    do j = kntlist, nlist
        knt = knt+1
        rtab(knt) = rlist(j)
    enddo
    ntabtot = min(ntabtot,knt)

    call leedamqtfrad	! Reads file .damqt  (generated by DAM2016)
    k = 0
    doi: do i = 1, mxsel
        if (iatomsel(i) .le. ncen .and. iatomsel(i) .gt. 0) then
            do j = 1, k
                if (iatomsel(i) .eq. iatomsel(j)) cycle doi
            enddo
            k = k+1
            iatomsel(k) = iatomsel(i)
        endif
    enddo doi
    nsel = k
    open(11,file=trim(projectname)//".frad",form='formatted')
    call tabulafrad(ltab, mtab, ntabtot, rtab)
    close(11)
    if (lderiv) then
        open(11,file=trim(projectname)//".drvfrad",form='formatted')
        call tabuladeriv1(ltab, mtab, ntabtot, rtab)
        close(11)
    endif
    if (lderiv2) then
        open(11,file=trim(projectname)//".drv2frad",form='formatted')
        call tabuladeriv2(ltab, mtab, ntabtot, rtab)
        close(11)
    endif
    stop
    end
!
!	***************************************************************
!
  subroutine tabulafrad(l, m, ntab, rtab)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE DAMDEN320_D, only: icfposd, xajustd
    USE DAMFORCES320_D
    implicit none
    integer(KINT) :: i, ia, icflm, ierr, interv, j, kntlm, k, l, m, ntab
    real(KREAL) :: aux, dost, flm, ra, t, tchb0, tchb1
    real(KREAL), allocatable :: flmtab(:)
    real(KREAL) :: rtab(*)
    allocate(flmtab(ntab), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating flmtab. Stop')
    write(11,"(4(3x,i5))") l, m, nsel, ntab
    write(11,"(3x,7(1x,e17.10))") rtab(1:ntab)
    do k = 1, nsel
        ia = iatomsel(k)
        if (ngini(ia) .le. 0) then
            write(6,"('Center ', i4, ' has no associated radial factors')") ia
            cycle
        endif
        write(6,"(/10x,'Radial factor of  center ',i2,' (',a2,'):  f(l,m,r)', //11x,'r',t26,'f(',i2,',',i3,',r)', t43 &
                , '4 Pi (r**',i2,') * f(',i2,',',i3,',r)', /5x,70('-'))") ia, atmnam(ia), l, m, 2*l+2, l, m
        kntlm = l*l+l+m+1
        if(icfposd(kntlm+1,ia) .le. icfposd(kntlm,ia)) then    ! If the radial factor is negligible, prints a message and exits
            write(6,"('Negligible radial factor')")
            write(11,"(3x,i4,3x, a,/3x,7(1x,e17.10))") ia, atmnam(ia), (0.d0, i = 1, ntab)
            cycle
        endif
        do i = 1, ntab       ! Do sobre los puntos de tabulacion
            ra = rtab(i)
            if (ra .lt. rinterv(nintervaj)) then
                interv = indintrv(int(fct*ra)+1)
                if (icfposd(interv*lmtop,ia) .le. icfposd((interv-1)*lmtop,ia) ) then
                    flm = cero
                else
                    icflm = icfposd((interv-1)*lmtop+kntlm,ia)
                    t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
                    dost = t + t
                    tchb0 = uno
                    tchb1 = t
                    flm = cfajust(icflm) + cfajust(1+icflm) * tchb1
                    do j = 2, icfposd((interv-1)*lmtop+kntlm+1,ia)-icflm-1
                        aux = dost * tchb1 - tchb0
                        tchb0 = tchb1
                        tchb1 = aux
                        flm = flm + cfajust(j+icflm) * tchb1
                    enddo
                    flm = flm * exp(-xajustd(interv,ia)*ra)
                endif
            else
                flm = cero
            endif
            flmtab(i) = flm
            write(6,"(3x,f12.5,3x,e22.15,3x,e22.15)") ra, flm, cuatro * pi * ra**(l+l+2) * flm
        enddo
        write(11,"(3x,i4,3x, a, /3x,7(1x,e17.10))") ia, atmnam(ia), flmtab(1:ntab)
    enddo
    deallocate(flmtab)
    return
    end
!
!	***************************************************************
!
  subroutine tabuladeriv1(l, m, ntab, rtab)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE DAMDEN320_D, only: icfposd, xajustd
    USE DAMFORCES320_D
    implicit none
    integer(KINT) :: i, ia, icflm, ierr, interv, j, k, kntlm, l, m, ntab
    real(KREAL) :: aux, dost, drvflm, flm, ra, t, tchb0, tchb1, uchb0, uchb1
    real(KREAL), allocatable :: flmtab(:)
    real(KREAL) :: rtab(*)
    allocate(flmtab(ntab), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating flmtab. Stop')
    write(11,"(4(3x,i5))") l, m, nsel, ntab
    write(11,"(3x,7(1x,e17.10))") rtab(1:ntab)
    do k = 1, nsel
        ia = iatomsel(k)
        if (ngini(ia) .le. 0) then
            write(6,"('Center ', i4, ' has no associated radial factor')") ia
            cycle
        endif
        write(6,"(/5x,'First derivative of the radial factor of  center ',i2,' (',a2,'):  f(l,m,r)' &
                , //11x,'r',t22,'D[f(',i2,',',i3,',r),r]', t43 , '4 Pi (r**',i2,') * f(',i2,',',i3,',r)', /5x,70('-'))") &
                ia, atmnam(ia), l, m, 2*l+2, l, m
        kntlm = l*l+l+m+1
        if(icfposd(kntlm+1,ia) .le. icfposd(kntlm,ia)) then     ! If the radial factor is negligible, prints a message and exits
            write(6,"('Negligible radial factor')")
            return
        endif
        do i = 1, ntab       ! Do sobre los puntos de tabulacion
            ra = rtab(i)
            if (ra .lt. rinterv(nintervaj)) then
                interv = indintrv(int(fct*ra)+1)
                t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
                icflm = icfposd((interv-1)*lmtop+kntlm,ia)
                dost = t + t
                tchb0 = uno
                tchb1 = t
                uchb0 = uno
                uchb1 = dost
                flm = cfajust(icflm) + cfajust(1+icflm) * tchb1
                drvflm = cfajust(1+icflm)
                do j = 2, icfposd((interv-1)*lmtop+kntlm+1,ia)-icflm-1
                    aux = dost * tchb1 - tchb0
                    tchb0 = tchb1
                    tchb1 = aux
                    flm = flm + cfajust(j+icflm) * tchb1
                    drvflm = drvflm + cfajust(j+icflm) * re(j) * uchb1
                    aux = dost * uchb1 - uchb0
                    uchb0 = uchb1
                    uchb1 = aux
                enddo
                drvflm = drvflm * dos / (rinterv(interv)-rinterv(interv-1)) ! Introduces the factor D[t,r]
                drvflm = exp(-xajustd(interv,ia)*ra) * (-xajustd(interv,ia) * flm + drvflm)
            else
                drvflm = cero
            endif
            flmtab(i) = drvflm
            write(6,"(3x,f12.5,3x,e22.15,3x,e22.15)") ra, drvflm, cuatro * pi * ra**(l+l+2) * drvflm
        enddo
        write(11,"(3x,i4,3x, a, /3x,7(1x,e17.10))") ia, atmnam(ia), flmtab(1:ntab)
    enddo
    deallocate(flmtab)
    return
    end
!
!	***************************************************************
!
  subroutine tabuladeriv2(l, m, ntab, rtab)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE DAMDEN320_D, only: icfposd, xajustd
    USE DAMFORCES320_D
    implicit none
    integer(KINT) :: i, ia, icflm, ierr, interv, j, k, kntlm, l, m, ntab
    real(KREAL) :: aux, dost, drvflm, drv2flm, dux, flm, ra, rj2, sgn, t, tchb0, tchb1, uchb0, uchb1, umt2i
    real(KREAL), allocatable :: flmtab(:)
    real(KREAL) :: rtab(*)
    allocate(flmtab(ntab), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating flmtab. Stop')
    write(11,"(4(3x,i5))") l, m, nsel, ntab
    write(11,"(3x,7(1x,e17.10))") rtab(1:ntab)
    do k = 1, nsel
        ia = iatomsel(k)
        if (ngini(ia) .le. 0) then
            write(6,"('Center ', i4, ' has no associated radial factor')") ia
            cycle
        endif
        write(6,"(/5x,'Second derivative of the radial factor of  center ',i2,' (',a2,'):  f(l,m,r)' &
                , //11x,'r',t20,'D[f(',i2,',',i3,',r),{r,2}]', t43 , '4 Pi (r**',i2,') * f(',i2,',',i3,',r)', /5x,70('-'))") &
                ia, atmnam(ia), l, m, 2*l+2, l, m
        kntlm = l*l+l+m+1
        if(icfposd(kntlm+1,ia) .le. icfposd(kntlm,ia)) then     ! If the radial factor is negligible, prints a message and exits
            write(6,"('Negligible radial factor')")
            return
        endif
        do i = 1, ntab       ! Do sobre los puntos de tabulacion
            ra = rtab(i)
            if (ra .lt. rinterv(nintervaj)) then
                interv = indintrv(int(fct*ra)+1)
                t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
                icflm = icfposd((interv-1)*lmtop+kntlm,ia)
                dost = t + t
                umt2i = uno / (t*t - uno)
                tchb0 = uno
                tchb1 = t
                uchb0 = uno
                uchb1 = dost
                flm = cfajust(icflm) + cfajust(1+icflm) * tchb1
                drvflm = cfajust(1+icflm)
                drv2flm = cero
                sgn = uno
                do j = 2, icfposd((interv-1)*lmtop+kntlm+1,ia)-icflm-1
                    aux = dost * tchb1 - tchb0
                    tchb0 = tchb1
                    tchb1 = aux
                    flm = flm + cfajust(j+icflm) * tchb1
                    drvflm = drvflm + cfajust(j+icflm) * re(j) * uchb1
                    if (uno-abs(t) .gt. 1.d-7) then
                        drv2flm = drv2flm + cfajust(j+icflm) * re(j) * umt2i * (re(j-1) * t * uchb1 - re(j) * uchb0)
                    else	! For values of t very close to 1 or -1, takes a linear approximation (Taylor series)
                        rj2 = re(j) * re(j)
                        drv2flm = drv2flm + cfajust(j+icflm) * sgn * ri(3) * (rj2 * (rj2 - uno)  &
                                + ri(5) * rj2 * (re(4) + rj2 * (-re(5) + rj2)) * (abs(t)-uno) )
                                if (t .lt. cero) sgn = - sgn
                    endif
                    aux = dost * uchb1 - uchb0
                    uchb0 = uchb1
                    uchb1 = aux
                enddo
                dux = dos / (rinterv(interv)-rinterv(interv-1))
                drvflm = drvflm * dux
                drv2flm = drv2flm * dux * dux
                drv2flm = exp(-xajustd(interv,ia)*ra) * (xajustd(interv,ia) * (xajustd(interv,ia) * flm &
                        - (drvflm+drvflm)) + drv2flm )
            else
                drv2flm = cero
            endif
            flmtab(i) = drv2flm
            write(6,"(3x,f12.5,3x,e22.15,3x,e22.15)") ra, drv2flm, cuatro * pi * ra**(l+l+2) * drv2flm
        enddo
        write(11,"(3x,i4,3x, a, /3x,7(1x,e17.10))") ia, atmnam(ia), flmtab(1:ntab)
    enddo
    deallocate(flmtab)
    return
    end
!
!	*************************************************************
!
  subroutine sort(n, xsort)
    USE DAM320_D
    implicit none
    integer(KINT) :: i, j, n
    real(KREAL) :: aux
    integer(KINT), parameter :: mxsteps = 1000
    logical :: lend
    real(KREAL) :: xsort(*)
    do i = 1, mxsteps
        lend = .true.
        do j = 1, 2*(n/2), 2
            if (xsort(j) .le. xsort(j+1)) cycle
            aux = xsort(j)
            xsort(j) = xsort(j+1)
            xsort(j+1) = aux
            lend = .false.
        enddo
        do j = 2, 2*((n-1)/2), 2
            if (xsort(j) .le. xsort(j+1)) cycle
            aux = xsort(j)
            xsort(j) = xsort(j+1)
            xsort(j+1) = aux
            lend = .false.
        enddo
        if (lend) return
    enddo
    call error(1,'Highest number of steps in sort reached. Stop')
    return
    end
!
!	***************************************************************
!
  subroutine leedamqtfrad
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE DAMDEN320_D, only: icfposd, xajustd
    USE GAUSS
    implicit none
    integer(KINT) :: i, ia, icarga, ierr, indnf, indng, interv, j, k, k1, k2, knt
    integer(KINT) :: lenindintrv, lldummy, lm, ncenbas, ncfaj, ncflm, ndummy, nfdummy, nginidummy, ngfindummy, nndummy, nsize
    real(KREAL) :: aux, bux, r, radiomin, step, stepmed, xxdummy
    inquire(file=trim(projectname)//"_2016.damqt", size=nsize, iostat=ierr)
    if (ierr .ne. 0) call error(ierr,'Error when inquiring file '//trim(projectname)//"_2016.damqt")
    if (nsize .eq. -1) call error(1,'Size of file '//trim(projectname)//"_2016.damqt cannot be determined")
    if (longoutput) write(6,"('Size of file ', a, ' = ', i12)") trim(projectname)//"_2016.damqt", nsize
#if _WIN32
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
#elif __INTEL_COMPILER
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
#else
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='unformatted', action = 'read', access='stream', iostat=ierr)
#endif
    if (ierr .ne. 0) call error(ierr,'Error when opening file '//trim(projectname)//"_2016.damqt")
    if (longoutput) write(6,"('Opens file ', a)") trim(projectname)//"_2016.damqt"
    read(10) ncen, nbas, ncaps
    nsize = nsize - sizeof(ncen) - sizeof(nbas) - sizeof(ncaps)
    if (longoutput) write(6,"('ncen = ', i3, ' nbas = ', i5, ' ncaps = ', i3)") ncen, nbas, ncaps

!	Allocates memory for geometry and basis set

    allocate(atmnam(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating atmnam. Stop')

    allocate(nzn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating nzn. Stop')

    allocate(rcen(3,ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating rcen. Stop')

    allocate(zn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating zn. Stop')

    if (longoutput) write(6,"(/24x,'GEOMETRY (BOHR)')")
    if (longoutput) write(6,"(/t1, ' no. of center:', t20, 'x', t32, 'y', t44, 'z', t56, 'charge')")
    do ia = 1, ncen
        read(10) rcen(1,ia), rcen(2,ia), rcen(3,ia), zn(ia)
        if (abs(zn(ia)-re(int(zn(ia) + umbrzn))) .gt. umbrzn) then
                nzn(ia) = 0
        else
                nzn(ia) = int(zn(ia) + umbrzn)
        endif
        atmnam(ia) = atmnms(nzn(ia))
        if (longoutput) write(6,"(t4, i5, t13, f12.7, t25, f12.7, t37, f12.7, t51, f10.5)") &
                ia, rcen(1,ia), rcen(2,ia), rcen(3,ia) , zn(ia)
    enddo
    nsize = nsize - sizeof(rcen) - sizeof(zn)

!	Basis set
    i = 0
    read(10) lsto	! .true. means STO basis, .false. means GTO basis
    nsize = nsize - sizeof(lsto)
    if (lsto) then
        allocate(ngini(ncen), stat = ierr)
        if (ierr .ne. 0) call error(1,'Memory error when allocating ngini. Stop')
!		Reads basis set data to dummies
        i = 0
        ncenbas = 0
        do ia = 1, ncen
            read(10) ngini(ia), ngfindummy
            nsize = nsize - sizeof(ngini(ia)) - sizeof(ngfindummy)
            if (ngini(ia) .le. 0) cycle
            ncenbas = ncenbas + 1
            do k = ngini(ia), ngfindummy
                i = i + 1
                read(10) nfdummy, nndummy, lldummy, xxdummy
                nsize = nsize - sizeof(nfdummy) - sizeof(nndummy) - sizeof(lldummy) - sizeof(xxdummy)
            enddo
        enddo
    else
        read(10) nprimitot
        nsize = nsize - sizeof(nprimitot)
        allocate(ngini(ncen), stat = ierr)
        if (ierr .ne. 0) call error(1,'Memory error when allocating ngini. Stop')
!		Reads basis set data to dummies
        indng = 1
        ncenbas = 0
        do ia = 1, ncen
            read(10) ndummy
            nsize = nsize - sizeof(ndummy)
            if (ndummy .le. 0) then
                ngini(ia) = -1
                cycle
            endif
            ncenbas = ncenbas + 1
            ngini(ia) = indng
            indng = indng + ndummy
            do j = 1, ndummy
                read(10) nndummy, lldummy
                nsize = nsize - sizeof(nndummy) - sizeof(lldummy)
                read(10) (xxdummy, k = 1, nndummy)
                read(10) (xxdummy, k = 1, nndummy)
                nsize = nsize - 2 * nndummy * sizeof(xxdummy)
            enddo
        enddo
    endif

!	Data of density representation
    read(10) lmaxexp
    nsize = nsize - sizeof(lmaxexp)
    lmtop = (lmaxexp+1)*(lmaxexp+1)
    if (longoutput) write(6,"('lmaxexp = ', i2, ' nintervaj = ', i2)") lmaxexp, nintervaj

    allocate(icfposd(lmtop*nintervaj+1,ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating icfposd. Stop')
    if (longoutput) write(6,"('Size of icfposd   = ', i15, ' bytes')") size(icfposd)
    nsize = nsize - sizeof(icfposd(:,1)) * ncenbas

    allocate(xajustd(nintervaj,ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating xajustd. Stop')
    if (longoutput) write(6,"('Estimated highest size of xajust   = ', i15, ' bytes')") size(xajustd)
    nsize = nsize - sizeof(xajustd(:,1)) * ncenbas

    allocate(cfajust(nsize/8), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating cfajust. Stop')
    if (longoutput) write(6,"('Size of cfajust   = ', i15, ' bytes')") size(cfajust)
    icfposd = 0
    xajustd = cero
    cfajust = cero
    k = 0
    do ia = 1, ncen      ! Do over centers
        if (ngini(ia) .le. 0) cycle
        read(10) icfposd(1:lmtop*nintervaj+1,ia)
        if (k .gt. 0) then
            icfposd(1:lmtop*nintervaj+1,ia) = icfposd(1:lmtop*nintervaj+1,ia) + icfposd(lmtop*nintervaj+1,k) - 1
        endif
        k = ia
        read(10) xajustd(1:nintervaj,ia)		! Exponents
        if (longoutput) write(6,"('fitting exponents: ',/, 8(1x,e17.10))")  xajustd(1:nintervaj,ia)
!     fitting coeficients
        read(10) cfajust(icfposd(1,ia):icfposd(lmtop*nintervaj+1,ia)-1)
    enddo

!	Generates an auxiliary index array for determining the interval to which a given r belongs
    step = rinterv(1)
    fct = uno / step
    lenindintrv = int(rinterv(nintervaj) * fct + udec)

    allocate(indintrv(lenindintrv), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating indintrv. Stop')
    if (longoutput) write(6,"('Size of indintrv   = ', i15, ' bytes')") size(indintrv)

    r = cero
    interv = 1
    do i = 1, lenindintrv-1
        r = r + step
        if (r .gt. (rinterv(interv))) interv = interv + 1
        indintrv(i) = interv
    enddo
    indintrv(lenindintrv) = interv
    close(10)
    return
    end
!
!**********************************************************************
!
  subroutine consta
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    integer(KINT) :: i
!	auxiliary parameters and functions
    pi = acos(-uno)
    raizpi = sqrt(pi)
    re(0) = cero
    ri(0) = 1.d300
    do i = 1, mxreal
        re(i) = re(i-1) + uno        ! dfloat(i)
        re(-i) = -re(i)
        ri(i) = uno / re(i)       	! uno / dfloat(i)
        ri(-i) = -ri(i)
    enddo
    return
    end
!
!	-------------------------------------------------------------------------------------------------------
!
  subroutine error(ierr, msg)
    USE DAM320_D
    implicit none
    integer(KINT) :: ierr
    character(*) :: msg
    write(6,"(a)") msg
    write(6,"('Error code = ', i4)") ierr
    stop
    end
