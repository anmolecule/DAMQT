!  Copyright 2013-2019, Jaime Fernandez Rico, Rafael Lopez, Ignacio Ema,
!  Guillermo Ramirez, Anmol Kumar, Sachin D. Yeole, Shridhar R. Gadre
! 
!  This file is part of DAM320.
! 
!  DAM320 is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation, either version 3 of the License, or
!  (at your option) any later version.
! 
!  DAM320 is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
! 
!  You should have received a copy of the GNU General Public License
!  along with DAM320.  If not, see <http://www.gnu.org/licenses/>.
!
!------------------------------------------------------------------------
!
! Program for tabulation of the electic field from the representation of the molecular density performed with
! DAM320
!
!
! Version of April 2019
!
  program DAMFIELDPNT320
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE DAMFIELD320_D
    implicit none
    integer(KINT) :: i, ierr
    integer(KINT) :: nucleos1, nucleos2, numlns, ntheta
    real(KREAL) :: dltfi, ex, ey, ez, fi, pidv4, R, theta, usalto, x, y, z
    real(4) :: tarray(2), tiempo, dtime
    integer(4) :: nfi(3)
    namelist / options / iswindows, largo, lmaxrep, longoutput, lvalence, umbrlargo
!	Namelist default values
    longoutput = .false.	! If .true. a more detailed output is given
    lvalence = .false.      ! If .true. only valence electrons are considered
    lmaxrep = 5             ! highest value of  l  in the expansion of the density for computing the field
    umbrlargo = 1.d-5       ! Threshold for determining the short-range radius
    largo = .false.         ! If .true. computes the long-range field
    iswindows = .false.		! .true. if running on a MS-windows system

!	End of namelist defaults

    read(5,OPTIONS)
    read(5,*) projectname
    write(6,"(1x,'project name : ',a,/,1x,'==============')") projectname
    if (iswindows) then
        dirsep = "\\"
        i = index(projectname,dirsep,.true.)	! Checks position of last directory name separator
        if (i .eq. 0) then	! This is intended for MinGW, whose directory separator in windows is also /
            dirsep = "/"
            i = index(projectname,dirsep,.true.)	! Checks position of last directory name separator
        endif
    else
        dirsep = "/"
        i = index(projectname,dirsep,.true.)	! Checks position of last directory name separator
    end if

    if (lvalence) then
        write(6,"(//'Using valence electrons only',//)")
    endif

    call consta		!	Computes auxiliary constants
    call leedamqtfield	!	Reads file .damqt  (generated by DAM2016)
    if (lmaxrep .gt. lmaxexp) then
        write(6,"('lmaxrep = ', i3, ' greater than lmaxexp ', i3)") lmaxrep, lmaxexp
        write(6,"('takes lmaxrep = ',i3)") lmaxexp
        lmaxrep = lmaxexp
    endif

    pidv4 = .25d0 * pi
    if (largo) then
        write(6,"(/45x,'Long-range electric field',/,45x,26('='),/,8x,'x',17x,'y',17x,'z',17x,'Ex',16x,'Ey',16x,'Ez')")
    else
        write(6,"(/45x,'Electric field',/,45x,15('='),/,8x,'x',17x,'y',17x,'z',17x,'Ex',16x,'Ey',16x,'Ez')")
    endif
    read(5,*,iostat=ierr) x, y, z
    do while (ierr .eq. 0)
        if (largo) then
            call campolargo(x, y, z, ex, ey, ez)
        else
            call campo(x, y, z, ex, ey, ez)
        endif
        write(6,"(3(1x,e17.10), 3(1x,e17.10))") x, y, z, ex, ey, ez
        read(5,*,iostat=ierr) x, y, z
    enddo
    stop
    end


!   ***************************************************************

   subroutine campo(x, y, z, ex, ey, ez)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D, zn_orig => zn
    USE DAMFIELD320_D
    implicit none
    integer(KINT) :: i, ia, icflm, ierr, interv, isgm, isgmm1, isgmp1, j, l, lm, lm1l, lp1lp2, ltop, m, mm
    real(KREAL) :: c1, c2, dost, Ex, Exext, Exnucl, Ey, Eyext, Eynucl, Ez, Ezext, Eznucl
    real(KREAL) :: pi4d2l1, ra, ra2, ra2inv, ra3inv, ra2l3inv, rinta, rintb, t, x, xa, y, ya, z, za
    real(KREAL) :: zlm((lmaxexp+2)*(lmaxexp+2)), tcheb(0:mxlenpol-1)
    real(KREAL), allocatable :: zn(:)
    allocate(zn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating zn in multmolec. Stop')
    if (lvalence) then
        do i = 1, ncen
            zn(i) = atom_core(zn_orig(i))
        enddo
    else
        zn = zn_orig
    endif
!    Electric field in point (x,y,z)
    Exnucl = cero
    Eynucl = cero
    Eznucl = cero
    Exext = cero
    Eyext = cero
    Ezext = cero
    do ia = 1, ncen
        xa = x - rcen(1,ia)
        ya = y - rcen(2,ia)
        za = z - rcen(3,ia)
        ra2 = xa*xa + ya*ya + za*za
        ra = sqrt(ra2)
        if (ra .lt. 1.d-10) then
            write(6,"('The point ',3(1x,F10.5),' coincides with center ',i4)") x, y, z, ia
            return
        endif
        ra3inv = uno / (ra*ra2)
        Exnucl = Exnucl + zn(ia) * xa * ra3inv
        Eynucl = Eynucl + zn(ia) * ya * ra3inv
        Eznucl = Eznucl + zn(ia) * za * ra3inv
        if (ngini(ia) .le. 0) cycle
        ra2inv = uno / ra2
        if (ra .lt. rlargo(ia)) then
            interv = indintrv(int(fct*ra)+1)
            ltop = lcorto(interv,ia)
        else
            ltop = llargo(min(int(ra),mxlargo),ia)
        endif
        zlm(1) = uno		! Regular spherical harmonics of r-R(ia)
        zlm(2) = ya
        zlm(3) = za
        zlm(4) = xa
        do l = 1, ltop
            zlm((l+1)*(l+3)+1) = dosl1(l) * (xa * zlm(l*(l+2)+1) - ya * zlm(l*l+1))		! zlm(l+1,l+1,ia)
            zlm((l+1)*(l+1)+1) = dosl1(l) * (ya * zlm(l*(l+2)+1) + xa * zlm(l*l+1))		! zlm(l+1,-(l+1),ia)
            zlm((l+2)*(l+2)-1) = dosl1(l) * za* zlm(l*(l+2)+1)				! zlm(l+1,l,ia)
            zlm(l*(l+2)+3) = dosl1(l) * za * zlm(l*l+1)					! zlm(l+1,-l,ia)
            do m = 0, l-1
                zlm((l+1)*(l+2)+m+1) = ri(l-m+1) * (dosl1(l)*za*zlm(l*(l+1)+m+1) - re(l+m)*ra2*zlm((l-1)*l+m+1))	! zlm(l+1,m,ia)
                zlm((l+1)*(l+2)-m+1) = ri(l-m+1) * (dosl1(l)*za*zlm(l*(l+1)-m+1) - re(l+m)*ra2*zlm((l-1)*l-m+1))	! zlm(l+1,-m,ia)
            enddo
        enddo

        if (ra .gt. rlargo(ia)) then   ! Long-range
            lm = 0
            ra2l3inv = uno / ra
            do l = 0, ltop
                ra2l3inv = ra2l3inv  * ra2inv	! 1.d0 / (ra**(2*l+3))
                do m = -l, l
                    lm = lm + 1
                    if(abs(QGacum((nintervaj-1)*lmtop+lm,ia)) .lt. umbrlargo) cycle
                    mm = iabs(m)
                    if (m .ge. 0) then
                        isgm = 1
                    else
                        isgm = -1
                    endif
!      Ex
                    c1 = zlm( (l+1)*(l+2)+isgm*(mm+1)+1)
                    if (m .ne. 0 .and. m .ne. -1) then
                        c1 = c1 - re(l+1-mm) * re(l+2-mm) * zlm( (l+1)*(l+2)+isgm*(mm-1)+1 )
                    else
                        if (m .eq. 0) then
                            c1 = c1 + c1
                        endif
                    endif
                    c1 = c1 * ra2l3inv
                    Ex = -umed * rmultip(lm,ia) * c1
                    Exext = Exext + Ex
!      Ey
                    c1 = zlm( (l+1)*(l+2)-isgm*(mm+1)+1 )
                    if (m .ne. 0 .and. m .ne. 1) then
                        c1 = c1 + re(l+1-mm) * re(l+2-mm) * zlm( (l+1)*(l+2)-isgm*(mm-1)+1 )
                    else
                        if (m .eq. 0) then
                            c1 = c1 + c1
                        endif
                    endif
                    c1 = c1 * ra2l3inv
                    Ey = -isgm * umed * rmultip(lm,ia) * c1
                    Eyext = Eyext + Ey
!      Ez
                    Ez = -rmultip(lm,ia)  * re(l+1-mm) * zlm( (l+1)*(l+2)+m+1 ) * ra2l3inv
                    Ezext = Ezext + Ez
                enddo
            enddo
            kntlargo = kntlargo + 1
        else
!     locates the fitting interval for ra
            interv = indintrv(int(fct*ra)+1)
            t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
            dost = t + t
            tcheb(0) = uno	! Chebyshev T  polynomials
            tcheb(1) = t
            do j = 2, mxlenpol-1
                    tcheb(j) = dost * tcheb(j-1) - tcheb(j-2)
            enddo
!     Integrals:
!		rinta = Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(i-1),r0}]
!		rintb = Integrate[ r * fradtr[la,ma,r], {r,r0,l_i}]
!		computed from fitting polynomials	
            lm = 0
            ra2l3inv = uno / ra
            do l = 0, ltop
                pi4d2l1 = cuatro * pi * dosl1i(l)
                ra2l3inv = ra2l3inv  * ra2inv	! 1.d0 / (ra**(2*l+3))
                lp1lp2 = (l+1)*(l+2)
                lm1l = (l-1)*l
                do m = -l, l
                    lm = lm + 1
                    if(abs(QGacum((nintervaj-1)*lmtop+lm,ia)) .lt. umbrlargo) cycle
                    icflm = icfposd((interv-1)*lmtop+lm,ia)
                    rinta = cero
                    rintb = cero
                    do i = 0, icfposd((interv-1)*lmtop+lm+1,ia)-icflm-1
                        rinta = rinta + cfrint2l2(icflm+i) * tcheb(i)
                        rintb = rintb + cfrint1(icflm+i) * tcheb(i)
                    enddo
                    rinta = rinta * (ra-rinterv(interv-1))
                    if (interv .gt. 1) rinta = QGacum((interv-2)*lmtop+lm,ia) + rinta
                    rintb = qpacum((interv-1)*lmtop+lm,ia) + rintb * (rinterv(interv)-ra)
                    mm = iabs(m)
                    if (m .ge. 0) then
                        isgm = 1
                    else
                        isgm = -1
                    endif
                    isgmm1 = isgm*(mm-1)
                    isgmp1 = isgm*(mm+1)
!      Ex
                    c1 = zlm( lp1lp2+isgmp1+1 )
                    if (l .gt. mm+1) then
                        c2 = zlm(lm1l + isgmp1 + 1)
                    else
                        c2 = cero
                    endif
                    if (m .ne. 0 .and. m .ne. -1) then
                        c1 = c1 - re(l+1-mm) * re(l+2-mm) * zlm( lp1lp2+isgmm1+1 )
                        c2 = c2 - re(l+mm) * re(l+mm-1) * zlm( lm1l+isgmm1+1 )
                    else
                        if (m .eq. 0) then
                            c1 = c1 + c1
                            c2 = c2 + c2
                        endif
                    endif
                    Exext = Exext -umed * pi4d2l1 * (c1 * rinta * ra2l3inv + c2 * rintb)

!      Ey
                    c1 = zlm( lp1lp2-isgmp1+1 )
                    if (l .gt. mm+1) then
                        c2 = zlm(lm1l-isgmp1+1 )
                    else
                        c2 = cero
                    endif
                    if (m .ne. 0 .and. m .ne. 1) then
                        c1 = c1 + re(l+1-mm) * re(l+2-mm) * zlm( lp1lp2-isgmm1+1 )
                        c2 = c2 + re(l+mm) * re(l+mm-1) * zlm( lm1l-isgmm1+1 )
                    else
                        if (m .eq. 0) then
                            c1 = c1 + c1
                            c2 = c2 + c2
                        endif
                    endif
                    Eyext = Eyext - isgm * umed * pi4d2l1 * (c1 * rinta * ra2l3inv + c2 * rintb)
!      Ez	
                    c1 = re(l+1-mm) * zlm( lp1lp2+m+1 )
                    if (l .gt. mm) then
                        c2 = re(l+mm) * zlm( lm1l+m+1 )
                    else
                        c2 = cero
                    endif
                    Ezext = Ezext - pi4d2l1 * (c1 * rinta * ra2l3inv - c2 * rintb)
                enddo     ! End of Do over m
            enddo     ! End of Do over l
            kntcorto = kntcorto + 1
        endif
    enddo     ! Fin del Do en ia
    ex = Exext + Exnucl
    ey = Eyext + Eynucl
    ez = Ezext + Eznucl
    return
    end

!   ***************************************************************

   subroutine campolargo(x, y, z, ex, ey, ez)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D, zn_orig => zn
    USE DAMFIELD320_D
    implicit none
    integer(KINT) :: i, ia, ierr, interv, isgm, l, lm, ltop, m, mm
    real(KREAL) :: c1, c2, Ex, Exext, Exnucl, Ey, Eyext, Eynucl, Ez, Ezext, Eznucl
    real(KREAL) :: ra, ra2, ra2inv, ra3inv, ra2l3inv, x, xa, y, ya, z, za
    real(KREAL) :: zlm((lmaxexp+2)*(lmaxexp+2))
    real(KREAL), allocatable :: zn(:)
    allocate(zn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating zn in multmolec. Stop')
    if (lvalence) then
        do i = 1, ncen
            zn(i) = atom_core(zn_orig(i))
        enddo
    else
        zn = zn_orig
    endif
!    Long-range Electric field in point (x,y,z)
    Exnucl = cero
    Eynucl = cero
    Eznucl = cero
    Exext = cero
    Eyext = cero
    Ezext = cero
    do ia = 1, ncen
        xa = x - rcen(1,ia)
        ya = y - rcen(2,ia)
        za = z - rcen(3,ia)
        ra2 = xa*xa + ya*ya + za*za
        ra = sqrt(ra2)
        if (ra .lt. 1.d-1) then
            write(6,"('The point ',3(1x,F10.5),' is too close to center ',i4, ' for long-range computation')") x, y, z, ia
            return
        endif
        ra3inv = uno / (ra * ra2)
        Exnucl = Exnucl + zn(ia) * xa * ra3inv
        Eynucl = Eynucl + zn(ia) * ya * ra3inv
        Eznucl = Eznucl + zn(ia) * za * ra3inv
        if (ngini(ia) .le. 0) cycle
        ra2inv = uno / ra2
        if (ra .lt. rlargo(ia)) then
            interv = indintrv(int(fct*ra)+1)
            ltop = lcorto(interv,ia)
        else
            ltop = llargo(min(int(ra),mxlargo),ia)
        endif
        zlm(1) = uno		! Regular spherical harmonics of r-R(ia)
        zlm(2) = ya
        zlm(3) = za
        zlm(4) = xa
        do l = 1, ltop
            zlm((l+1)*(l+3)+1) = dosl1(l) * (xa * zlm(l*(l+2)+1) - ya * zlm(l*l+1))		! zlm(l+1,l+1,ia)
            zlm((l+1)*(l+1)+1) = dosl1(l) * (ya * zlm(l*(l+2)+1) + xa * zlm(l*l+1))		! zlm(l+1,-(l+1),ia)
            zlm((l+2)*(l+2)-1) = dosl1(l) * za* zlm(l*(l+2)+1)				! zlm(l+1,l,ia)
            zlm(l*(l+2)+3) = dosl1(l) * za * zlm(l*l+1)					! zlm(l+1,-l,ia)
            do m = 0, l-1
                zlm((l+1)*(l+2)+m+1) = ri(l-m+1) * (dosl1(l)*za*zlm(l*(l+1)+m+1) - re(l+m)*ra2*zlm((l-1)*l+m+1))	! zlm(l+1,m,ia)
                zlm((l+1)*(l+2)-m+1) = ri(l-m+1) * (dosl1(l)*za*zlm(l*(l+1)-m+1) - re(l+m)*ra2*zlm((l-1)*l-m+1))	! zlm(l+1,-m,ia)
            enddo
        enddo
        lm = 0
        ra2l3inv = uno / ra
        do l = 0, ltop
            ra2l3inv = ra2l3inv  * ra2inv	! 1.d0 / (ra**(2*l+3))
            do m = -l, l
                lm = lm + 1
                mm = iabs(m)
                if (m .ge. 0) then
                    isgm = 1
                else
                    isgm = -1
                endif
!      Ex
                c1 = zlm( (l+1)*(l+2)+isgm*(mm+1)+1 )
                if (m .ne. 0 .and. m .ne. -1) then
                    c1 = c1 - re(l+1-mm) * re(l+2-mm) * zlm( (l+1)*(l+2) + isgm*(mm-1) + 1 )
                else
                    if (m .eq. 0) then
                        c1 = c1 + c1
                    endif
                endif
                c1 = c1 * ra2l3inv
                Ex = -umed * rmultip(lm,ia) * c1
                Exext = Exext + Ex
                c1 = zlm( (l+1)*(l+2)-isgm*(mm+1)+1 )
                if (m .ne. 0 .and. m .ne. 1) then
                    c1 = c1 + re(l+1-mm) * re(l+2-mm) * zlm( (l+1)*(l+2)-isgm*(mm-1)+1 )
                else
                    if (m .eq. 0) then
                        c1 = c1 + c1
                    endif
                endif
                c1 = c1 * ra2l3inv
                Ey = -isgm * umed * rmultip(lm,ia) * c1
                Eyext = Eyext + Ey
!      Ez
                c1 = re(l+1-mm) * zlm( (l+1)*(l+2)+m )
                if (l .gt. mm) then
                    c2 = re(l+mm) * zlm( (l-1)*l+m )
                else
                    c2 = cero
                endif
                c1 = c1 * ra2l3inv
                Ez = -rmultip(lm,ia)  * c1
                Ezext = Ezext + Ez
            enddo
        enddo
    enddo     ! End of DO over ia
    ex = Exext + Exnucl
    ey = Eyext + Eynucl
    ez = Ezext + Eznucl
    return
    end
!
!	***************************************************************
!
  subroutine leedamqtfield
    USE DAM320_D
    USE DAMFIELD320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE GAUSS
    implicit none
    integer(KINT) :: i, ia, icarga, icflm, ierr, indnf, indng, interv, j, k, k1, k2, knt, kntlm, l, lenindintrv
    integer(KINT) :: lldummy, lm, m, ncenbas, ncflm, ndummy, nfdummy, nginidummy, ngfindummy, nndummy, nsamples
    real(KREAL) :: aux, bux, dltsample, dost, dummy, fr1, fr2l2, pi4d2l1, r, ra, ral1inv, rainv, ral
    real(KREAL) :: rinta, rintb, rlarex, step, stepmed, suml, suml1, suml2, summ, summ1, summ2, t, xxdummy
    real(KREAL), allocatable :: Qg(:), qp(:)
    real(KREAL) :: tcheb(0:mxlenpol-1)
#if _WIN32
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0) call error(1,'Memory error when opening file '//trim(projectname)//"_2016.damqt")
    open (unit=11, file=trim(projectname)//"_2016.dmqtv", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0) call error(1,'Memory error when opening file '//trim(projectname)//"_2016.dmqtv")
#elif __INTEL_COMPILER
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0) call error(1,'Memory error when opening file '//trim(projectname)//"_2016.damqt")
    open (unit=11, file=trim(projectname)//"_2016.dmqtv", form='binary', action = 'read', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0) call error(1,'Memory error when opening file '//trim(projectname)//"_2016.dmqtv")
#else
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='unformatted', action = 'read', access='stream', iostat=ierr)
    if (ierr .ne. 0) call error(1,'Memory error when opening file '//trim(projectname)//"_2016.damqt")
    open (unit=11, file=trim(projectname)//"_2016.dmqtv", form='unformatted', action = 'read', access='stream', iostat=ierr)
    if (ierr .ne. 0) call error(1,'Memory error when opening file '//trim(projectname)//"_2016.dmqtv")
#endif
    if (longoutput) write(6,"('Opens files ', a, ' and ', a)") trim(projectname)//"_2016.damqt", trim(projectname)//"_2016.dmqtv"
    read(10) ncen, nbas, ncaps
    write(6,"('ncen = ', i4, ' nbas = ', i6, ' ncaps = ', i5)") ncen, nbas, ncaps

!	Allocates memory for geometry and basis set

    allocate(atmnam(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating atmnam. Stop')

    allocate(nzn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating nzn. Stop')

    allocate(rcen(3,ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating rcen. Stop')

    allocate(zn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating zn. Stop')

!	Geometry and nuclear charges

    write(6,"(/24x,'GEOMETRY (BOHR)')")
    write(6,"(/t1, ' no. of center:', t20, 'x', t32, 'y', t44, 'z', t56, 'charge')")
    do ia = 1, ncen
        read(10) rcen(1,ia), rcen(2,ia), rcen(3,ia), zn(ia)
        if (abs(zn(ia)-re(int(zn(ia) + umbrzn))) .gt. umbrzn) then
            nzn(ia) = 0
        else
            nzn(ia) = int(zn(ia) + umbrzn)
        endif
        atmnam(ia) = atmnms(nzn(ia))
        write(6,"(t4, i5, t13, f12.7, t25, f12.7, t37, f12.7, t51, f10.5)") &
                ia, rcen(1,ia), rcen(2,ia), rcen(3,ia) , zn(ia)
    enddo

!	Basis set
    i = 0
    read(10) lsto	! .true. means STO basis, .false. means GTO basis
    if (lsto) then
        allocate(ngini(ncen), stat = ierr)
        if (ierr .ne. 0) call error(1,'Memory error when allocating ngini. Stop')
!		Reads basis set data to dummies
        i = 0
        ncenbas = 0
        do ia = 1, ncen
            read(10) ngini(ia), ngfindummy
            if (ngini(ia) .le. 0) cycle
            ncenbas = ncenbas + 1
            do k = ngini(ia), ngfindummy
                i = i + 1
                read(10) nfdummy, nndummy, lldummy, xxdummy
            enddo
        enddo
    else
        read(10) nprimitot
        allocate(ngini(ncen), stat = ierr)
        if (ierr .ne. 0) call error(1,'Memory error when allocating ngini. Stop')
!		Reads basis set data to dummies
        indng = 1
        ncenbas = 0
        do ia = 1, ncen
            read(10) ndummy
            if (ndummy .le. 0) then
                ngini(ia) = -1
                cycle
            endif
            ncenbas = ncenbas + 1
            ngini(ia) = indng
            indng = indng + ndummy
            do j = 1, ndummy
                read(10) nndummy, lldummy
                read(10) (xxdummy, k = 1, nndummy)
                read(10) (xxdummy, k = 1, nndummy)
            enddo
        enddo
    endif

!	Data of density representation
    read(10) lmaxexp
    if (lmaxrep .gt. lmaxexp) then
        write(6,"('lmaxrep = ', i3, ' greater than lmaxexp ', i3)") lmaxrep, lmaxexp
        write(6,"('takes lmaxrep = ',i3)") lmaxexp
            lmaxrep = lmaxexp
    endif
    lmtop = (lmaxexp+1)*(lmaxexp+1)
    write(6,"('Electric field from expansion of the density: lmaxrep = ', i3)") lmaxrep
    if (longoutput) write(6,"('lmaxexp = ', i2, ' nintervaj = ', i2)") lmaxexp, nintervaj

    allocate(icfposd(lmtop*nintervaj+1,ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating icfposd. Stop')
    if (longoutput) write(6,"('Size of icfposd   = ', i15, ' bytes')") size(icfposd)

    if (longoutput) write(6,"('radii of fitting intervals: ',/, 8(1x,e17.10))") rinterv
    icfposd = 0
    xajustd = cero
    cfajust = cero
    k = 0
    do ia = 1, ncen      ! Do over centers
        if (ngini(ia) .le. 0) cycle
        read(10) icfposd(1:lmtop*nintervaj+1,ia)
        if (k .gt. 0) then
            icfposd(1:lmtop*nintervaj+1,ia) = icfposd(1:lmtop*nintervaj+1,ia) + icfposd(lmtop*nintervaj+1,k) - 1
        endif
        k = ia
        read(10) (xxdummy, i = 1, nintervaj)	! Reads xajust to dummy
!     fitting coeficients
        read(10) (xxdummy, i = icfposd(1,ia), icfposd(lmtop*nintervaj+1,ia)-1) ! Reads cfajust to dummy
    enddo

!	Generates an auxiliary index array for determining the interval to which a given r belongs
    step = rinterv(1)
    fct = uno / step
    lenindintrv = int(rinterv(nintervaj) * fct + udec)

    allocate(indintrv(lenindintrv), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating indintrv. Stop')
    if (longoutput) write(6,"('Size of indintrv   = ', i15, ' bytes')") size(indintrv)

    r = cero
    interv = 1
    do i = 1, lenindintrv-1
        r = r + step
        if (r .gt. (rinterv(interv))) interv = interv + 1
        indintrv(i) = interv
    enddo
    indintrv(lenindintrv) = interv

!	Reads auxiliary integrals from file .dmqtv

    allocate(cfrint1(icfposd(lmtop*nintervaj+1,ncen)-1), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating cfrint1. Stop')
    if (longoutput) write(6,"('Size of cfrint1   = ', i15, ' bytes')") size(cfrint1)

    allocate(cfrint2l2(icfposd(lmtop*nintervaj+1,ncen)-1), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating cfrint2l2. Stop')
    if (longoutput) write(6,"('Size of cfrint2l2 = ', i15, ' bytes')") size(cfrint2l2)

    allocate(QGacum(nintervaj*lmtop,ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating QGacum. Stop')
    if (longoutput) write(6,"('Size of QGacum    = ', i15, ' bytes')") size(QGacum)

    allocate(Qgpart(nintervaj*lmtop), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating Qgpart. Stop')
    if (longoutput) write(6,"('Size of Qgpart    = ', i15, ' bytes')") size(Qgpart)

    allocate(qppart(nintervaj*lmtop), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating qppart. Stop')
    if (longoutput) write(6,"('Size of qppart    = ', i15, ' bytes')") size(qppart)

    allocate(qpacum(nintervaj*lmtop,ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating qpacum. Stop')
    if (longoutput) write(6,"('Size of qpacum    = ', i15, ' bytes')") size(qpacum)

    allocate(rlargo(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating rlargo. Stop')

    allocate(rmultip(lmtop,ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating rmultip. Stop')
    if (longoutput) write(6,"('Size of rmultip    = ', i15, ' bytes')") size(rmultip)
    cfrint1 = cero
    cfrint2l2 = cero
    QGacum = cero
    Qgpart = cero
    qppart = cero
    qpacum = cero
    rlargo = cero
    rmultip = cero
    do ia = 1, ncen      ! Do over centers
        if (ngini(ia) .le. 0) cycle
!	multipolar moments
        read(11) rmultip(1:lmtop,ia)
!	Reads the integrals:
!		Qg(la,ma,i;ia) = 
!			Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(i-1),l_i}]
!		qp(la,ma,i;ia) = 
!			Integrate[ r * fradtr[la,ma,r], {r,l_(i-1),l_i}]
!	and computes from them and stores the integrals:
!		QGacum(la,ma,i;ia) = 
!			Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,0,l_i}]
!		qpacum(la,ma,i;ia) = 
!			Integrate[ r * fradtr[la,ma,r], {r,l_(i-1),Infinity}]
!    where  ia  labels the center (atom),
        read(11) Qgpart(1:nintervaj*lmtop)
        read(11) qppart(1:nintervaj*lmtop)
        QGacum(1:lmtop,ia) = Qgpart(1:lmtop)
        do i = lmtop+1, nintervaj*lmtop, lmtop
                QGacum(i:i+lmtop-1,ia) = QGacum(i-lmtop:i-1,ia) + Qgpart(i:i+lmtop-1)
        enddo
        qpacum((nintervaj-1)*lmtop+1:nintervaj*lmtop,ia) = cero
        do i = (nintervaj-2)*lmtop+1, 1, -lmtop
                qpacum(i:i+lmtop-1,ia) = qpacum(i+lmtop:i+2*lmtop-1,ia) + qppart(i+lmtop:i+2*lmtop-1)
        enddo
!    Reads the fitting coeficients of auxiliary integrals for electrostatic potential and field
        read(11) cfrint1(icfposd(1,ia):icfposd(lmtop*nintervaj+1,ia)-1)	! Expansion coefficients of auxiliary integrals rint1
        read(11) cfrint2l2(icfposd(1,ia):icfposd(lmtop*nintervaj+1,ia)-1)	! Expansion coefficients of auxiliary integrals rint2l2
    enddo
    close(10)
    close(11)

!	Determines the long-range radii and the highest l in the expansion for each interval
    allocate(lcorto(nintervaj,ncen), llargo(0:mxlargo,ncen), Qllargo(0:lmaxrep), stat = ierr )
    if (ierr .ne. 0) call error(1,'Memory error when allocating lcorto, llargo and Qllargo. Stop')
    if (longoutput) write(6,"('Size of lcorto   = ', i15, ' bytes')") size(lcorto)
    if (longoutput) write(6,"('Size of llargo   = ', i15, ' bytes')") size(llargo)
    if (longoutput) write(6,"('Size of Qllargo   = ', i15, ' bytes')") size(Qllargo)
!	long-range radii
    allocate(umedpow(0:lmaxexp), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating umedpow in consta. Stop')
    umedpow(0) = uno							!
    do i = 1, lmaxexp							!
        umedpow(i) = umedpow(i-1) * umed			! 1 / 2^i
    enddo
    write(6,"('Long-range threshold = ', e12.5)") umbrlargo
    nsamples = 4
    do ia = 1, ncen
        rlargo(ia) = cero
        if (ngini(ia) .le. 0) cycle
        kntlm = 0
        do l = 0, lmaxrep
            summ1 = cero
            do m = -l, l
                kntlm = kntlm + 1
                summ1 = summ1 + abs(rmultip(kntlm,ia)) * fact(l+abs(m)) * umedpow(abs(m)) &
                                        * facti(l-abs(m)) * facti(abs(m))
            enddo
            Qllargo(l) = summ1
        enddo
        rlargo(ia) = rinterv(nintervaj)
        lcorto(1:nintervaj,ia) = 0
        do interv = 1, nintervaj
            dltsample = udec * (rinterv(interv) - rinterv(interv-1))
            do i = 0, nsamples-1	! samples over nsamples points in each interval to decide the highest l
                ra = rinterv(interv-1) + dltsample + (rinterv(interv) - rinterv(interv-1) - dos * dltsample) &
                        * ri(nsamples-1) * re(i)
                t = dos * (ra - rinterv(interv-1))/(rinterv(interv)-rinterv(interv-1)) - uno
                dost = t + t
                tcheb(0) = uno	! Chebyshev T  polynomials
                tcheb(1) = t
                do j = 2, mxlenpol-1
                    tcheb(j) = dost * tcheb(j-1) - tcheb(j-2)
                enddo
                lm = 0
                rainv = uno / ra
                ral = uno
                ral1inv = rainv
                suml1 = cero
                suml2 = cero
                do l = 0, lmaxrep
                    pi4d2l1 = cuatro * pi * dosl1i(l)
                    summ2 = cero
                    do m = -l, l
                        lm = lm + 1
                        if(abs(QGacum((nintervaj-1)*lmtop+lm,ia)) .lt. umbrlargo) cycle
                        icflm = icfposd((interv-1)*lmtop+lm,ia)
                        rinta = cero
                        rintb = cero
                        do j = 0, icfposd((interv-1)*lmtop+lm+1,ia)-icflm-1
                            rinta = rinta + cfrint2l2(icflm+j) * tcheb(j)
                            rintb = rintb + cfrint1(icflm+j) * tcheb(j)
                        enddo
                        rinta = rinta * (ra-rinterv(interv-1))
                        if (interv .gt. 1) rinta = QGacum((interv-2)*lmtop+lm,ia) + rinta
                        rintb = qpacum((interv-1)*lmtop+lm,ia) + rintb * (rinterv(interv)-ra)
                        summ2 = summ2 + abs(pi4d2l1 * ( ral1inv * rinta + ral * rintb)) * fact(l+abs(m)) &
                                * umedpow(abs(m)) * facti(l-abs(m)) * facti(abs(m))
                    enddo
                    suml1 = suml1 + Qllargo(l) * ral1inv
                    suml2 = suml2 + summ2
                    if (abs(summ2) .gt. umbrlargo .and. l .gt. lcorto(interv,ia)) lcorto(interv,ia) = l
                    if (abs(suml2-suml1) .gt. umbrlargo) rlargo(ia) = rinterv(interv)
                    ral = ral * ra
                    ral1inv = ral1inv * rainv
                enddo
            enddo
        enddo
        if (longoutput) then
            write(6,"('Long-range radius for center ',i4,' (',a2,') = ', e12.5, ' lcorto = ', 30(i3))") &
                        ia, atmnms(nzn(ia)), rlargo(ia), lcorto(1:nintervaj,ia)
        else
            write(6,"('Long-range radius for center ',i4,' (',a2,') = ', e12.5)") ia, atmnms(nzn(ia)), rlargo(ia)
        endif
        llargo(0,ia) = lcorto(1,ia)
        do i = 1, mxlargo
            ra = re(i)
            rainv = uno / ra
            ral1inv = rainv
            kntlm = 0
            do l = 0, lmaxrep
                summ1 = cero
                do m = -l, l
                    kntlm = kntlm + 1
                    summ1 = summ1 + abs(rmultip(kntlm,ia)) * fact(l+abs(m)) * umedpow(abs(m)) * facti(l-abs(m)) * facti(abs(m))
                enddo
                Qllargo(l) = summ1 * ral1inv
                ral1inv = ral1inv * rainv
            enddo
            llargo(i,ia) = 0
            suml1 = cero
            do l = lmaxrep, 0, -1
                suml1 = suml1 + Qllargo(l)
                if (suml1 .gt. umbrlargo) then
                    llargo(i,ia) = l
                    exit
                endif
            enddo
        enddo
        write(6,"('llargo: ', 51(i3))") llargo(0:mxlargo,ia)
    enddo
    deallocate (Qgpart, qppart, umedpow)
    return
    end
!**********************************************************************
!    subroutine consta
!
!	Computes and stores auxiliary constants
!		re(i) = dfloat(i)
!		ri(i) = 1.d0 / dfloat(i)
!		fact(i) = dfloat(i!)
!		facti(i) = 1.d0 / dfloat(i!)
!		facts(i) = dfloat((i+1/2)!)
!		ind(i) = i*(i+1)/2
!    	ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m) 
!			/ (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
!
!**********************************************************************
  subroutine consta
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE DAMFIELD320_D
    implicit none
    integer(KINT) :: i
!	auxiliary parameters and functions
    pi = acos(-uno)
    raizpi = sqrt(pi)
    re(0) = cero
    ri(0) = 1.d300
    dosl1(0) = uno
    dosl1i(0) = uno
    do i = 1, mxreal
        re(i) = re(i-1) + uno        ! dfloat(i)
        re(-i) = -re(i)
        ri(i) = uno / re(i)       	! uno / dfloat(i)
        ri(-i) = -ri(i)
        dosl1(i) = re(i) + re(i) + uno	! dfloat(i√¨)
        dosl1(-i) = -re(i) - re(i) + uno
        dosl1i(i) = uno / dosl1(i)		! dfloat( 1/(i+i+1) )
        dosl1i(-i) = -dosl1i(i)
    enddo
    fact(0) = uno
    facti(0) = uno
    do i = 1, mxfact
        fact(i) = fact(i-1) * re(i)   		!  i!
        facti(i) = uno / fact(i)     		!  uno / i!
    enddo
    return
    end
!
!	-------------------------------------------------------------------------------------------------------
!
  subroutine error(ierr, msg)
    USE DAM320_D
    implicit none
    integer(KINT) :: ierr
    character(*) :: msg
    write(6,"(a)") msg
    write(6,"('Error code = ', i4)") ierr
    stop
    end
