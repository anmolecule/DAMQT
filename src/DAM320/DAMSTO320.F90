!  Copyright 2013-2021, Jaime Fernandez Rico, Rafael Lopez, Ignacio Ema,
!  Guillermo Ramirez, Anmol Kumar, Sachin D. Yeole, Shridhar R. Gadre
! 
!  This file is part of DAM320.
! 
!  DAM320 is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation, either version 3 of the License, or
!  (at your option) any later version.
! 
!  DAM320 is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
! 
!  You should have received a copy of the GNU General Public License
!  along with DAM320.  If not, see <http://www.gnu.org/licenses/>.
!
!------------------------------------------------------------------------
! 
! Program for the analytical representation of the molecular density in terms of atomic fragments, these latter given as expansions
! of spherical harmonics times radial factors.
! 
! The program fits the radial factors to piecewise functions.
!
! Every piece of the radial factors consist of Chebyshev T polynomials of the variable
! 
!      t = 2 (r - l0) / (l1 - l0) - 1
!
! where l0 and l1 are the lower and upper boundaries of the corresponding interval of r. 
!
! The polynomials can be (optionally) multiplied by exponentials of minus a given exponent times r
!
! The intervals with exponentials are user-defined and the exponents can be supplied in the input or dynamically fitted
!
! The coefficients of the polynomials are computed by least-squares fitting to a given set of points (projection)
!
! It also computes the auxiliary integrals for the electrostatic potential and electric field.
!
! Data can be read from standard input data alone (general input: lgeninp = .true.)
! or from standard input and the files generated by SMILES (default):
!    *.sgbs with geometry and basis set  and   *.den  with the density matrix.
!
! Requires file DAM320_GLOBAL.F90 which must be compiled first (contains the modules)
!
! Version of April 2019
!
  program DAM320
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE DAM320_LEGENDRE_D
    implicit none
    integer(KINT) :: i, ia, ierr, j, k, kj, knt, kntlm, l, la, m, ma
    real(KREAL) :: aux, qe, qn, qt, rant
    logical :: leg35, lprint, lsgbs, lsgbsgz
    real(KREAL4) :: tarray(2), tiempo, dtime
    real(KREAL) :: qlm((mxmult+1)**2), qlmnuc((mxmult+1)**2)
    namelist / options / ipmax, ioptaj, iswindows, leg35, lmaxexp, lm2c, lmultmx, longoutput, lvalence, lzdo &
        , umbral, umbralres, thresoverlap, wthreshold
    tiempo = dtime(tarray)
!    Defaults for the NAMELIST OPTIONS
    longoutput = .false.    ! If .true. a more detailed output is given
    lvalence = .false.      ! If .true. only valence electrons are considered
    lzdo = .false.          ! If .true. ZDO approximation holds
    lmaxexp = 10            ! Highest value of  l  in the expansion
    lm2c = .false.          ! If .true. read data from a calculation with m2c
    lmultmx = 5             ! highest l of multipoles whose modules are stored
    ioptaj = 1              ! 1: fits the total density  (default)
                            ! 2: fits the one-center part of the density
                            ! 3: fits the two-center part of the density
    umbral = 1.d-12         ! Threshold for neglecting radial factors
    umbralres = 1.d-12      ! Threshold for truncating radial factors expansions
    leg35 = .false.         ! if .true. uses a Legendre quadrature rule with 35 points for the B integrals
                            ! if .false.  uses a Legendre quadrature rule with 25 points for the B integrals  (default)
                            ! (Obsolescent. Kept only for testing)
    ipmax = 20              ! length of the expansion of the B integrals in subroutine frgsigma
    thresoverlap = 1.d-12   ! Threshold for distributions neglect
    wthreshold = 200        ! Threshold for B integrals (see Avk subroutine)
    iswindows = .false.     ! .true. if running on a MS-windows system
!    End of Defaults for the NAMELIST OPTIONS

    nqleg = 25          ! Default Legendre quadrature length for numerical integration of B integrals (Obsolescent)
    u => uleg25         ! Default pointer initialization for Legendre quadrature abscissae (Obsolescent)
    w => wleg25         ! Default pointer initialization for Legendre quadrature weights (Obsolescent)

    read(5,OPTIONS)     !    Reads the namelist OPTIONS
    read(5,*) projectname
    write(6,"(1x,'project name : ',a,/,1x,'==============')") trim(projectname)

    if (iswindows) then
        dirsep = "\\"
        i = index(projectname,dirsep,.true.)    ! Checks position of last directory name separator
        if (i .eq. 0) then    ! This is intended for MinGW, whose directory separator in windows is also /
            dirsep = "/"
            i = index(projectname,dirsep,.true.)    ! Checks position of last directory name separator
        endif
    else
        dirsep = "/"
        i = index(projectname,dirsep,.true.)    ! Checks position of last directory name separator
    end if

    if (lzdo) then
        write(6,"(/'IMPORTANT: ZDO approximation used, fits one-center part of density',/)")
        ioptaj = 2
    endif

    if (ipmax .gt. mxsigexp) then
        write(6,"('Length of expansion of B integrals: ', i3,' higher than maximum allowed: ', i3)") ipmax, mxsigexp
        write(6,"('Sets it to maximum allowed value')")
        ipmax = mxsigexp
    endif

    if (leg35) then    ! Legendre quadrature rule with 35 points    ! (Obsolescent)
        nqleg = 35    ! (Obsolescent)
        u => uleg35    ! (Obsolescent)
        w => wleg35    ! (Obsolescent)
    endif


    mxltot = mxldst + lmaxexp
    mxtpw = 2*lmaxexp+mxlenpol+3

    call consta1    !    Computes and stores several auxiliary constants and functions

    allocate(av(0:2*mxn+4*mxl), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating av. Stop')
    allocate(bv(0:2*mxn+4*mxl), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating bv. Stop')

!    Reads geometry, basis set and density matrix generated by an external program
!    Checks if files .sgbs or .sgbs.gz and .den or .den.gz exist. If yes, read geometry, basis set and density with subroutine leedamm2c
!        otherwise read them with subroutine leedatgen
    lsgbs = .false.
    lsgbsgz = .false.
    inquire(file=trim(projectname)//".sgbs", exist=lsgbs, iostat=ierr)
    if (ierr .ne. 0 .or. .not. lsgbs) then
        inquire(file=trim(projectname)//".sgbs.gz", exist=lsgbs, iostat=ierr)
        if (ierr .eq. 0 .and. lsgbs) then
            call system ("gunzip "//trim(projectname)//".sgbs.gz")
            lsgbsgz = .true.
        endif
    endif
    lden = .false.
    ldengz = .false.
    if (lsgbs) then
        inquire(file=trim(projectname)//".den", exist=lden, iostat=ierr)
        if (ierr .ne. 0 .or. .not. lden) then
            inquire(file=trim(projectname)//".den.gz", exist=lden, iostat=ierr)
            if (ierr .eq. 0 .and. lden) then
                call system ("gunzip "//trim(projectname)//".den.gz")
                ldengz = .true.
            endif
        endif
    endif
    lm2c = lsgbs .and. lden
    if (lm2c) then
        call leedatm2c        ! Reads input from SMILES files
    else        ! Reads input from general input file
        call leedatgen
    endif
    if (lzdo) then
        lmaxexp = 2*lmaxbase
        lmtop = (lmaxexp+1)*(lmaxexp+1)
        lmultmx = min(lmultmx,lmaxexp)
    endif
    lmtop = (lmaxexp+1)*(lmaxexp+1)
    if (ldengz) then    ! restores files back to their original gzipped status
        call system ("gzip "//trim(projectname)//".den")
    endif
    if (lsgbsgz) then
        call system ("gzip "//trim(projectname)//".sgbs")
    endif

!    writes geometry in .xyz file for gOpenMol compatibility
!
    open(99,file=trim(projectname)//".xyz",form='formatted', iostat=ierr)
    if (ierr .ne. 0) then
        write(6,"('Cannot open file ', a)") trim(projectname)//".xyz"
    else
        write(99,*) ncen
        write(99,*)
        do i = 1 , ncen
                write(99,"(a2,3f15.10)") atmnms( int(zn(i)) ), (rcen(j,i)*0.529177249d0,j=1,3)
        end do
        close(99)
    endif

    if (ioptaj .eq. 1) then    ! Case 1: fits the total density
        write(6,"(/,'Fits the total density',/)")
    elseif (ioptaj .eq. 2) then     ! Case 2: fits only the one-center part
        write(6,"(/,'Fits only the one-center terms of the density',/)")
    else                        ! Case 3: fits only the two-center part
        write(6,"(/,'Fits only the two-center terms of the density',/)")
    endif

!    Piecewise fitting of the radial factors and calculation of multipolar moments
    call ajusta

!    Computes the total molecular multipolar moments from the atomic moments directly computed
    call multmolec(qlm, qlmnuc)
    if (lvalence) then
        write(6,"(/12x, ' molecular multipole components (nuclei+core electrons, valence electrons, total)', /1x, 100('='))")
    else
        write(6,"(/12x, ' molecular multipole components (nuclei, electrons, total)', /1x, 100('='))")
    endif
    kntlm = 0
    do l = 0, mxmult
        write(6,"(/57x,'L = ', i2,/57x,6('='),/)") l
        do m = -l, l
            kntlm = kntlm + 1
            qn = qlmnuc(kntlm)
            if (abs(qn) .lt. 1.d-15) qn = cero
            qe = qlm(kntlm)
            if (abs(qe) .lt. 1.d-15) qe = cero
            qt = qlm(kntlm)+qlmnuc(kntlm)
            if (abs(qt) .lt. 1.d-15) qt = cero
            write(6,"(5x,'q(',i2,',',i3,'): ',8x,3(2x,d22.15))") l, m, qn, qe, qt
        enddo
    enddo

    tiempo = dtime(tarray)
    write(6,"(1x,'Timing in seconds (user, system, total):',/5x,'(',e12.5,',',e12.5,',',e12.5')')") &
            tarray(1), tarray(2), tarray(1)+tarray(2)
!     write(6,"('kmltan = ', i10, ' kmltquad = ', i10)") kmltan, kmltquad
    stop
    end


!
!    ***************************************************************
!
  subroutine leedatm2c
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    integer(KINT) :: i, ia, ib, igrespec, ierr, indgr, iopsim, ios, ivclass, ivopsim, j, k, m2cmxcap, m2cmxfun, m2cmxcen
    integer(KINT) :: nbasis, nclassgr, numelem
    real(KREAL) :: rab, repnuc, umbrznm2c, vchar, vchari
    character(6) grupo
    character(5) repirred
    logical lcmplxgr, ldst, lgrespec
    real(KREAL) :: rijk(3,3)
!    Reads the geometry and basis set (actually, it reads more data than required, because of the format of the *.sgbs file
!    generated by SMILES. These "extra" data are just skipped)
    open(15,file=trim(projectname)//".sgbs",form='unformatted', iostat=ierr)
    if (ierr .ne. 0) call error(1,'Cannot open file '//trim(projectname)//'.sgbs. Stop')
    rewind(15)
    read(15) umbrznm2c
    if (longoutput) write(6,"('umbrznm2c = ', e22.15)") umbrznm2c
    read(15) m2cmxcap, m2cmxfun, m2cmxcen
    if (longoutput) write(6,"('m2cmxcap, m2cmxfun, m2cmxcen = ', 3(1x,i8))")  m2cmxcap, m2cmxfun, m2cmxcen
!    Checks the compatibility of some dimensions with those of SMILES
    if (m2cmxcen .ne. mxcen) then
        write(6,"('WARNING: Parameter  mxcen  has different values in module DAM320_D than in smiles')")
        write(6,"('Value in DAM320_D = ',i5)") mxcen
        write(6,"('Value in SMILES = ',i5,/)") m2cmxcen
    endif
    read(15) ncen
    write(6,"('ncen = ', i3)") ncen
    read(15) nbas, ncaps
    read(15) repnuc
    write(6,"('Nuclear repulsion = ', e22.15)") repnuc
    write(6,"('Number of basis functions = ', i8)") nbas
    write(6,"('Number of function shells = ', i8)") ncaps
    call flush(6)

!    Allocates memory for geometry and basis set

    if (ierr .ne. 0) call error(1,'Cannot open file.'//trim(projectname)//'.sgbs. Stop')
    allocate(atmnam(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating atmnam. Stop')

    allocate(ll(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating ll. Stop')

    allocate(lmaxc(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating lmaxc. Stop')

    allocate(nf(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating nf. Stop')

    allocate(ngini(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating ngini. Stop')

    allocate(ngfin(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating ngfin. Stop')

    allocate(nn(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating nn. Stop')

    allocate(nzn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating nzn. Stop')

    allocate(rcen(3,ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating rcen. Stop')

    allocate(rnor(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating rnor. Stop')

    allocate(xx(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating xx. Stop')

    allocate(zn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating zn. Stop')

!    Reads the basis set
    lmaxbase = 0
    i = 0
    do ia = 1, ncen
        read(15) ngini(ia), ngfin(ia)
        lmaxc(ia) = 0
        if (ngini(ia) .le. 0) cycle
        do k = ngini(ia), ngfin(ia)
            i = i + 1
            read(15) nf(i), nn(i), ll(i), xx(i), rnor(i)
            if (ll(i) .gt. lmaxbase) lmaxbase = ll(i)
            if (ll(i) .gt. lmaxc(ia)) lmaxc(ia) = ll(i)
        enddo
    enddo
    if (lmaxbase .gt. mxl) then
        write(6,"('Basis functions with not allowed values of  l. ')")
        write(6,"('Highest allowed value: ', i2 , ' Highest value in basis set: ', i2)") mxl, lmaxbase
        call error(1,' Stop')
    endif
    do i = 1, 3
        read(15) rijk(i,1), rijk(i,2), rijk(i,3)
    enddo
!    Reads the geometry and nuclear charges
    do ia = 1, ncen
        read(15) rcen(1,ia), rcen(2,ia), rcen(3,ia), zn(ia)
        if (abs(zn(ia)-re(int(zn(ia) + umbrzn))) .gt. umbrzn) then
            nzn(ia) = 0
        else
            nzn(ia) = int(zn(ia) + umbrzn)
        endif
        atmnam(ia) = atmnms(nzn(ia))
    enddo
    close(15)
    call consta2
!    Marks the blocks of negligible charge distributions the matrix in array lsdisf 
    if (ioptaj .ne. 2) then
        allocate(lsdisf(ncaps,ncaps), stat = ierr)
        if (ierr .ne. 0) call error(1,'Memory error when allocating lsdisf. Stop')
        do ia = 1, ncen
            do ib = 1, ia-1
                rab = sqrt((rcen(1,ia)-rcen(1,ib))**2+(rcen(2,ia)-rcen(2,ib))**2+(rcen(3,ia)-rcen(3,ib))**2)
                do i = ngini(ia), ngfin(ia)
                    do j = ngini(ib), ngfin(ib)
                        call abintegs(nn(i), ll(i), xx(i), nn(j), ll(j), xx(j), rab)
                        call testoverlap(nn(i)-ll(i), ll(i), xx(i), rnor(i), nn(j)-ll(j), ll(j), xx(j), rnor(j), rab, ldst)
                        lsdisf(i,j) = ldst
                        lsdisf(j,i) = ldst
                    enddo
                enddo
            enddo
            do i = ngini(ia), ngfin(ia)
                do j = ngini(ia), i
                    lsdisf(i,j) = ldst
                    lsdisf(j,i) = ldst
                enddo
            enddo
        enddo
    endif

!    Allocates the array containing the density matrix
    allocate(dmat(nbas,nbas), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating dmat. Stop')
    if (longoutput) write(6,"('Estimated highest size of dmat   = ', i15, ' bytes')") size(dmat)

!    Reads the density matrix as written by the direct minimization program of SMILES
    open(16,file=trim(projectname)//".den",form='unformatted', iostat=ierr)
    if (ierr .ne. 0) call error(1,'Cannot open file '//trim(projectname)//'.den. Stop')
    read(16, iostat = ios) nbasis, ((dmat(i,j), i=1,nbasis), j=1,nbasis)

    if ( ios .ne. 0 .or. nbas .ne. nbasis ) then
            write(6,"('ERROR reading density matrix. Check whether the density matrix correspond to this basis set.')")
            call error(1,' Stop')
    endif
    close(16)

!    prints out the input data to standard output
    write(6,"(/24x,'GEOMETRY (BOHR)')")
    write(6,"(/t1, ' no. of center:', t20, 'x', t32, 'y', t44, 'z', t56, 'charge', t68, 'n. of shells')")
    do ia = 1, ncen
        if (ngini(ia) .gt. 0) then
            write(6,"(t4, i5, t13, f12.7, t25, f12.7, t37, f12.7, t51, f10.5, t73, i3)") &
                    ia, rcen(1,ia), rcen(2,ia), rcen(3,ia) , zn(ia), ngfin(ia)-ngini(ia)+1
        else
            write(6,"(t4, i5, t13, f12.7, t25, f12.7, t37, f12.7, t51, f10.5, t73, i3)") &
                    ia, rcen(1,ia), rcen(2,ia), rcen(3,ia) , zn(ia), 0
        endif
    enddo
    if (longoutput) then
        write(6,"(27x,'STO BASIS SET')")
        write(6,"(/t1,' shell:',t13,'n',t25,'l',t43,'exp',t60,'rnor')")
        do i = 1, ncaps
            write(6,"(t2, i3, t12, i2, t23, i3, t38, f12.7, t55, d17.10)") i, nn(i), ll(i), xx(i), rnor(i)
        enddo
    endif
    write(6,"('Number of basis functions = ', i8)") nbas

    call totalchargeSTO        ! Total electron charge from density

    return
    end
!
!    ***************************************************************
!
  subroutine leedatgen
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    integer(KINT) :: i, ia, ib, ierr, indnf, iunit, j, k, nbasis, ngi, ngf
    integer(KINT), allocatable :: nshells(:)
    logical :: ldst, lsgbs, lsgbsden, lsgbsdengz
    real(KREAL) :: rab

!     Checks if file .sgbsden or .sgbsden.gz exist. If yes, read geometry, basis set and density from it. Otherwise,
!     read these data from standard input.
    lsgbsden = .false.
    lsgbsdengz = .false.
    inquire(file=trim(projectname)//".sgbsden", exist=lsgbsden, iostat=ierr)
    if (ierr .ne. 0 .or. .not. lsgbsden) then
        inquire(file=trim(projectname)//".sgbsden.gz", exist=lsgbsden, iostat=ierr)
        if (ierr .eq. 0 .and. lsgbsden) then
            call system ("gunzip "//trim(projectname)//".sgbsden.gz")
            lsgbsdengz = .true.
        endif
    endif
    if (lsgbsden) then
        iunit = 17
        open(iunit,file=trim(projectname)//".sgbsden",form='formatted', iostat=ierr)
        if (ierr .ne. 0) then
            iunit = 5
        endif
    else
        iunit = 5
    endif

!    Reads the number of centers
    read(iunit,*) ncen

!    Allocates memory for geometry and basis set
    ncaps = mxcap ! just for allocating

    allocate(atmnam(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating atmnam. Stop')

    allocate(ll(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating ll. Stop')

    allocate(lmaxc(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating lmaxc. Stop')

    allocate(nf(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating nf. Stop')

    allocate(ngini(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating ngini. Stop')

    allocate(ngfin(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating ngfin. Stop')

    allocate(nzn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating nzn. Stop')

    allocate(nshells(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating nshells. Stop')

    allocate(rcen(3,ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating rcen. Stop')

    allocate(zn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating zn. Stop')

    allocate(xx(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating xx. Stop')

    allocate(rnor(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating rnor. Stop')

    allocate(nn(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating nn. Stop')

!    Reads geometry, nuclear charge and number of function shells per center

    ncaps = 0
    do ia = 1, ncen
        read(iunit,*) rcen(1,ia), rcen(2,ia), rcen(3,ia), zn(ia), nshells(ia)
        if (nshells(ia) .le. 0) cycle
        if (ncaps + nshells(ia) .gt. mxcap) call error(1,'Error: maximum number of shells in basis set exceeded. Stop')
        if (abs(zn(ia)-re(int(zn(ia) + umbrzn))) .gt. umbrzn) then
            nzn(ia) = 0
        else
            nzn(ia) = int(zn(ia) + umbrzn)
        endif
        atmnam(ia) = atmnms(nzn(ia))
        ncaps = ncaps + nshells(ia)
    enddo

!    Reads the basis set

    lmaxbase = 0
    nbas = 0
    i = 0
    ngi = 1
    ngf = 0
    indnf = 1
    do ia = 1, ncen
        if (nshells(ia) .gt. 0) then
            ngini(ia) = ngi
            ngf = ngi + nshells(ia) - 1
            ngfin(ia) = ngf
            ngi = ngf + 1
            lmaxc(ia) = 0
            do k = ngini(ia), ngfin(ia)
                i = i + 1
                read(iunit,*) nn(i), ll(i), xx(i)
                rnor(i) = sqrt( (dos*xx(i))**(2*nn(i)+1) / fact(2*nn(i)) )
                nf(i) = indnf
                indnf = indnf + 2*ll(i) + 1
                nbas = nbas + 2*ll(i) + 1
                if (ll(i) .gt. lmaxbase) lmaxbase = ll(i)
                if (ll(i) .gt. lmaxc(ia)) lmaxc(ia) = ll(i)
            enddo
        else
            ngini(ia) = -1
            ngfin(ia) = -1
        endif
    enddo

    if (lmaxbase .gt. mxl) then
        write(6,"('Basis functions with not allowed values of  l. ')")
        write(6,"('Highest allowed value: ', i2 , ' Highest value in basis set: ', i2)") mxl, lmaxbase
        call error(1,' Stop')
    endif
    nbasis = nbas

!    Allocates the array containing the density matrix

    allocate(dmat(nbas,nbas), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating dmat. Stop')
    if (longoutput) write(6,"('Estimated highest size of dmat   = ', i15, ' bytes')") size(dmat)

!    Reads the density matrix in lower triangle form:  read ((dmat(i,j), j = 1, i), i = 1, nbasis)

    read(iunit,*) ((dmat(i,j),j=1,i),i=1,nbasis)
    do i = 2, nbasis
        do j = 1, i-1
            dmat(j,i) = dmat(i,j)
        enddo
    enddo

    if (iunit .eq. 17) then
            close(iunit)
    endif

!    Creates files ".sgbs"  and  ".den" if they don't exist for the programs of density analysis and related properties (DAMQT)

    inquire(file=trim(projectname)//".sgbs", exist=lsgbs, iostat=ierr)
    if (ierr .ne. 0 .or. .not. lsgbs) inquire(file=trim(projectname)//".sgbs.gz", exist=lsgbs, iostat=ierr)
    if (.not. lsgbs) then
        open(15,file=trim(projectname)//".sgbs",form='unformatted')
        rewind(15)
        write(15) cero
        write(15) ncaps, nbasis, mxcen
        write(15) ncen
        write(15) nbas, ncaps
        write(15) cero
        i = 0
        do ia = 1, ncen
            write(15) ngini(ia), ngfin(ia)
            if (ngini(ia) .le. 0) cycle
            do k = ngini(ia), ngfin(ia)
                i = i + 1
                write(15) nf(i), nn(i), ll(i), xx(i), rnor(i)
            enddo
        enddo
!        orientation of the original axis system in the final system (coincident: for compatibility with old codes)
        write(15) uno, cero, cero
        write(15) cero, uno, cero
        write(15) cero, cero, uno
!        Geometry and nuclear charges
        do ia = 1, ncen
                write(15) rcen(1,ia), rcen(2,ia), rcen(3,ia), zn(ia)
        enddo
!    Marks the blocks of negligible charge distributions the matrix in array lsdisf
        call consta2
        if (ioptaj .ne. 2) then
            allocate(lsdisf(ncaps,ncaps), stat = ierr)
            if (ierr .ne. 0) call error(1,'Memory error when allocating lsdisf. Stop')
            do ia = 1, ncen
                do ib = 1, ia-1
                    rab = sqrt((rcen(1,ia)-rcen(1,ib))**2+(rcen(2,ia)-rcen(2,ib))**2+(rcen(3,ia)-rcen(3,ib))**2)
                    do i = ngini(ia), ngfin(ia)
                        do j = ngini(ib), ngfin(ib)
                            call abintegs(nn(i), ll(i), xx(i), nn(j), ll(j), xx(j), rab)
                            call testoverlap(nn(i)-ll(i), ll(i), xx(i), rnor(i), nn(j)-ll(j), ll(j), xx(j), rnor(j), rab, ldst)
                            lsdisf(i,j) = ldst
                            lsdisf(j,i) = ldst
                        enddo
                    enddo
                enddo
                do i = ngini(ia), ngfin(ia)
                    do j = ngini(ia), i
                        lsdisf(i,j) = ldst
                        lsdisf(j,i) = ldst
                    enddo
                enddo
            enddo
            write(15) ((lsdisf(i,j), j = 1, ncaps), i = 1, ncaps)
        endif
        close(15)

!        Writes the density matrix to a file .den
        open(16,file=trim(projectname)//".den",form='unformatted')
        write(16) nbasis, ((dmat(i,j), i=1,nbasis), j=1,nbasis)
        close(16)
    endif
!    prints out the input data to standard output
    write(6,"(/24x,'GEOMETRY (BOHR)')")
    write(6,"(/t1, ' no. of center:', t20, 'x', t32, 'y', t44, 'z', t56, 'charge', t68, 'n. of shells')")
    do i = 1, ncen
        if (ngini(i) .gt. 0) then
            write(6,"(t4, i5, t13, f12.7, t25, f12.7, t37, f12.7, t51, f10.5, t73, i3)") &
                    i, rcen(1,i), rcen(2,i), rcen(3,i) , zn(i), ngfin(i)-ngini(i)+1
        else
            write(6,"(t4, i5, t13, f12.7, t25, f12.7, t37, f12.7, t51, f10.5, t73, i3)") &
                    i, rcen(1,i), rcen(2,i), rcen(3,i) , zn(i), 0
        endif
    enddo
    if (longoutput) then
        write(6,"(27x,'STO BASIS SET')")
        write(6,"(/t1,' shell:',t13,'n',t25,'l',t43,'exp',t60,'rnor')")
        do i = 1, ncaps
            write(6,"(t2, i3, t12, i2, t23, i3, t38, f12.7, t55, d17.10)") i, nn(i), ll(i), xx(i), rnor(i)
        enddo
    endif
    write(6,"('Number of basis functions = ', i8)") nbas
    deallocate(nshells)
    return
    end
!
!    ***************************************************************
!
!    Subroutine for the piecewise fitting of the density of an atom in a molecule. 
!        Fit is made in terms of Chebyshev polynomials either multiplied by exponentials or not (depending on intervals)
!        The variable of the Chebyshev polynomials, x, is chosen as:  
!                x = 2 * (r-r_inf) / (r_sup - r_inf) - 1
!            so that:   
!                r = (r_sup - r_inf) * (t+1)/2 + r_inf 
!            with r_inf: lower bound of interval, and r_sup: upper bound of interval
!        ioptaj .eq. 1: fits the total density
!        ioptaj .eq. 2: fits only the one-center terms of the density
!        otherwise:     fits only the two-center terms of the density
  subroutine ajusta
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    integer(KINT) :: i, i1, i2, ia, ib, ib2, ierr, ir, irinf, irshft, irsup, ishift, j
    integer(KINT) :: k, kj, kml, knt, knticf, kntlm
    integer(KINT) :: l, la, laux, lb, lenpol, lk, lm, lma, lmax, lmb, lmin, lrotar, m, ma, maxltot, mb
    integer(KINT) :: n, na, nb, nfa, nfb, nga1, nga2, ngb1, ngb2, ngb21, ngb22
    real(KREAL) :: aux, bux, cosal, cosbet, cosga, cux, den, dosx, exa, exb, expajust, fabs, factor, fmax
    real(KREAL) :: rab, rab2, rabinv, rdif, res, rn, rna, rnab, sinal, sinbet, singa, suma, tchb0, tchb1, umbralres2
    real(KREAL) :: x, xa, xab, xab2, xb, xb2, xinv, xy, ya, yab, yab2, yb, yb2, za, zab, zab2, zb, zb2, umbraux
    logical :: lprint, lmultmod
    logical, allocatable :: lskip(:)
    real(KREAL), allocatable :: faux(:), fbux(:), fk0(:), r2l2(:), r2v(:)
    real(KREAL) :: roaux(-mxl:mxl,-mxl:mxl), bvec(0:mxlenpol-1), qlm1c(0:mxldst)
    lrotar = max(lmaxbase,lmaxexp)
    umbralres2 = umbralres * umbralres

!    Allocates memory for arrays lskip
    allocate(lskip(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating lskip. Stop')

!    Allocates memory for arrays icfpos, cfajust, rmultip, rmultipfr and xajust
    allocate(icfpos(nintervaj*lmtop+1), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating icfpos. Stop')
    if (longoutput) write(6,"('Estimated highest size of icfpos   = ', i15, ' bytes')") size(icfpos)
    allocate(cfajust(lmtop * nintervaj * mxlenpol), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating cfajust. Stop')
    if (longoutput) write(6,"('Estimated highest size of cfajust   = ', i15, ' bytes')") size(cfajust)
    allocate(rmultip(max(25,lmtop),ncen), rmultipfr(lmtop,ncen), rmultipmod(0:lmultmx), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating rmultip, rmultipfr and rmultipmod. Stop')
    if (longoutput) write(6,"('Size of rmultip    = ', i15, ' bytes')") size(rmultip)
    if (longoutput) write(6,"('Size of rmultipfr    = ', i15, ' bytes')") size(rmultipfr)
    allocate(xajust(nintervaj), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating xajust. Stop')
    if (longoutput) write(6,"('Size of xajust    = ', i15, ' bytes')") size(xajust)

!    Allocates memory for arrays QGpart, qppart
    allocate(QGpart(nintervaj*lmtop), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating QGpart. Stop')
    if (longoutput) write(6,"('Size of QGpart    = ', i15, ' bytes')") size(QGpart)
    allocate(qppart(nintervaj*lmtop), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating qppart. Stop')
    if (longoutput) write(6,"('Size of qppart    = ', i15, ' bytes')") size(qppart)

!    Allocates memory for arrays dl, fa, ftab, rl, rlt
    allocate(dl(-lrotar:lrotar,-lrotar:lrotar,0:lrotar), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating dl. Stop')
    allocate(fa(npntaj,(lmaxexp + 2*lmaxbase+1)**2), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating fa. Stop')
    if (longoutput) write(6,"('Size of fa   = ', i15, ' bytes')") size(fa)
    allocate(ftab(npntaj,(max(2*lmaxbase,lmaxexp)+1)**2), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ftab. Stop')
    if (longoutput) write(6,"('Size of ftab   = ', i15, ' bytes')") size(ftab)
    allocate(rl(-lrotar:lrotar,-lrotar:lrotar,0:lrotar), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating rl. Stop')
    allocate(rlt((lrotar+1)*(2*lrotar+1)*(2*lrotar+3)/3), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating rlt. Stop')

!    Allocates memory for arrays tchvec0, tchvec1, tchvec0a, xcheb, fkvec0
    allocate(tchvec0(npntintr), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating tchvec0. Stop')
    if (longoutput) write(6,"('Size of tchvec0    = ', i15, ' bytes')") size(tchvec0)
    allocate(tchvec1(npntintr), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating tchvec1. Stop')
    if (longoutput) write(6,"('Size of tchvec1    = ', i15, ' bytes')") size(tchvec1)
    allocate(tchvec0a(npntintr), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating tchvec0a. Stop')
    if (longoutput) write(6,"('Size of tchvec0a    = ', i15, ' bytes')") size(tchvec0a)
    allocate(xcheb(npntintr), dosxcheb(npntintr), fk0(npntintr), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating xcheb, dosxcheb and fk0. Stop')
    if (longoutput) write(6,"('Size of xcheb    = ', i15, ' bytes')") size(xcheb)
    allocate(fkvec0(npntintr), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating fkvec0. Stop')
    if (longoutput) write(6,"('Size of fkvec0    = ', i15, ' bytes')") size(fkvec0)

    allocate(expvec(npntintr), expvinv(npntintr), f0(npntaj,0:mxltot), faux(npntintr), fbux(npntintr), r2l2(npntintr), &
            r2v(npntintr), residuals(nintervaj), rpntaj(npntaj), rpow(npntaj,0:2*mxn), vaux1c(npntaj,0:mxldst), stat = ierr )
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating: expvec, expvinv, f0, faux, fbux, r2l2, r2v, residuals, &
    &rpntaj, rpow, vaux1c. Stop')
    allocate(ha(npntaj,(lmaxexp+mxl+1)*(lmaxexp+mxl+1)), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ha. Stop')
    if (longoutput) write(6,"('Size of ha   = ', i15, ' bytes')") size(ha)
    allocate(r2pow(npntaj,0:(lmaxexp+3*mxl)/2), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating r2pow. Stop')
    if (longoutput) write(6,"('Size of r2pow   = ', i15, ' bytes')") size(r2pow)
    allocate(qlmdst(lmtop), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating qlmdst. Stop')
    allocate(qlmasint(lmtop), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating qlmasint. Stop')
    allocate(qlm2c(lmtop), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating qlm2c. Stop')
    if (longoutput) write(6,"('Size of qlmdst   = ', i15, ' bytes')") size(qlmdst)
    if (longoutput) write(6,"('Size of qlmasint   = ', i15, ' bytes')") size(qlmasint)
    if (longoutput) write(6,"('Size of qlm2c   = ', i15, ' bytes')") size(qlm2c)

    allocate(ymat1(npntintr,lmtop), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ymat1. Stop')
    if (longoutput) write(6,"('Size of ymat1   = ', i15, ' bytes')") size(ymat1)
    allocate(ymat2(npntintr,lmtop), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ymat2. Stop')
    if (longoutput) write(6,"('Size of ymat2   = ', i15, ' bytes')") size(ymat2)
    allocate(rintr1(lmtop), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating rintr1. Stop')
    if (longoutput) write(6,"('Size of rintr1   = ', i15, ' bytes')") size(rintr1)
    allocate(rintr2l2(lmtop), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating rintr2l2. Stop')
    if (longoutput) write(6,"('Size of rintr2l2   = ', i15, ' bytes')") size(rintr2l2)

!    opens files 'projectname'_2016.damqt and 'projectname'_2016.dmqtv to store data for the remaining programs
!    The files are unformatted. The content of 'projectname'_2016.damqt can be retrieved int a plain text file with the program
!        readdamqt.exe included in the package
#if _WIN32
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='binary', action = 'write', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when opening file '//trim(projectname)//"_2016.damqt")
    open (unit=11, file=trim(projectname)//"_2016.dmqtv", form='binary', action = 'write', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when opening file '//trim(projectname)//"_2016.dmqtv")
#elif __INTEL_COMPILER
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='binary', action = 'write', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when opening file '//trim(projectname)//"_2016.damqt")
    open (unit=11, file=trim(projectname)//"_2016.dmqtv", form='binary', action = 'write', carriagecontrol='NONE', iostat=ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when opening file '//trim(projectname)//"_2016.dmqtv")
#else
    open (unit=10, file=trim(projectname)//"_2016.damqt", form='unformatted', action = 'write', access='stream', iostat=ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when opening file '//trim(projectname)//"_2016.damqt")
    open (unit=11, file=trim(projectname)//"_2016.dmqtv", form='unformatted', action = 'write', access='stream', iostat=ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when opening file '//trim(projectname)//"_2016.dmqtv")
#endif
    if (longoutput) write(6,"('file 10 = ', a)") trim(projectname)//"_2016.damqt"
    if (longoutput) write(6,"('file 11 = ', a)") trim(projectname)//"_2016.dmqtv"
!    writes basis set to 'projectname'_2016.damqt 
    call escribebase

    write(10) lmaxexp    ! length of expansions on l of the atomic fragments

    xcheb(1:npntintr) = - cos(pi*(re(1:npntintr)-umed) * ri(npntintr))
    dosxcheb = dos * xcheb
!     Tabulation points
    do i = 1, nintervaj
        rpntaj((i-1)*npntintr+1:i*npntintr) = (rinterv(i) - rinterv(i-1)) * umed * (uno + xcheb) + rinterv(i-1)
    enddo
    rpow(1:npntaj,0) = uno
    do j = 1, 2*mxl
        rpow(1:npntaj,j) = rpow(1:npntaj,j-1) * rpntaj
    enddo

    rmultip = cero
    rmultipfr = cero

    open(19,file=trim(projectname)//".mltmod",form='formatted', iostat=ierr)
    if (ierr .ne. 0) then
        write(6,"('Cannot open file ', a)") trim(projectname)//".mltmod"
        lmultmod = .false.
    else
        write(6,"('Open file ', a)") trim(projectname)//".mltmod"
        lmultmod = .true.
    endif
    if (lvalence) then
        write(6,"(/,5x,'Non-vanishing atomic multipolar moments of electron valence (absolute value higher than 10^-10)')")
        write(6,"(5x,'defined as the coefficients that multiply the UNNORMALIZED irregular harmonics in the expansion')")
        write(6,"(5x,'of the long-range potential multiplied by sqrt((1+delta(m,0)) * (l+|m|)! / (l-|m|)!) to keep them')")
        write(6,"(5x,'rotationally invariant except in case of l = 0, in which case the valence electron charge is quoted')")
    else
        write(6,"(/,5x,'Non-vanishing atomic multipolar moments of electron cloud (absolute value higher than 10^-10)')")
        write(6,"(5x,'defined as the coefficients that multiply the UNNORMALIZED irregular harmonics in the expansion')")
        write(6,"(5x,'of the long-range potential multiplied by sqrt((1+delta(m,0)) * (l+|m|)! / (l-|m|)!) to keep them')")
        write(6,"(5x,'rotationally invariantexcept in case of l = 0, in which case the electron charge is quoted')")
    endif
    write(6,"(/3x,'  atom     la    ma  ', 13x, 'value',14x,'from radial factors' &
            ,/3x,8('-'),2x,4('-'),2x,4('-'),4x,24('-'),3x,24('-'))")
    do ia = 1, ncen    ! Do over centers (ia)
        if (ngini(ia) .le. 0) cycle    ! If center without associated basis set, cycles
!    Initializes vectors and matrices
        ftab = cero
        fa = cero
        nga1 = ngini(ia)
        nga2 = ngfin(ia)
        xa = rcen(1,ia)
        ya = rcen(2,ia)
        za = rcen(3,ia)
!    ONE-CENTER CONTRIBUTIONS
        if (ioptaj .ne. 3) then
            do i1 = nga1, nga2
                na = nn(i1)
                la = ll(i1)
                exa = xx(i1)
                rna= rnor(i1)
                nfa = nf(i1)
                do i2 = nga1, nga2
                    nb = nn(i2)
                    lb = ll(i2)
                    exb = xx(i2)
                    rn = rnor(i2) * rna
                    nfb = nf(i2)
                    lmin = abs(la-lb)
                    lmax = la + lb
                    n = na + nb - la - lb - 2
                    x = exa + exb
                    xinv = uno / x
                    qlm1c(0) = rn * cuatro * pi * fact(na+nb) * xinv**(na+nb+1)
                    do l = 1, la+lb
                        qlm1c(l) = qlm1c(l-1) * re(na+nb+l) * xinv
                    enddo
                    do ir = 1 , npntaj
                        factor = exp(-x*rpntaj(ir)) * rn
                        do l = 0, min(la,lb)
                            vaux1c(ir,l) = factor * rpow(ir,n+l+l)
                        enddo
                    enddo
                    do mb = -lb, lb
                        lmb = lb*(lb+1)+mb+1
                        doma: do ma = -la, la
                            lma = la*(la+1)+ma+1
                            aux = ang(ind(la)+abs(ma)+1) * ang(ind(lb)+abs(mb)+1) * dmat(nf(i1)+la+ma,nf(i2)+lb+mb)
                            do j = i1l1l2(lma,lmb), i2l1l2(lma,lmb)
                                if (lml1l2(j) .gt. lmtop) cycle doma
                                bux = ccl1l2(j) * aux
                                rmultip(lml1l2(j),ia) = rmultip(lml1l2(j),ia) + bux * qlm1c(llm(lml1l2(j))) &
                                        * dosl1i(llm(lml1l2(j)))
                                fa(1:npntaj,lml1l2(j)) = fa(1:npntaj,lml1l2(j)) + bux * vaux1c(1:npntaj,npl1l2(j))
                            enddo
                        enddo doma
                    enddo
                enddo
            enddo
            ftab(1:npntaj,1:(2*lmaxc(ia)+1)*(2*lmaxc(ia)+1)) = fa(1:npntaj,1:(2*lmaxc(ia)+1)*(2*lmaxc(ia)+1))
        endif
!    TWO-CENTER CONTRIBUTIONS
        if (ioptaj .ne. 2) then        ! In case ioptaj .eq. 2, only takes one-center distributions
            lskip = .false.
            do ib = 1, ncen                  ! Do over centers (ib)
                if (lskip(ib) .or. ia .eq. ib .or. ngini(ib) .le. 0) cycle        ! skips to next center ib
!                 Computes the sigma radial factors for all pairs equivalent to AB
                xb = rcen(1,ib)
                yb = rcen(2,ib)
                zb = rcen(3,ib)
!    Computes Euler angles and rotation matrices from the AB aligned axis system to the molecular system and conversely
                xab = xb - xa
                yab = yb - ya
                zab = zb - za
                rab = sqrt(xab*xab + yab*yab + zab*zab)
                if (rab .lt. 1.d-10) then
                    write(6,"('Centers ',i8,' and ',i8,' coincide. Stop')") ia, ib
                    call error(1,' Stop')
                endif
                ngb1 = ngini(ib)
                ngb2 = ngfin(ib)
                allocate(f0ab(npntaj,0:mxltot,(nga2-nga1+1)*(ngb2-ngb1+1)), stat = ierr)
                if (ierr .ne. 0) call error(ierr,'Memory error when allocating fa. Stop')
                f0ab = cero
                knt = 0
                do i1 = nga1, nga2
                    na = nn(i1)
                    la = ll(i1)
                    exa = xx(i1)
                    do i2 = ngb1, ngb2
                        knt = knt + 1
                        if (.not. lsdisf(i1,i2)) cycle    ! If the distribution is negligible, skips to next
                        nb = nn(i2)
                        lb = ll(i2)
                        exb = xx(i2)
                        call frgsigma(knt, na-la, nb-lb, lmaxexp+la+lb, exa, exb, rab)    ! Sigma part
                    enddo
                enddo

                do ib2 = ib, ncen       ! Computes the contributions to radial factors of A from all pairs of centers equivalent to AB
                    if (lskip(ib2)) cycle        ! skips to next center ib2
                    ngb21 = ngini(ib2)
                    ngb22 = ngfin(ib2)
                    xb2 = rcen(1,ib2)
                    yb2 = rcen(2,ib2)
                    zb2 = rcen(3,ib2)
!    Computes Euler angles and rotation matrices from the AB aligned axis system to the molecular system and conversely
                    xab2 = xb2 - xa
                    yab2 = yb2 - ya
                    zab2 = zb2 - za
                    xy = sqrt(xab2*xab2 + yab2*yab2)
                    rab2 = sqrt(xab2*xab2 + yab2*yab2 + zab2*zab2)
                    if (dabs(rab-rab2) .gt. 1.d-10 .or. nzn(ib) .ne. nzn(ib2) .or. (ngb2-ngb1) .ne. (ngb22-ngb21)) cycle
                    lskip(ib2) = .true.     ! Marks the center as already accounted
                    fa = cero
                    if (xy .gt. 1.d-10) then
                        sinal = yab2 / xy
                        cosal = xab2 / xy
                    else
                        sinal = cero
                        cosal = uno
                    endif
                    rabinv = uno / rab2
                    sinbet = xy * rabinv
                    cosbet = zab2 * rabinv
                    singa = cero
                    cosga = uno
                    call rotar (lrotar, cosal, sinal, cosbet, sinbet, cosga, singa)
                    knt = 0
                    do i = 0, lmaxexp    ! Stores the transpose of rl multiplied and divided by suitable normalization factors
                        do k = -i, i
                            do j = -i, i
                                knt = knt + 1
                                rlt(knt) = rl(k,j,i) * ang(ind(i)+abs(k)+1) / ang(ind(i)+abs(j)+1)
                            enddo
                        enddo
                    enddo
                    qlm2c = cero    ! Initializes qlm2c
                    knt = 0
                    do i1 = nga1, nga2
                        na = nn(i1)
                        la = ll(i1)
                        exa = xx(i1)
                        rna= rnor(i1)
                        nfa = nf(i1)
                        do i2 = ngb21, ngb22
                            knt = knt + 1
                            if (.not. lsdisf(i1,i2)) cycle    ! If the distribution is negligible, skips to next
                            nb = nn(i2)
                            lb = ll(i2)
                            exb = xx(i2)
                            nfb = nf(i2)
!    Reads the pertinent block of density matrix and rotates it to the AB aligned system. Loads the result in roblk.
!    Angular normalization factors are introduced at the end of the loading process.
                            do i = -la, la
                                ishift = i+la+nfa
                                do j = -lb, lb
                                    roblk(i,j) = dmat(ishift,j+lb+nfb)
                                enddo
                            enddo
!    Rotation on center B
                            do i = -la, la
                                do j = -lb, lb
                                    roaux(i,j) = dot_product(roblk(i,-lb:lb),rl(-lb:lb,j,lb))
                                enddo
                            enddo
!    Rotation on center A and introduction of the angular normalization
                            rnab = rna * rnor(i2) * dos
                            do i = -la, la
                                do j = -lb, lb
                                    roblk(i,j) = ang(ind(la)+abs(i)+1) * ang(ind(lb)+abs(j)+1) * rnab &
                                        * dot_product(roaux(-la:la,j), rl(-la:la,i,la))
                                enddo
                            enddo
! write(6,*) 'ia = ', ia, 'ib = ', ib2, ' i1 = ', i1, ' i2 = ', i2, ' knt = ', knt, ' fsigma = ', f0(1:5,0)
!    Computes the multipolar moments in the lined-up axis system
                            call multfrg2c(na,la,nb,lb,exa,exb,rab)
!    Loads the sigma factor
                            f0(1:npntaj,0:lmaxexp+la+lb) = f0ab(1:npntaj,0:lmaxexp+la+lb,knt)
!    Computes the two-center contributions to the tabulation of A fragment
                            call dsczazbnew(la, lb, rab)    ! Factors for La,Ma,Lb,Mb
                        enddo
                    enddo
!    Rotates the radial factors and the multipolar moments back to the molecular axis system
                    lm = 0
                    kml = 0
                    do l = 0, lmaxexp
                        do m = -l, l
                            lm = lm + 1
                            lk = l*(l+1)+1
                            do k = -l, l
                                kml = kml + 1
                                rmultip(lm,ia) = rmultip(lm,ia) + qlm2c(lk+k) * rlt(kml)
                                ftab(1:npntaj,lm) = ftab(1:npntaj,lm) + fa(1:npntaj,lk+k) * rlt(kml)
                            enddo
! write(6,*) 'ftab(', l, ',', m, ') = ', ftab(1:5,lm)
                        enddo
                    enddo
                enddo    ! End of Do over centers (ib2)
                deallocate(f0ab)
            enddo    ! End of Do over centers (ib)
        endif
!        Computes the modules of multipolar moments and stores them in file  filename.mltmod
!        Since the multipolar moments, are defined as the coefficients that multiply the unnormalized irregular spherical harmonics 
!        in the long-range potential, they are multipied here by sqrt((1+delta(m,0)) *  (l+|m|)!/(l-|m|)! ) to keep them invariant under rotations
        if (lmultmod) then
            lm = 0
            do l = 0, lmultmx
                aux = 0.d0
                do m = -l, l
                    lm = lm + 1
                    if (m .eq. 0) then
                        bux = dos
                    else
                        bux = uno
                    endif
                    aux = aux + rmultip(lm,ia) *  rmultip(lm,ia) * bux * fact(l+abs(m)) * facti(l-abs(m))
                enddo
                rmultipmod(l) = sqrt(aux)
            enddo
            write(19,"(a, 2x, i5, 2x, 6(e22.15,1x))") atmnam(ia), ia, rmultipmod(0:lmultmx)
        endif
!
!    Fits the radial factors    
!
        knticf = 1
        icfpos(1) = 1
        do i = 1, nintervaj
            irshft = (i-1) * npntintr
!            Optimizes exponent
            if (min(abs(ftab(irshft+npntintr,1)),abs(ftab(irshft+1,1))) .lt. umbral) then
                xajust(i) = cero
            else
                xajust(i) = (log(abs(ftab(irshft+npntintr,1)))-log(abs(ftab(irshft+1,1)))) &
                        / (rpntaj(irshft+1)-rpntaj(irshft+npntintr))
            endif
            if (xajust(i) .lt. uno) then
                    xajust(i) = cero
                    expvec = uno
                    expvinv = uno
            else
                    expvec = exp(rpntaj(irshft+1:irshft+npntintr) * xajust(i))
                    expvinv = uno / expvec
            endif
            kntlm = 0
            r2v = rpntaj(irshft+1:irshft+npntintr) * rpntaj(irshft+1:irshft+npntintr)
            r2l2 = uno
            do l = 0, lmaxexp
                r2l2 = r2l2 * r2v
                do m = -l, l
                    kntlm = kntlm+1
                    knticf = knticf + 1
!    Checks whether the radial factor is negligible or not. If it is, marks it and avoids fitting.
                    aux = maxval(abs(ftab(irshft+1:irshft+npntintr,kntlm)))
                    bux = maxval(abs(ftab(irshft+1:irshft+npntintr,kntlm))*r2l2)
                    cux = fact(l+abs(m)) * umedpow(abs(m)) * facti(l-abs(m)) * facti(abs(m))
                    fmax = max(aux,bux) * cux
                    if (fmax .lt. umbral) then    ! Test: is the fragment negligible ?
                        icfpos(knticf) = icfpos(knticf-1)
                    else
                        lenpol = 0
                        fk0 = ftab(irshft+1:irshft+npntintr,kntlm) * expvec
                        tchvec0 = uno
                        tchvec1 = xcheb
                        bvec(0) = sum(fk0) * ri(npntintr)
                        bvec(1) = dot_product(fk0,tchvec1) * dos * ri(npntintr)
                        fkvec0 = bvec(0) * tchvec0 + bvec(1) * tchvec1
                        if (aux .gt. bux) then
                            faux = ftab(irshft+1:irshft+npntintr,kntlm)
                            fbux = expvinv
                        else
                            faux = ftab(irshft+1:irshft+npntintr,kntlm) * r2l2
                            fbux = expvinv * r2l2
                        endif
                        do j = 2, mxlenpol-1
                            tchvec0a = tchvec0
                            tchvec0 = tchvec1
                            tchvec1 = dosxcheb * tchvec1 - tchvec0a
                            bvec(j) = dot_product(fk0,tchvec1) * dos * ri(npntintr)
                            fkvec0 = fkvec0 + bvec(j) * tchvec1
                            res = cux * cux * dot_product( ( faux - fkvec0 * fbux), (faux - fkvec0 * fbux))
                            if (res .lt. umbralres2) then
                                lenpol = j+1
                                exit
                            endif
                        enddo
                        if (lenpol .eq. 0) then
                            lenpol = mxlenpol
                        endif
                        icfpos(knticf) = icfpos(knticf-1) + lenpol
                        cfajust(icfpos(knticf-1):icfpos(knticf)-1) = bvec(0:lenpol-1)
                    endif    ! End of Test: is the fragment negligible ?
                enddo    ! End of loop on m
!                 r2l2 = r2l2 * rpntaj(irshft+1:irshft+npntintr)
            enddo        ! End of loop on l
        enddo    ! End of loop on intervals

!    Computes the atomic multipolar moments from the fit and some auxiliary integrals
        call multipolos(ia)

!    Fitting coefficients 

!    Allocates memory for arrays cfrint1, cfrint2l2
        allocate(cfrint1(icfpos(knticf)-1), cfrint2l2(icfpos(knticf)-1), stat = ierr)
        if (ierr .ne. 0) call error(1,'Memory error when allocating cfrint1 and cfrint2l2. Stop ')
        if (longoutput) write(6,"('Size of cfrint1 and cfrint2l2  = ', i15, ' bytes')") size(cfrint1)
!    Fits the auxiliary integrals 
!         rintr1(la,ma) =  Integrate[ r * fradtr[la,ma,r], {r,r0,l_k}]
!         rintr2l2 = Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(k-1),r0}]
        call fitrint(ia)
!     writes data of center ia to file 'projectname'_2016.damqt
        write(10) icfpos(1:knticf)    ! pointers to expansion coefficients of radial factors of center ia
        write(10) xajust(1:nintervaj)    ! fitting exponents
!    fitting coeficients 
        write(10) cfajust(1:icfpos(knticf)-1)    ! Expansion coefficients
!    multipolar moments
        write(11) rmultip(1:lmtop,ia)        ! multipolar moments of center ia
!    Partial integrals for electrostatic potential and field
        write(11) QGpart(1:nintervaj*lmtop)
        write(11) qppart(1:nintervaj*lmtop)
!    fitting coeficients of auxiliary integrals for electrostatic potential and field
        write(11) cfrint1(1:icfpos(knticf)-1)    ! Expansion coefficients of auxiliary integrals rint1
        write(11) cfrint2l2(1:icfpos(knticf)-1)    ! Expansion coefficients of auxiliary integrals rint2l2
        deallocate (cfrint1,cfrint2l2)

!    Prints the atomic multipolar moments directly computed and those obtained from the radial factors

        lprint = .true.
        kntlm = 0
        do l = 0, lmultmx
            do m = -l, l
                kntlm = kntlm+1
                if (m .eq. 0 .and. l .ne. 0) then
                    bux = dos
                else
                    bux = uno
                endif
                aux = sqrt(bux * fact(l+abs(m)) * facti(l-abs(m)))
                if (abs(rmultip(kntlm,ia)) * aux .gt. 1.d-10) then
                    if (lprint) then
                        write(6,"(/3x,a2, 1x, i5, 2x, i3, 3x, i3, 1x, 2(5x,e22.15))") &
                                atmnam(ia), ia, l, m, -rmultip(kntlm,ia) * aux, -rmultipfr(kntlm,ia) * aux
                        lprint = .false.
                    else
                        write(6,"(13x, i3, 3x, i3, 1x, 2(5x,e22.15))") l, m, -rmultip(kntlm,ia) * aux, &
                                -rmultipfr(kntlm,ia) * aux
                    endif
                endif
            enddo
        enddo

    enddo    ! End of Do over centers (ia)
    close(19)
    close(10)
    close(11)
    deallocate(dl, dosxcheb, expvec, expvinv, f0, fa, faux, fk0, ftab, fkvec0, ha, qlm2c, qlmasint, qlmdst, r2pow, &
            rintr1, rintr2l2, rl, rlt, rmultipmod, rpntaj, rpow, tchvec0, tchvec1, tchvec0a, vaux1c, xcheb, ymat1, ymat2)
    return
    end
!
!    ***************************************************************
!
  subroutine escribebase
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    integer(KINT) :: i, ia, ierr, j, k, knt, lm
!    Writes basis set information to file  'projectname'_2016.damqt

!    first record:
!            ncen: number of centers
!            nbas: number of basis functions
!            ncaps: number of shells in the basis set
    write(10) ncen, nbas, ncaps
!    Geometry and nuclear charges
    do i = 1, ncen
        write(10) rcen(1,i), rcen(2,i), rcen(3,i), zn(i)
    enddo
!    End of geometry and nuclear charges

!    Basis set information
    i = 0
    write(10) .true.    ! .true. means STO basis, .false. means GTO basis
    do ia = 1, ncen
        write(10) ngini(ia), ngfin(ia)    ! shell indices
        if (ngini(ia) .le. 0) cycle
        do k = ngini(ia), ngfin(ia)
            i = i + 1
            write(10) nf(i), nn(i), ll(i), xx(i)    ! Quantum numbers and exponents of the shell  i
        enddo
    enddo

!    End of basis set information

    return
    end
!
!    ---------------------------------------------------------
!
  subroutine frgsigma(knt, n, np, lmax, za, zb, Rg)
    USE DAM320_D
    USE DAM320_CONST_D, ONLY : cero, uno, dos, umed, pi, re, ri, fact, facti
    USE DAM320_DATA_D, rv => rpntaj
    implicit none
    integer(KINT) :: i, ip, jshift, k, knt, kshift, ipnt, l, lmax, m, n, np
    real(KREAL) :: auxl, a00, am10, a0m1, am1m1, arg, arg2, arg2i, aux, bk0, bk1, ci, cux, Rg, r2R2, Rg2, rp, rp2
    real(KREAL) :: sumi, sumk, sump, z2dvr2R2, zak, za, za2, za2pzb2, za2pzb2i, zai, zb, zb2, zb2i, zbnpdpi
    logical lprint
    real(KREAL) :: f0aux(0:mxltot), fbk(-(2*mxn+mxltot+2*mxsigexp+1):mxltot+2*mxsigexp+1)
    real(KREAL) :: bvec(-mxn:mxltot+2*mxsigexp+1), rppow(0:mxn), zpow(0:mxn), ak(0:mxn)
    za2 = za*za
    zb2 = zb*zb
    zb2i = uno / zb2
    zbnpdpi = zb**np / pi
    Rg2 = Rg*Rg
    za2pzb2 = za2+zb2
    za2pzb2i = uno / za2pzb2
    zai = uno / za
    zpow(0) = uno
    do i = 1, n-3
        zpow(i) = -umed * zai * zpow(i-1)     ! zpow(i) = 1/ (-2*za)**i
    enddo
    do ipnt = 1, npntaj
        rp = rv(ipnt)
        rp2 = rp*rp
        rppow(0) = uno
        do i = 1, n
            rppow(i) = rppow(i-1) * rp        ! rppow(i) = rp**i
        enddo
!    Modified Bessel functions: fbk(n) = (za^2+zb^2)**(-n) * khat(n, sqrt((za^2+zb^2)*(Rg^2+2rp^2)) )
        r2R2 = Rg2+rp2+rp2
        arg2 = za2pzb2 * r2R2
        arg = sqrt(arg2)
        arg2i = uno / arg2
        call bkhat01(arg, bk0, bk1)
        fbk(0) = bk0
        fbk(-1) = bk1 * za2pzb2i
!    Upwards recursion
        z2dvr2R2 = za2pzb2 / r2R2
        do i = 0, lmax+2*ipmax
            fbk(i+1) = z2dvr2R2 * (re(i+i) * za2pzb2i * fbk(i) + fbk(i-1))
        enddo
!    Downwards recursion
        do i = -1, -(n+np+lmax+2*ipmax),-1
            fbk(i-1) = za2pzb2i * (r2R2 * fbk(i+1) - re(i+i) * fbk(i))
        enddo
!    B_m^k integrals (multiplied by 2 )
        call Avk(za, zb, rp, Rg, a00, am10, a0m1, am1m1)
        if (mod(n,2) .eq. 1) then    ! Case of n odd
!             call bvk0(za, zb, za2, zb2, Rg2, rp, rp2, bvecm1, bvec0)
            bvec(0) = dos * a00
            if (bvec(0) .lt. 1.d-100) then
                do l = 0, lmax
                    f0ab(ipnt,l,knt) = cero
                enddo
                cycle
            endif
            bvec(-1) = dos * ( (rp2 + Rg2) * am10 + rp2 * am1m1 )
            aux = uno
            cux = uno / (Rg2+rp2)
            do m = 0, lmax+2*ipmax-1        ! Upwards recursion
                bvec(m+1) = cux * ( re(m+m+1) * bvec(m) + zb2 * bvec(m-1) - dos * fbk(m) )
            enddo
            aux = (Rg2+rp2)
            cux = uno / zb2
            do m = -1, -np+1, -1        ! Downwards recursion
                bvec(m-1) = cux * ( -re(m+m+1) * bvec(m) + aux * bvec(m+1) + dos * fbk(m) )
            enddo
            zak = uno
            do k = 0, n-3
                sumi = cero
                do i = mod(k,2), min(n-3-k,k+1), 2
                    sumi = sumi + fact(k+1+i) * facti(k+1-i) * facti(i) * rppow(n-3-k-i) * zpow(i)
                enddo
                ak(k) = sumi * zak
                zak = zak * za
            enddo
            aux = za * rppow(n-1)
            do m = lmax+2*ipmax+1, -np+1, -1
                sumk = cero
                do k = 0, n-3
                    sumk = sumk + za * ak(k) * fbk(m-k-2)
                enddo
                bvec(m) = aux * bvec(m-1) - dos * sumk
            enddo
        else                        ! Case of n even
!             call bvkm1(za, zb, za2, zb2, Rg2, rp, rp2, bvec0, bvec1)
            bvec(0) = dos * a0m1
            if (bvec(0) .lt. 1.d-100) then
                do l = 0, lmax
                    f0ab(ipnt,l,knt) = cero
                enddo
                cycle
            endif
            bvec(1) = dos * ( za2 * am10 + zb2 * am1m1 )
            aux = uno
            cux = uno / (Rg2+rp2)
            do m = 1, lmax+2*ipmax        ! Upwards recursion
                    bvec(m+1) = cux * ( re(m+m-1) * bvec(m) + zb2 * bvec(m-1) - dos * fbk(m) )
            enddo
            aux = (Rg2+rp2)
            cux = uno / zb2
            do m = 0, -np+2, -1        ! Downwards recursion
                bvec(m-1) = cux * ( -re(m+m-1) * bvec(m) + aux * bvec(m+1) + dos * fbk(m) )
            enddo
            zak = uno
            do k = 0, n-2
                sumi = cero
                do i = min(k,n-2-k), 0, -2
                        sumi = sumi + fact(k+i) * facti(k-i) * facti(i) * rppow(n-2-k-i) * zpow(i)
                enddo
                ak(k) = sumi * zak
                zak = zak * za
            enddo
            aux = rppow(n)
            do m = -np+1, lmax+2*ipmax+1
                sumk = cero
                do k = 0, n-2
                        sumk = sumk + ak(k) * fbk(m-k-1)
                enddo
                bvec(m) = aux * bvec(m) - dos * sumk
            enddo
        endif
!    Computes the n^th order derivatives of the B_m^k functions
        do l = 0, lmax
                f0aux(l) = cero
        enddo
        aux = umed * rp2 * Rg2
        ci = zbnpdpi        ! ci(i) = (-1)**i * zb**(np-2i) * np! / ( pi * (np-2i)! i! 2**i)
        do i = 0, (np/2)
            auxl = ci        ! auxl = ci * (rp*Rg/2)**l * (l+1/2) / (l+1/2)!
            do l = 0, lmax
                jshift = l+ipmax+ipmax+1+i-np
                kshift = l+l+1+ipmax+ipmax
                sump = bvec(jshift)
                do ip = 0, ipmax-2
                    sump = bvec(jshift-ip-ip-2) + aux * ri(kshift-ip-ip) * ri(ipmax-ip) * sump
                enddo
                f0aux(l) = f0aux(l) + auxl * (bvec(l+1+i-np) + aux * ri(l+l+3) * sump)
                auxl = auxl * Rg * ri(l+l+1)
            enddo
            ci = -ci * umed * re(np-i-i) * re(np-i-i-1) * ri(i+1) * zb2i
        enddo
        do l = 0, lmax
            f0ab(ipnt,l,knt) = f0aux(l)
        enddo
    enddo
    return
    end

!    ---------------------------------------------------------------------------

  subroutine dsczazbnew(la, lb, Rab)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    real(KREAL) :: aux, bux, cux, Rab
    integer(KINT) :: i, j, k, kmb, l, la, labexp, lb, lbexp, lm, lma, lmbexp, ma, mb, mba
    real(KREAL), parameter :: umbraux = 1.d-20
    real(KREAL) :: Rabpow(0:mxl)
    Rabpow(0) = uno    ! Rabpow(i) = (-Rab)**i
    do i = 1, lb
            Rabpow(i) = -Rabpow(i-1) * Rab
    enddo
    lbexp = lmaxexp+lb
    lmbexp = (lbexp+1)*(lbexp+1)
    labexp = lbexp+la
    lmtop = (lmaxexp+1)*(lmaxexp+1)
    r2pow(1:npntaj,0) = uno        ! r2pow(ir,l) = rpuntos(ir)**(2l)
    do l = 1, (labexp+max(la,lb))/2
            r2pow(1:npntaj,l) = r2pow(1:npntaj,l-1) * rpntaj(1:npntaj) * rpntaj(1:npntaj)
    enddo
    ha(1:npntaj,1:lmbexp) = cero
!    decomposes the product:  f0(l) * zlm(l,0) * zlmA(La,Ma) --> ha(lp,Ma) * zlm(lp,Ma)
    do ma = -la, la
        lma = la*(la+1)+ma+1
        dol1: do l = 0, labexp
            lm = l*(l+1) + 1
            do j = i1l1l2(lma,lm), i2l1l2(lma,lm)
                if (lml1l2(j) .gt. lmbexp) cycle dol1
                ha(1:npntaj,lml1l2(j)) = ha(1:npntaj,lml1l2(j)) + ccl1l2(j) * r2pow(1:npntaj,npl1l2(j)) * f0(1:npntaj,l)
            enddo
        enddo dol1
    enddo
!    decomposes the product:  ha(lp,Ma) * zlm(lp,Ma) * zlm(Lb,Mb) --> fa(l,m) * zlm(l,m)
!    multiplies by the density matrix and accumulates
    do mb = -lb, lb
        mba = abs(mb)
        do k = mba, lb
            bux = bin(ind(lb+mba)+k+mba+1) * Rabpow(lb-k)
            kmb = k*(k+1)+mb+1
            do ma = -la, la
                cux = bux * roblk(ma,mb)
                if (abs(cux) .lt. umbraux) cycle
                dol2: do l = abs(ma), lbexp
                    lma = l*(l+1)+ma+1
                    do j = i1l1l2(lma,kmb), i2l1l2(lma,kmb)
                        aux = cux * ccl1l2(j)
                        if (lml1l2(j) .gt. lmtop) cycle dol2
                        fa(1:npntaj,lml1l2(j)) = fa(1:npntaj,lml1l2(j)) + aux * r2pow(1:npntaj,npl1l2(j)) * ha(1:npntaj,lma)
                    enddo
                enddo dol2
            enddo
        enddo
    enddo
    return
    end

!
!   ***************************************************************
!
!    Subroutine for computing the total atomic multipolar moments and the integrals:
!        qppart(la,ma,i;ia) = 
!            Integrate[ r * fradtr[la,ma,r], {r,l_(i-1),l_i}]
!        QGpart(la,ma,i;ia) = 
!            Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(i-1),l_i}]
!     where  ia  labels the center (atom),
!     fradtr[la,ma,r]  stands for the piecewise representation
!     of the corresponding radial factor, and  (l_(i-1), l_i)  are the
!     (lower,upper) bounds of the i-th interval..
!     These integrals are useful for computing the potential,
!     field and Hellmann-Feynman forces generated by the corresponding component of 
!     the atomic electron density (see programs DAMPOT, DAMFIELD, DAMFORCES)

   subroutine multipolos(ia)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    real(KREAL) :: ai, aiinv, argdlt, argsg, aux, auxa, auxb, bux, dlt2, dlti, dosdltsg
    real(KREAL) :: pi4d2l1, rinf, rl12, rl32, rl52, rsup, sgi, sg2, suma, sumb, w, zz
    integer(KINT) :: i, i1, ia, icflm, kchb, kk, knt, kntcf, kntlm, kntq, l, l2, la, lk, m, ma, n, ntpow
    real(KREAL) :: cfpows(0:mxlenpol-1), gl(0:mxtpw+2), rint(0:mxtpw)
    if (ngini(ia) .le. 0) return
    knt = 0
    ntpow = 2*lmaxexp + 2 + mxlenpol + 1
    rinf = cero
    do i = 1, nintervaj      ! Do over intervals
        rsup = rinterv(i)
        dlti = umed * (rsup - rinf)
        sgi = umed * (rsup + rinf)
        if (xajust(i) .gt. udec) then    ! Non null exponent: computes the integrals:  Integral[dlti * t**j * Exp[-xi*r(t)],{t,-1,1}]
            argdlt = xajust(i) * dlti
            argsg = xajust(i) * sgi
            w = dlti * exp(-argsg)
!                Computes the integrals:   Int[ Exp[-argdlt * t] * LegendreP[l,t], {t,-1,1}]
!                by means of:   Int[ Exp[-z * t] * LegendreP[l,t], {t,-1,1}] = (-1)**l 2 z**l * 0F1[l+3/2,z**2/4] / (2l+1)!!
!                starting with the hypergeometrics 0F1[...] corresponding to  l = ntpow  and  l = ntpow-1
!                the remaining ones being obtained by means of:  0F1[l-1,z] = 0F1[l,z] + 0F1[l+1,z] * z / ( l (l-1) )
!                hypergeometrics 0F1[ntpow,z**2/4] and  0F1[ntpow-1,z**2/4]
            auxa = uno
            auxb = uno
            suma = uno
            sumb = uno
            ai = uno
            rl32 = ntpow + umed + uno
            rl52 = ntpow + umed + dos
            zz = pt25 * argdlt * argdlt
            do i1 = 1, 1000
                    aiinv = uno / ai
                    auxa = auxa * zz * aiinv / rl32
                    auxb = auxb * zz * aiinv / rl52
                    suma = suma + auxa
                    sumb = sumb + auxb
                    rl32 = rl32 + uno
                    rl52 = rl52 + uno
                    ai = ai + uno
                    if (auxa .lt. (1.d-15*suma) ) go to 234
            enddo
            write(6,"(/,'WARNING: The computation of the hypergeometrics 0F1 does not converge in subroutine multipolos' &
                    ,/, 'suma = ', e22.15, ' auxa = ', e22.15, ' sumb = ', e22.15, ' auxb = ', e22.15,/)") suma, auxa, sumb, auxb
234                continue
            gl(ntpow+1) = sumb
            gl(ntpow)   = suma
!                backwards recursion of the hypergeometrics 0F1
            rl32 = ntpow + umed + uno
            rl12 = ntpow + umed
            do l = ntpow, 1, -1
                gl(l-1) = gl(l) + zz * gl(l+1) / (rl32 * rl12)
                rl32 = rl12
                rl12 = rl12 - uno
            enddo
!                transforms the hypergeometrics into integrals over Legendre polynomials
            aux = dos
            do l = 0, ntpow+1
                gl(l) = aux * gl(l)
                aux = - aux * argdlt * dosl1i(l+1)
            enddo
!             transforms the integrals over Legendre polynomials into integrals over powers of  t
            rint(0) = gl(0) * w
            do l = 1, ntpow
                aux = cero
                do lk = 0, ntpow-l
                    bux = ri(lk+lk+1) * (re(lk+1) * gl(lk+1) + re(lk) * aux )
                    aux = gl(lk)
                    gl(lk) = bux
                enddo
                rint(l) = gl(0) * w
            enddo
        else        ! Null exponent: Computes the integrals: Integral[dlti * t**j,{t,-1,1}]
            aux = rsup - rinf
            do l = 0, ntpow-1, 2
                rint(l) = aux * ri(l+1)
                rint(l+1) = cero
            enddo
            if (mod(ntpow,2) .eq. 0) rint(ntpow) = aux * ri(ntpow+1)
        endif
!-------------------------------------------------------------------------------
!     Integrals:
!        qppart(la,ma,i) = Integrate[ r * fradtr[la,ma,r], {r,l_(i-1),l_i}]
!-------------------------------------------------------------------------------
        kntq = knt
        kntlm = 0
        do la = 0, lmaxexp
            do ma = -la, la
                kntlm = kntlm + 1
                kntq = kntq + 1
                if (icfpos(kntlm+(i-1)*lmtop+1) .le. icfpos(kntlm+(i-1)*lmtop)) then ! If the radial factor is null
                    qppart(kntq) = cero
                else
!                    Converts the expansion coefficients from Chebyshev T polynomials to powers
                    kchb = 0
                    cfpows = cero
                    do kk = 0, icfpos(kntlm+(i-1)*lmtop+1)-icfpos(kntlm+(i-1)*lmtop)-1
                        do n = 0, kk/2
                            kchb = kchb + 1
                            cfpows(kk-n-n) = cfpows(kk-n-n) + chebTcf(kchb) * cfajust(icfpos(kntlm+(i-1)*lmtop)+kk)
                        enddo
                    enddo
                    aux = cero
                    do kk = 0, icfpos(kntlm+(i-1)*lmtop+1)-icfpos(kntlm+(i-1)*lmtop)-1
                        aux = aux + cfpows(kk) * ( dlti*rint(kk+1) + sgi * rint(kk) )
                    enddo
                    qppart(kntq) = aux
                endif
            enddo    ! End of Do on ma
        enddo    ! End of Do on la
!     Recursion on  l  of the integrals with powers of  t  to yield integrals  with powers of  r
        dlt2 = dlti*dlti
        sg2 = sgi * sgi
        dosdltsg = dos * dlti * sgi
        kntlm = 0
        do la = 0, lmaxexp
            l2 = la+la+2
            do kk = 0, ntpow-l2
                rint(kk) = dlt2*rint(kk+2) + dosdltsg*rint(kk+1) + sg2 * rint(kk)
            enddo
!-------------------------------------------------------------------------------
!     Integrals:
!        QGpart(la,ma,i;ia) = Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(i-1),l_i}]
!-------------------------------------------------------------------------------
            pi4d2l1 = cuatro * pi * dosl1i(la)
            do ma = -la, la
                kntlm = kntlm + 1
                knt = knt + 1
                if (icfpos(kntlm+(i-1)*lmtop+1) .le. icfpos(kntlm+(i-1)*lmtop)) then ! If the radial factor is null
                    QGpart(knt) = cero
                else
!                    Converts the expansion coefficients from Chebyshev T polynomials to powers
                    kchb = 0
                    cfpows = cero
                    do kk = 0, icfpos(kntlm+(i-1)*lmtop+1)-icfpos(kntlm+(i-1)*lmtop)-1
                        do n = 0, kk/2
                            kchb = kchb + 1
                            cfpows(kk-n-n) = cfpows(kk-n-n) + chebTcf(kchb) * cfajust(icfpos(kntlm+(i-1)*lmtop)+kk)
                        enddo
                    enddo
                    aux = cero
                    do kk = 0, icfpos(kntlm+(i-1)*lmtop+1)-icfpos(kntlm+(i-1)*lmtop)-1
                        aux = aux + cfpows(kk) * rint(kk)
                    enddo
                    QGpart(knt) = aux
                    rmultipfr(kntlm,ia) = rmultipfr(kntlm,ia) + pi4d2l1 * QGpart(knt)    ! Multipolar moments from radial factors
                endif
            enddo  ! End of Do on ma
        enddo  ! End of Do on la
        rinf = rsup
    enddo   ! End of loop over intervals
    return
    end
    
!   ***************************************************************

!     Subroutine for fitting the  integrals:
!          rintr1(la,ma) = Integrate[ r * fradtr[la,ma,r], {r,r0,l_k}] ) 
!          rintr2l2(la,ma) = Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(k-1),r0}]
!     with    l_(k-1) < r0 < l_k
!     where   fradtr[la,ma,r]  stands for the piecewise representation
!     of the corresponding radial factor, and  (l_(i-1), l_i)  are the
!     (lower,upper) bounds of the i-th interval.

  subroutine fitrint(ia)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    integer(KINT) :: i, ia, j, k, knt, knticf, lm
    real(KREAL) :: rk, rkmrinfi, rsupmrki
    knticf = 0
    do i = 1, nintervaj
        do k = 1, npntintr
            rk = (rinterv(i)-rinterv(i-1)) * umed * (uno + xcheb(k)) + rinterv(i-1)
            call integfradk(i, ia, rk, xajust(i))
            rkmrinfi = uno / (rk - rinterv(i-1))
            rsupmrki = uno / (rinterv(i) - rk)
            ymat1(k,1:lmtop) = rintr1 * rsupmrki
            ymat2(k,1:lmtop) = rintr2l2 * rkmrinfi
        enddo
        do lm = 1, lmtop
            knticf = knticf + 1
            knt = icfpos(knticf)
            if ( knt .lt. icfpos(knticf+1)) then
                tchvec0 = uno
                tchvec1 = xcheb
                cfrint1(knt) = sum(ymat1(1:npntintr,lm)) * ri(npntintr)
                cfrint2l2(knt) = sum(ymat2(1:npntintr,lm)) * ri(npntintr)
                cfrint1(knt+1) = dot_product(ymat1(1:npntintr,lm), tchvec1) * dos * ri(npntintr)
                cfrint2l2(knt+1) = dot_product(ymat2(1:npntintr,lm), tchvec1) * dos * ri(npntintr)
                do j = 2, icfpos(knticf+1)-icfpos(knticf)-1
                    tchvec0a = tchvec0
                    tchvec0 = tchvec1
                    tchvec1 = dosxcheb * tchvec1 - tchvec0a
                    cfrint1(knt+j) = dot_product(ymat1(1:npntintr,lm), tchvec1) * dos * ri(npntintr)
                    cfrint2l2(knt+j) = dot_product(ymat2(1:npntintr,lm), tchvec1) * dos * ri(npntintr)
                enddo
            endif
        enddo
    enddo
    return
    end

!   ***************************************************************

!     Subroutine for computing the  integrals:
!          rintr1(la,ma) = Integrate[ r * fradtr[la,ma,r], {r,r0,l_k}] ) 
!          rintr2l2(la,ma) = Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(k-1),r0}]
!     with    l_(k-1) < r0 < l_k
!     where   fradtr[la,ma,r]  stands for the piecewise representation
!     of the corresponding radial factor, and  (l_(i-1), l_i)  are the
!     (lower,upper) bounds of the i-th interval.
  subroutine integfradk(interv, ia, r0, xaj)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    real(KREAL) :: aiinv, ai, argdlt, argsg, aux, auxa, auxb, auxj, auxp, bux, dlt2, dltbar, dlti, dltip, dosdltsg
    real(KREAL) :: r0, rl12, rl32, rl52, sg2, sgbar, sgi, sgip, suma, sumb, xaj, xi, w, zz
    integer(KINT) :: i1, ia, icflm, interv, intshft, ip, j, kchb, kk, kntcf, kntlm, l, l2, la, lenpol, lk, ma, n, ntpow
    real(KREAL) :: cfpows(0:mxlenpol-1), coef(0:mxlenpol-1), gl(0:mxtpw+2), rint(0:mxtpw)
!----------------------------------------------------------------------------------
!     Integrals:  rintr1(la,ma) =  Integrate[ r * fradtr[la,ma,r], {r,r0,l_k}] )
!----------------------------------------------------------------------------------
    ntpow = mxlenpol + 2
    dltip = umed * (rinterv(interv) - r0)
    sgip = umed * (rinterv(interv) + r0)
    intshft = (interv-1)*lmtop
    if (xaj .gt. cero) then    ! Interval with exponential
!        Starts with the integrals:  Integral[t**j * Exp[-xi*r(t)],{t,-1,1}]
        argdlt = xaj * dltip
        argsg = xaj * sgip
        w = dltip * exp(-argsg)
!     Computes the integrals:   Int[ Exp[-argdlt * t] * LegendreP[l,t], {t,-1,1}]
!     by means of:   Int[ Exp[-z * t] * LegendreP[l,t], {t,-1,1}] = (-1)**l 2 z**l * 0F1[l+3/2,z**2/4] / (2l+1)!!
!     starting with the hypergeometrics 0F1[...] corresponding to  l = ntpow  and  l = ntpow-1
!     the remaining ones being obtained by means of:  0F1[l-1,z] = 0F1[l,z] + 0F1[l+1,z] * z / ( l (l-1) )
!
!     hypergeometrics 0F1[ntpow,z**2/4] and  0F1[ntpow-1,z**2/4]
        auxa = uno
        auxb = uno
        suma = uno
        sumb = uno
        ai = uno
        rl32 = ntpow + umed + uno
        rl52 = ntpow + umed + dos
        zz = pt25 * argdlt * argdlt
        do i1 = 1, 1000
            aiinv = uno / ai
            auxa = auxa * zz * aiinv / rl32
            auxb = auxb * zz * aiinv / rl52
            suma = suma + auxa
            sumb = sumb + auxb
            rl32 = rl32 + uno
            rl52 = rl52 + uno
            ai = ai + uno
            if (auxa .lt. (1.d-15*suma) ) go to 334
        enddo
        write(6,"('WARNING: The computation of the hypergeometrics 0F1 does not converge in subroutine integfradk' &
                ,/, 'suma = ', e22.15, ' auxa = ', e22.15, ' sumb = ', e22.15, ' auxb = ', e22.15)") suma, auxa, sumb, auxb
334            continue
        gl(ntpow+1) = sumb
        gl(ntpow)   = suma
!    backwards recursion of the hypergeometrics  0F1
        rl32 = ntpow + uno + umed
        rl12 = ntpow + umed
        do l = ntpow, 1, -1
            gl(l-1) = gl(l) + zz * gl(l+1) / (rl32 * rl12)
            rl32 = rl12
            rl12 = rl12 - uno
        enddo
!     transforms the hypergeometrics into integrals over Legendre polynomials
        aux = dos
        do l = 0, ntpow+1
            gl(l) = aux * gl(l)
            aux = - aux * argdlt * dosl1i(l+1)
        enddo
!     transforms the integrals over Legendre polynomials into integrals over powers of  t
        rint(0) = gl(0) * w
        do l = 1, ntpow
            aux = cero
            do lk = 0, ntpow-l
                bux = ri(lk+lk+1) * (re(lk+1) * gl(lk+1) + re(lk) * aux )
                aux = gl(lk)
                gl(lk) = bux
            enddo
            rint(l) = gl(0) * w
        enddo
    else    !    Interval with zero exponent in the exponential (only polynomial)
!            Computes the integrals: Integral[dlti * t**j,{t,-1,1}]
        do l = 0, ntpow-1, 2
            rint(l) = (dltip+dltip) * ri(l+1)
            rint(l+1) = cero
        enddo
        if (mod(ntpow,2) .eq. 0) rint(ntpow) = dltip * ri(ntpow+1)
    endif

    kntlm = 0
    do la = 0, lmaxexp
        do ma = -la, la
            kntlm = kntlm + 1
            icflm = icfpos(kntlm+intshft)
            if (icfpos(kntlm+intshft+1) .le. icflm) then   ! If the radial factor is null, loads zeroes and jumps to next
                rintr1(kntlm) = cero
            else
!            Converts the expansion coefficients from Chebyshev T polynomials to powers
                kchb = 0
                cfpows = cero
                lenpol = icfpos(kntlm+intshft+1)-icflm
                kntcf = icflm
                do kk = 0, lenpol-1
                    do n = 0, kk/2
                        kchb = kchb + 1
                        cfpows(kk-n-n) = cfpows(kk-n-n) + chebTcf(kchb) * cfajust(kntcf)
                    enddo
                    kntcf = kntcf + 1
                enddo
                aux = cero
!            Transforms the coefficients
                dltbar=(rinterv(interv)-r0) / (rinterv(interv)-rinterv(interv-1))
                sgbar=(r0-rinterv(interv-1)) / (rinterv(interv)-rinterv(interv-1))
                auxj = uno
                do j = 0, lenpol-1
                    suma = cero
                    auxp = uno
                    do ip = 0, lenpol-1-j
                        suma = suma + cfpows(ip+j) * auxp
                        auxp = auxp * sgbar * re(ip+j+1) * ri(ip+1)
                    enddo
                    coef(j) = suma * auxj
                    auxj = auxj * dltbar
                enddo
!            Computes the integral
                do kk = 0, lenpol-1
                    aux = aux + coef(kk) * ( dltip*rint(kk+1) + sgip * rint(kk) )
                enddo
                rintr1(kntlm) = aux
            endif
        enddo    ! End of Do on ma
    enddo    ! End of Do on la
!-----------------------------------------------------------------------------------
!     Integral:  rintr2l2 = Integrate[ r**(2*la+2) * fradtr[la,ma,r], {r,l_(k-1),r0}]
!-----------------------------------------------------------------------------------
    ntpow = 2*lmaxexp + 2 + mxlenpol + 1
    dlti = umed * (r0 - rinterv(interv-1))
    sgi = umed * (r0 + rinterv(interv-1))
    if (xaj .gt. cero) then    ! Interval with exponential
        argdlt = xaj * dlti
        argsg = xaj * sgi
        w = dlti * exp(-argsg)
!     Computes the integrals:   Int[ Exp[-argdlt * t] * LegendreP[l,t], {t,-1,1}]
!     by means of:   Int[ Exp[-z * t] * LegendreP[l,t], {t,-1,1}] = (-1)**l 2 z**l * 0F1[l+3/2,z**2/4] / (2l+1)!!
!     starting with the hypergeometrics 0F1[...] corresponding to  l = ntpow  and  l = ntpow-1
!     the remaining ones being obtained by means of:  0F1[l-1,z] = 0F1[l,z] + 0F1[l+1,z] * z / ( l (l-1) )
!
!     hypergeometrics 0F1[ntpow,z**2/4] and  0F1[ntpow-1,z**2/4]
        auxa = uno
        auxb = uno
        suma = uno
        sumb = uno
        ai = uno
        rl32 = ntpow + uno + umed
        rl52 = ntpow + dos + umed
        zz = pt25 * argdlt * argdlt
        do i1 = 1, 1000
            aiinv = uno / ai
            auxa = auxa * zz * aiinv / rl32
            auxb = auxb * zz * aiinv / rl52
            suma = suma + auxa
            sumb = sumb + auxb
            rl32 = rl32 + uno
            rl52 = rl52 + uno
            ai = ai + uno
            if (auxa .lt. (1.d-15*suma) ) go to 234
        enddo
        write(6,"('WARNING: The computation of the hypergeometrics 0F1 does not converge in subroutine integfradk' &
                ,/, 'suma = ', e22.15, ' auxa = ', e22.15, ' sumb = ', e22.15, ' auxb = ', e22.15)") suma, auxa, sumb, auxb
234          continue
        gl(ntpow+1) = sumb
        gl(ntpow)   = suma
!        backwards recursion of the hypergeometrics  0F1
        rl32 = ntpow + uno + umed
        rl12 = ntpow + umed
        do l = ntpow, 1, -1
            gl(l-1) = gl(l) + zz * gl(l+1) / (rl32 * rl12)
            rl32 = rl12
            rl12 = rl12 - uno
        enddo
!             transforms the hypergeometrics into integrals over Legendre polynomials
        aux = dos
        do l = 0, ntpow+1
            gl(l) = aux * gl(l)
            aux = - aux * argdlt * dosl1i(l+1)
        enddo
!               transforms the integrals over Legendre polynomials into integrals over powers of  t
        rint(0) = gl(0) * w
        do l = 1, ntpow
            aux = cero
            do lk = 0, ntpow-l
                bux = ri(lk+lk+1) * (re(lk+1) * gl(lk+1) + re(lk) * aux )
                aux = gl(lk)
                gl(lk) = bux
            enddo
            rint(l) = gl(0) * w
        enddo
    else    !    Interval with zero exponent in the exponential (only polynomial)
!            Computes the integrals: Integral[dlti * t**j,{t,-1,1}]
        do l = 0, ntpow-1, 2
            rint(l) = (dlti+dlti) * ri(l+1)
            rint(l+1) = cero
        enddo
            if (mod(ntpow,2) .eq. 0) rint(ntpow) = dlti * ri(ntpow+1)
    endif
!    Recursion on  l  of the integrals with powers of  t  to yield integrals  with powers of  r
    kntlm = 0
    do la = 0, lmaxexp
        l2 = 2*la+2
        dlt2 = dlti*dlti
        sg2 = sgi * sgi
        dosdltsg = dos * dlti * sgi
        do kk = 0, ntpow-l2
            rint(kk) = dlt2*rint(kk+2) + dosdltsg*rint(kk+1) + sg2 * rint(kk)
        enddo
        do ma = -la, la
            kntlm = kntlm + 1
            icflm = icfpos(kntlm+intshft)
            if (icfpos(kntlm+intshft+1) .le. icflm) then     ! If the radial factor is null, loads zeroes and jumps to next
                rintr2l2(kntlm) = cero
            else
                kntcf = icflm
                lenpol = icfpos(kntlm+intshft+1)-icflm
!            Converts the expansion coefficients from Chebyshev T polynomials to powers
                kchb = 0
                cfpows = cero
                do kk = 0, lenpol-1
                    do n = 0, kk/2
                        kchb = kchb + 1
                        cfpows(kk-n-n) = cfpows(kk-n-n) + chebTcf(kchb) * cfajust(kntcf)
                    enddo
                    kntcf = kntcf + 1
                enddo
!            Transforms the coefficients
                dltbar = (r0-rinterv(interv-1)) / (rinterv(interv)-rinterv(interv-1))
                sgbar = (r0-rinterv(interv)) / (rinterv(interv)-rinterv(interv-1))
                auxj = uno
                do j = 0, lenpol-1
                    suma = cero
                    auxp = uno
                    do ip = j, lenpol-1
                        suma = suma + cfpows(ip) * auxp
                        auxp = auxp * sgbar * re(ip+1) * ri(ip+1-j)
                    enddo
                    coef(j) = suma * auxj
                    auxj = auxj * dltbar
                enddo
                aux = cero
                do kk = 0, lenpol-1
                    aux = aux + coef(kk) * rint(kk)
                enddo
                rintr2l2(kntlm) = aux
            endif
        enddo   ! End of Do on ma
    enddo   ! End of Do on la
    return
    end
! 
!    Integrals: A(-1,-1), A(-1,0), A(0,-1), A(0,0), with
! 
!          A(m,k) = 2 * Integral[s**(2k) 
!             * khat(m,xs * sqrt(a^2+b^2*s+c^2/s)), {s,0,1}]
! 
!    khat(n,z) = z**n * K(n,z)
!    where K(n,z) stands for the corresponding Macdonald function
!
!    New version (June 2012) with analytical integrals
! 
!   Equations can be found in the supplementary material of the following reference:
!
!       Improved partition-expansion of two-center distributions involving Slater functions
!       Rafael Lopez, Guillermo Ramirez, Ignacio Ema, and Jaime Fernandez Rico
!       Journal of Computational Chemistry 2013, 34, 1800–1809
!
!   Equations numbering starting with S refers to those of the supplentary material file
!   remaining numbering refers to the manuscript
!
  subroutine Avk(xa, xb, r, Rab, a00, am10, a0m1, am1m1)
    USE DAM320_D
    USE DAM320_DATA_D , ONLY : wthreshold
    USE DAM320_CONST_D
    implicit none
    real(KREAL) :: aux, a00, am10, a0m1, am1m1, ai, bk0, bk1, bkm1, Gint0, Gintm1, G00, G030
    real(KREAL) :: r, Rab, rk0w1, rk0w2, rKcomp0, rKcompm1, rKint0, rKintm1, rkm1w1
    real(KREAL) :: s0, sgn, sm1, sqrR, x, xa, xb, w, w1, w2, wsq, wsqi
    integer(KINT) :: i, j, jmax
    real(KREAL) :: bi(0:31), bk(0:31), g0(0:30)
    sqrR = sqrt(r*r + Rab*Rab)
    w = sqrt((xa*xa + xb*xb) * (dos * r * r + Rab * Rab))
    w1 = xb * sqrR + xa * r
    w2 = abs(xb * sqrR - xa * r)
!    Calculation of Kint(m,w,w1) for m = 0  and (m = -1
    rk0w1 = exp(-w1) * pimed    !    rk0w1 = sqrt(pi/2) * khat(1/2,w1)
    rkm1w1 = rk0w1 / w1         !    rkm1w1 = sqrt(pi/2) * khat(-1/2,w1)
    if (w-w1 .lt. 1.d-15) then    !    Case of w = w1 : series of products of Bessel I and K functions truncated to first term
        call BesselK01(umed*(w+w1), bk0, bk1)
        rKint0 = dos * bk0
        rKintm1 = cuatro * bk1 / (w+w1)
    elseif (w*w .le. dos * w1*w1) then    !    Case of w <= sqrt(2) w1 : series of products of Bessel I and K functions (30 terms)
        if ((w-w1) .lt. 1.d-5) then
            call BesselIK1011(umed*(w-w1), umed*(w+w1), bi, bk)
            jmax = 10
        else
            call BesselIK3031(umed*(w-w1), umed*(w+w1), bi, bk)
            jmax = 30
        endif
        rKint0 = umed * bi(0) * bk(0)
        rKintm1 = bi(1) * bk(1)
        sgn = uno
        do j = 1, jmax
            sgn = -sgn
            rKint0 = rKint0 - sgn * bi(j) * bk(j) * dosl1i(j-1) * dosl1i(j)         ! equation (S10)
            rKintm1 = rKintm1 + re(j+1) * re(j+1) * h3f2(j) * bi(j+1) * bk(j+1)     ! equation (S11)
        enddo
        rKint0 = cuatro * rKint0                    ! equation (S10)
        rKintm1 = rKintm1 * r16 / (w*w - w1*w1)     ! equation (S11)
    else        !    Case of w > sqrt(2) w1 : asymptotic integral minus complementary integral
        rKint0 = rk0w1      !    rk0w1 = sqrt(pi/2) * khat(1/2,w1)
        rKintm1 = rkm1w1    !    rkm1w1 = sqrt(pi/2) * khat(-1/2,w1)
        if (w .gt. wthreshold) then
            s0 = cero
            sm1 = cero
        else
            call BesselK01(w, bk0, bk1)
            bkm1 = bk1 / w
            bk1 = bk1 * w
            wsq = w * w
            if (w .lt. 25d0) then
                Gint0 = G00(w)
                Gintm1 = bkm1 - Gint0    ! Recursion (S17)
                x = w1*w1 / wsq
                ai = uno
                s0 = Gint0
                sm1 = Gintm1
                do i = 1, 30
                    Gint0 = (wsq * Gint0 + dosl1(i-1) * bk0 - bk1) * dosl1i(i-1) * dosl1i(i-1)     ! Recursion (S18)
                    Gintm1 = (wsq * Gintm1 + dosl1(i-1) * bkm1 - bk0) * dosl1i(i-1) * dosl1i(i)    ! Recursion (S18)
                    ai = ai * (re(i)-umed) * x * ri(i)
                    s0 = s0 + ai * Gint0        !   Summation of equation (S12)    for m = 0
                    sm1 = sm1 + ai * Gintm1     !   Summation of equation (S12)    for m = -1
                enddo
            else
                wsqi = uno / wsq
                g0(30) = G030(w)
                do i = 29, 0, -1
                    g0(i) = wsqi * (dosl1(i) * dosl1(i) * g0(i+1) - dosl1(i) * bk0 + bk1)        ! Recursion (S18) (downwards)
                enddo
                x = w1*w1 / wsq
                ai = uno
                s0 = g0(0)
                sm1 = bkm1 - g0(0)    ! Recursion (S17)
                do i = 1, 30
                    ai = ai * (re(i)-umed) * x * ri(i)
                    s0 = s0 + ai * g0(i)                        !   Summation of equation (S12)  for m = 0
                    sm1 = sm1 + ai * (bkm1 - g0(i)) * dosl1i(i) !   Summation of equation (S12)  for m = -1    with Recursion (S17)
                enddo
            endif
        endif
        aux = dos / sqrt(w*w - w1*w1)
        rKint0 = aux * (rKint0 - w * s0)        ! equation (S13)
        rKintm1 = aux * (rKintm1 - w * sm1)     ! equation (S13)
    endif 
    if (w*w .le. dos * w2*w2) then    !    Case of w <= sqrt(2) w2 : series of products of Bessel I and K functions (30 terms)
        if ((w-w2) .lt. 1.d-5) then
            call BesselIK1011(umed*(w-w2), umed*(w+w2), bi, bk)
            jmax = 10
        else
            call BesselIK3031(umed*(w-w2), umed*(w+w2), bi, bk)
            jmax = 30
        endif
        rKcomp0 = umed * bi(0) * bk(0)
        rKcompm1 = bi(1) * bk(1)
        sgn = uno
        do j = 1, jmax
            sgn = -sgn
            rKcomp0 = rKcomp0 - sgn * bi(j) * bk(j) * dosl1i(j-1) * dosl1i(j)       ! equation (S10)
            rKcompm1 = rKcompm1 + re(j+1) * re(j+1) * h3f2(j) * bi(j+1) * bk(j+1)   ! equation (S11)
        enddo
        rk0w2 = exp(-w2) * pi / sqrt(w*w - w2*w2)    !    rk0w2 = sqrt(2*pi/(w^2-w2^2)) * khat(1/2,w2)
        rKcomp0 = rk0w2 - cuatro * rKcomp0                      ! equation (S13)
        rKcompm1 = rk0w2 / w2 - rKcompm1 * r16 / (w*w - w2*w2)  ! equation (S13)
    else        !    Case of w > sqrt(2) w2 : asymptotic integral minus complementary integral
        if (w .gt. wthreshold) then
            s0 = cero
            sm1 = cero
        else
            call BesselK01(w, bk0, bk1)
            bkm1 = bk1 / w
            bk1 = bk1 * w
            wsq = w * w
            if (w .lt. 25d0) then
                Gint0 = G00(w)
                Gintm1 = bkm1 - Gint0    ! Recursion (S17)
                x = w2*w2 / wsq
                ai = uno
                s0 = Gint0
                sm1 = Gintm1
                do i = 1, 30
                    Gint0 = (wsq * Gint0 + dosl1(i-1) * bk0 - bk1) * dosl1i(i-1) * dosl1i(i-1)     ! Recursion (S18)
                    Gintm1 = (wsq * Gintm1 + dosl1(i-1) * bkm1 - bk0) * dosl1i(i-1) * dosl1i(i)    ! Recursion (S18)
                    ai = ai * (re(i)-umed) * x * ri(i)
                    s0 = s0 + ai * Gint0
                    sm1 = sm1 + ai * Gintm1
                enddo
            else
                wsqi = uno / wsq
                g0(30) = G030(w)
                do i = 29, 0, -1
                    g0(i) = wsqi * (dosl1(i) * dosl1(i) * g0(i+1) - dosl1(i) * bk0 + bk1)        ! Recursion (S18) (downwards)
                enddo
                x = w2*w2 / wsq
                ai = uno
                s0 = g0(0)
                sm1 = bkm1 - g0(0)    ! Recursion (S17)
                do i = 1, 30
                    ai = ai * (re(i)-umed) * x * ri(i)
                    s0 = s0 + ai * g0(i)                        !   Summation of equation (S12)  for m = 0
                    sm1 = sm1 + ai * (bkm1 - g0(i)) * dosl1i(i) !   Summation of equation (S12)  for m = -1   with Recursion (S17)
                enddo
            endif
        endif
        aux = dos / sqrt(w*w - w2*w2)
        rKcomp0 = aux * w * s0      ! Equation (12)     for m = 0
        rKcompm1 = aux * w * sm1    ! Equation (12)     for m = -1
    endif
    a00 = (rk0w1 + umed * (xa * sqrR - xb * r) * rKint0 - umed * (xa * sqrR + xb * r) * rKcomp0) / (dos * xa * sqrR)     ! equation (44) 
    am10 = (rkm1w1 + umed * (xa * sqrR - xb * r) * rKintm1 - umed * (xa * sqrR + xb * r) * rKcompm1) / (dos * xa * sqrR) ! equation (44)
    a0m1 = (rk0w1 + umed * (xa * sqrR - xb * r) * rKint0 + umed * (xa * sqrR + xb * r) * rKcomp0) / (dos * xb * r)       ! equation (45)
    am1m1 = (rkm1w1 + umed * (xa * sqrR - xb * r) * rKintm1 + umed * (xa * sqrR + xb * r) * rKcompm1) / (dos * xb * r)   ! equation (45)
    return
    end
!
!    Integral G00(x) = Integrate[khat[0,x*t], {t,1,Infinity}]
!
  function G00(x)
    USE DAM320_D
    USE DAM320_CONST_D, ONLY : cero, uno, umed, pt25, pimed, euler
    implicit none
    real(KREAL) :: G00, x, y
    if (x .lt. 10.d0) then
        if (x .le. 2.d0) then    ! x <= 2
            y = pt25 * x * x
            G00 = pimed / x + (euler + log(umed * x)) * (1.0000000000000000D0+y*(3.3333333333333330D-1 &
                    +y*(5.0000000000000000D-2+y*(3.9682539682539680D-3+y*(1.9290123456790120D-4 &
                    +y*(6.3131313131313130D-6+y*(1.4838556505223170D-7+y*(2.6245065927605610D-9 &
                    +y*(3.6183454863426860D-11+y*(3.9968728569087500D-13+y*(3.6162182991079160D-15))))))))))) &
                    - (uno+y*(4.4444444444444450D-1+y*(8.5000000000000000D-2+y*(7.8420256991685570D-3 &
                    +y*(4.2331104252400560D-4+y*(1.4988904193449650D-5+y*(3.7495890861275480D-7 &
                    +y*(6.9799377716989200D-9+y*(1.0046989977519180D-10+y*(1.1517388156653240D-12 &
                    +y*(1.0763989468892250D-14)))))))))))
        else    ! 2 < x <= 10
            G00 = exp(-x) * sqrt(uno/(x*x*x)) * (1.7922675870630270D-1+x*(6.1934589962448720D0 &
                    +x*(2.7156631898979300D1+x*(3.5806595825592980D1+x*(1.8024894723741420D1 &
                    +x*(3.6045106767006080D0+x*(2.3667679950973320D-1))))))) &
                    / (1.0000000000000000D0 &
                    +x*(1.1814300296658350D1+x*(3.4060693226973210D1+x*(3.6080831132786410D1 &
                    +x*(1.6062729224430470D1+x*(2.9940087867679320D0+x*(1.8884076549805700D-1)))))))
        endif
    else
        if (x .le. 100.d0) then    ! 10 < x <= 100
            G00 = exp(-x) * sqrt(uno/(x*x*x)) * (3.0869783544904670D-1+x*(3.3866264115692110D0 &
                    +x*(4.9161353441613540D0+x*(2.1896835425508080D0+x*(3.5584310716409640D-1 &
                    +x*(1.8300999119747960D-2)))))) &
                    / (1.0000000000000000D0+x*(4.4361868334559810D0 &
                    +x*(4.8622518681184430D0+x*(1.9155535435390730D0+x*(2.9304802417620100D-1 &
                    +x*(1.4602084644916760D-2))))))
        else    ! x > 100: sets G00 to zero
            G00 = cero
        endif
    endif
    return
    end function
!
!    Integral G030(x) = Integrate[khat[0,x*t] / t^60, {t,1,Infinity}]
!
!     Only valid for x > 25
!     It must be checked outside the function that this restriction is fulfilled
!     If x < 25, inaccurate or even meaningless value is returned
!
  function G030(x)
    USE DAM320_D
    USE DAM320_CONST_D, ONLY : uno
    implicit none
    real(KREAL) :: G030, x
    G030 = exp(-x) * sqrt(uno/(x*x*x)) * (-1.5995488278297400D-3+x*(2.0989898258123690D-2 &
            +x*(-1.4109823169861160D-2+x*(-3.6243324892564730D-2+x*(-1.8211585987297380D-3 &
            +x*(-2.9987773691913830D-5+x*(-1.6083296101110410D-7))))))) &
            / (1.0000000000000000D0 &
            +x*(-8.5971638576996100D-1+x*(-1.7462287132380000D0+x*(-1.1622358300065430D-1 &
            +x*(-2.8968191605075690D-3+x*(-3.1706553627854880D-5+x*(-1.2832613649421540D-7)))))))
    return
    end
!
!    Macdonald functions K[n,x], n = 0, 1
!
  subroutine BesselK01(x, bk0, bk1)
    USE DAM320_D
    USE DAM320_CONST_D, ONLY : uno, umed
    implicit none
    real(KREAL) :: bk0, bk1, x, x2, xi
    x2 = x * x
    xi = uno / x
    if (x .lt. 1.8d0) then     ! 0 <= x < 1.8  err < 7.3468D-17
        bk0 = -log(umed*x) * (1.0000000000000000D0+x2*(2.4999999999999960D-1 &
                +x2*(1.5625000000002980D-2+x2*(4.3402777776785650D-4+x2*(6.7816840441615740D-6 &
                +x2*(6.7816825183797480D-8+x2*(4.7095840125542120D-10+x2*(2.4002744550453120D-12 &
                +x2*(9.8091585038713500D-15))))))))) &
                + (-5.7721566490153280D-1+x2*(1.0569608377461490D-1 &
                +x2*(1.4418505235927360D-2+x2*(5.4518996021712680D-4+x2*(1.0214014193798720D-5 &
                +x2*(1.1570346171202710D-7+x2*(8.8201157393109500D-10+x2*(4.8365517544342580D-12 &
                +x2*(2.1117652087933440D-14)))))))))
!        0 <= x < 1.8  err < 4.2473D-16
        bk1 = log(umed*x) * x * (5.0000000000000000D-1+x2*(6.2499999999999980D-2 &
                +x2*(2.6041666666668300D-3+x2*(5.4253472221687950D-5+x2*(6.7816840364383320D-7 &
                +x2*(5.6514025708569590D-9+x2*(3.3639722934454360D-11+x2*(1.5004676478633540D-13 &
                +x2*(5.4274715382643900D-16))))))))) &
                + xi * (1.0000000000000000D0 &
                +x2*(3.8607832450787250D-2+x2*(-4.2049020943821730D-2+x2*(-2.8371119832441660D-3 &
                +x2*(-7.4930429866409100D-5+x2*(-1.0892175495975930D-6+x2*(-1.0113270821769760D-8 &
                +x2*(-6.5293914913889730D-11+x2*(-3.2945603125166970D-13)))))))))
    else
!         x >= 1.8  err < 1.2039D-17
        bk0 = sqrt(xi) * exp(-x) * (1.2533141373155000D0+xi*(1.7168113083556290D1 &
                +xi*(8.4058065238156000D1+xi*(1.8451128616426320D2+xi*(1.8669475343307380D2 &
                +xi*(8.0260256475123400D1+xi*(1.1540179557584240D1 &
                +xi*(2.5982512903262060D-1)))))))) &
                / (1.0000000000000000D0+xi*(1.3823172367487210D1 &
                +xi*(6.8726216510427700D1+xi*(1.5491078396788470D2+xi*(1.6439268456283490D2 &
                +xi*(7.7405808022562240D1+xi*(1.3529690413964620D1+xi*(5.4457906513011500D-1))))))))
!         x >= 1.8  err < -1.9134D-17
        bk1 = sqrt(xi) * exp(-x) * (1.2533141373155000D0+xi*(1.6936161397080210D1 &
                +xi*(8.2772897704525600D1+xi*(1.8584554680747990D2+xi*(2.0189606898235020D2 &
                +xi*(1.0245683525072580D2+xi*(2.1105315978984250D1 &
                +xi*(1.1660416083420830D0)))))))) &
                / (1.0000000000000000D0+xi*(1.3138101697995840D1 &
                +xi*(6.1233616494596590D1+xi*(1.2675776853743860D2+xi*(1.1952843443193260D2 &
                +xi*(4.7118033617852210D1+xi*(6.0393000847364940D0+xi*(1.0811703622238420D-1))))))))
    endif
    return
    end
!
!	Bessel I functions starting from I[10,x] and I[11,x]
!	Bessel K functions starting from K[0,xk] and K[1,xk]
!	This code has been generated with the notebook fragmentos_fortran_new.nb
!	Rafael Lopez. January 2018
!
  subroutine BesselIK1011(x, xk, bi, bk)
    USE DAM320_D
    USE DAM320_CONST_D, ONLY : uno, umed, re
    implicit none
    real(KREAL) :: x, xk, xk2, xi
    integer(KINT) :: i
    real(KREAL) :: bi(0:*), bk(0:*)

!	Functions I[n,x], n = 0, ... 11
    xi = uno / x
    if (x .lt. 25.d0) then
        if (x .lt. 1) then 	! 0 <= x < 1  err < -2.6075D-23
            bi(10) = x**10 * (2.6911444554673710D-10+x*(-2.3461779160251250D-30+x*(6.1162373987894820D-12 &
                +x*(-2.8248857842815450D-27+x*(6.3710806237422300D-14+x*(-2.1340343184030230D-25 &
                +x*(4.0840260500021110D-16+x*(-2.6121593978208660D-24+x*(1.8232309790048000D-18 &
                +x*(-6.6629782917529550D-24+x*(6.0831926707992960D-21+x*(-3.0577366764909020D-24 &
                +x*(1.6621783698343680D-23)))))))))))))
                ! 0 <= x < 1  err < -1.5931D-23
            bi(11) = x**11 * (1.2232474797578960D-11+x*(-6.5150640831795310D-32+x*(2.5484322494956180D-13 &
                +x*(-7.8435613901358110D-29+x*(2.4504156245159020D-15+x*(-5.9248401043365360D-27 &
                +x*(1.4585807314165320D-17+x*(-7.2518565424021060D-26+x*(6.0774337729077280D-20 &
                +x*(-1.8497301676925220D-25+x*(1.9007963252850480D-22+x*(-8.4890487205441700D-26 &
                +x*(4.8756614868859870D-25)))))))))))))
        else 	! 1 <= x < 25  err < 1.9193D-15
            bi(10) = x**10 * (2.6911444554282000D-10+x*(-1.9577535922001100D-11+x*(5.1343206795163040D-12 &
                +x*(-3.2093032504886700D-13+x*(4.0586374246891700D-14+x*(-2.1144434497422430D-15 &
                +x*(1.6909788867016760D-16+x*(-7.0065623794778540D-18+x*(3.8223378718775090D-19 &
                +x*(-1.1478172459005900D-20+x*(4.1651016683691790D-22+x*(-7.0819627768787720D-24 &
                +x*(1.4454309983181610D-25))))))))))))) &
                / (1.0000000000000000D0+x*(-7.2747993519457650D-2 &
                +x*(-3.6486955499914050D-3+x*(4.6082113541252840D-4+x*(-3.0028221659163680D-6 &
                +x*(-1.1078030075736730D-6+x*(4.2855915085319330D-8+x*(4.3369732726294790D-10 &
                +x*(-7.7161570817236220D-11+x*(2.6166296178116460D-12+x*(-4.5289748610666200D-14 &
                +x*(4.1665927797113690D-16+x*(-1.6286048980575170D-18)))))))))))))
                ! 1 <= x < 25  err < 7.0586D-16
            bi(11) = x**11 * (1.2232474797525740D-11+x*(-8.6025541194859200D-13+x*(2.1082392423105410D-13 &
                +x*(-1.2654487850688720D-14+x*(1.5085729632825420D-15+x*(-7.5118812942347590D-17 &
                +x*(5.6962771846752970D-18+x*(-2.2492197992560010D-19+x*(1.1689138577528490D-20 &
                +x*(-3.3418106500784380D-22+x*(1.1620384749360100D-23+x*(-1.8839815609381860D-25 &
                +x*(3.7270067973677570D-27))))))))))))) &
                / (1.0000000000000000D0+x*(-7.0325541350404160D-2 &
                +x*(-3.5985604665512560D-3+x*(4.3061599431647750D-4+x*(-2.0252179467208140D-6 &
                +x*(-1.0244731282719670D-6+x*(3.6350623924173020D-8+x*(5.4718389895319270D-10 &
                +x*(-7.2882383871580870D-11+x*(2.3598097737853290D-12+x*(-3.9676100484612060D-14 &
                +x*(3.5645784823599010D-16+x*(-1.3640087051131270D-18)))))))))))))
        endif
    else
        if (x .lt. 65) then 	! 25 <= x < 65  err < -2.3531D-33
            bi(10) = exp(x) * sqrt(xi) * (3.9894228040143270D-1+xi*(-3.3118244003716390D1 &
                +xi*(1.3029824725346840D3+xi*(-3.1932167018268480D4+xi*(5.4521300444280920D5 &
                +xi*(-6.8605996812794510D6+xi*(6.5425804756125190D7+xi*(-4.7713021710520310D8 &
                +xi*(2.6421428897653650D9+xi*(-1.0832780676032280D10+xi*(3.1195234367459690D10 &
                +xi*(-5.6601649502744850D10 &
                +xi*(4.8884546451168650D10))))))))))))) &
                / (1.0000000000000000D0+xi*(-3.3140126825844080D1 &
                +xi*(3.9440856906507510D2+xi*(-9.3501821913311800D2+xi*(-7.1329889854903030D2 &
                +xi*(6.7366156279877440D3+xi*(1.1816671284979950D5+xi*(1.3080641323037310D6 &
                +xi*(1.1759288670324420D7+xi*(8.8620832028525400D7+xi*(5.5341473328382680D8 &
                +xi*(2.7572868483280580D9+xi*(1.0094941373922980D10+xi*(2.2144862146974440D10))))))))))))))
                ! 25 <= x < 65  err < -8.5502D-33
            bi(11) = exp(x) * sqrt(xi) * (3.9894228040143270D-1+xi*(-2.8604684237886500D1 &
                +xi*(1.0272157313401870D3+xi*(-2.3776415976995800D4+xi*(3.9376188915229740D5 &
                +xi*(-4.8958983736401680D6+xi*(4.6761183470488510D7+xi*(-3.4487807707031370D8 &
                +xi*(1.9451135666340320D9+xi*(-8.1646867092485100D9+xi*(2.4163755149718520D10 &
                +xi*(-4.5187714193480750D10 &
                +xi*(4.0308737506083280D10))))))))))))) &
                / (1.0000000000000000D0+xi*(-1.1326310297578010D1 &
                +xi*(9.8639199606796500D1+xi*(9.3711031441900300D2+xi*(1.2550760556521250D4 &
                +xi*(1.5985865674311340D5+xi*(1.8486939210330060D6+xi*(1.9094994011728590D7 &
                +xi*(1.7356032073893250D8+xi*(1.3617493722455680D9+xi*(8.9690177008518100D9 &
                +xi*(4.7418332303041170D10+xi*(1.8461704819594300D11+xi*(4.2981592333048160D11))))))))))))))
        else 	!  x >= 65  err < 2.3330D-29
            bi(10) = exp(x) * sqrt(xi) * (3.9894228040143270D-1+xi*(-1.5742485111373430D1 &
                +xi*(3.1142481431581000D2+xi*(-3.9412871634658940D3+xi*(3.4426045961972100D4 &
                +xi*(-2.1055416789877040D5+xi*(8.7470134960974600D5+xi*(-2.2455347309571900D6 &
                +xi*(2.7177974440393290D6))))))))) &
                / (1.0000000000000000D0+xi*(1.0414441706873810D1 &
                +xi*(8.1226212616049800D1+xi*(5.2254979896918550D2+xi*(2.7990290865816440D3 &
                +xi*(1.2229665350008150D4+xi*(4.1503734553237210D4+xi*(9.8756455324211300D4 &
                +xi*(1.2583715219131220D5)))))))))
                !  err < 4.6646D-28
            bi(11) = exp(x) * sqrt(xi) * (3.9894228040143270D-1+xi*(-1.6930864274855060D1 &
                +xi*(3.6389360026208780D2+xi*(-5.0381662294197520D3+xi*(4.8392290163103080D4 &
                +xi*(-3.2689488091850770D5+xi*(1.5061040840178760D6+xi*(-4.3062675551395730D6 &
                +xi*(5.8311854411475130D6))))))))) &
                / (1.0000000000000000D0+xi*(1.7935616894708400D1 &
                +xi*(2.0262604489223980D2+xi*(1.7365673728169110D3+xi*(1.1799547979152250D4 &
                +xi*(6.3357720262390920D4+xi*(2.5855608648378000D5+xi*(7.2853148230196360D5 &
                +xi*(1.0875463125536690D6)))))))))
        endif
    endif
    do i = 10, 1, -1
        bi(i-1) = bi(i+1) + dble(i+i) * xi * bi(i)
    enddo

!	Functions K[n,x], n = 0, ... 11
    xk2 = xk * xk
    xi = uno / xk
    if (xk .lt. 1.8) then 	! 0 <= x < 1.8  err < 7.3468D-17
        bk(0) = -log(umed*xk) * (1.0000000000000000D0+xk2*(2.4999999999999960D-1 &
            +xk2*(1.5625000000002980D-2+xk2*(4.3402777776785650D-4+xk2*(6.7816840441615740D-6 &
            +xk2*(6.7816825183797480D-8+xk2*(4.7095840125542120D-10+xk2*(2.4002744550453120D-12 &
            +xk2*(9.8091585038713500D-15))))))))) &
            + (-5.7721566490153280D-1+xk2*(1.0569608377461490D-1 &
            +xk2*(1.4418505235927360D-2+xk2*(5.4518996021712680D-4+xk2*(1.0214014193798720D-5 &
            +xk2*(1.1570346171202710D-7+xk2*(8.8201157393109500D-10+xk2*(4.8365517544342580D-12 &
            +xk2*(2.1117652087933440D-14)))))))))
!		0 <= x < 1.8  err < 4.2473D-16
        bk(1) = log(umed*xk) * xk * (5.0000000000000000D-1+xk2*(6.2499999999999980D-2 &
            +xk2*(2.6041666666668300D-3+xk2*(5.4253472221687950D-5+xk2*(6.7816840364383320D-7 &
            +xk2*(5.6514025708569590D-9+xk2*(3.3639722934454360D-11+xk2*(1.5004676478633540D-13 &
            +xk2*(5.4274715382643900D-16))))))))) &
            + xi * (1.0000000000000000D0 &
            +xk2*(3.8607832450787250D-2+xk2*(-4.2049020943821730D-2+xk2*(-2.8371119832441660D-3 &
            +xk2*(-7.4930429866409100D-5+xk2*(-1.0892175495975930D-6+xk2*(-1.0113270821769760D-8 &
            +xk2*(-6.5293914913889730D-11+xk2*(-3.2945603125166970D-13)))))))))
    else
!		 x >= 1.8  err < 1.2039D-17
        bk(0) = sqrt(xi) * exp(-xk) * (1.2533141373155000D0+xi*(1.7168113083556290D1 &
            +xi*(8.4058065238156000D1+xi*(1.8451128616426320D2+xi*(1.8669475343307380D2 &
            +xi*(8.0260256475123400D1+xi*(1.1540179557584240D1 &
            +xi*(2.5982512903262070D-1)))))))) &
            / (1.0000000000000000D0+xi*(1.3823172367487210D1 &
            +xi*(6.8726216510427700D1+xi*(1.5491078396788470D2+xi*(1.6439268456283490D2 &
            +xi*(7.7405808022562250D1+xi*(1.3529690413964630D1+xi*(5.4457906513011510D-1))))))))
!		 x >= 1.8  err < -1.9134D-17
        bk(1) = sqrt(xi) * exp(-xk) * (1.2533141373155000D0+xi*(1.6936161397080210D1 &
            +xi*(8.2772897704525600D1+xi*(1.8584554680747990D2+xi*(2.0189606898235020D2 &
            +xi*(1.0245683525072580D2+xi*(2.1105315978984250D1 &
            +xi*(1.1660416083420830D0)))))))) &
            / (1.0000000000000000D0+xi*(1.3138101697995840D1 &
            +xi*(6.1233616494596590D1+xi*(1.2675776853743860D2+xi*(1.1952843443193260D2 &
            +xi*(4.7118033617852210D1+xi*(6.0393000847364940D0+xi*(1.0811703622238420D-1))))))))
    endif
    do i = 1, 10
        bk(i+1) = bk(i-1) + dble(i+i) * xi * bk(i)
    enddo
    return
    end
!
!    Bessel I functions starting from I[30,x] and I[31,x]
!    Bessel K functions starting from K[0,xk] and K[1,xk]
!    This code has been generated with the notebook fragmentos.nb
!    Rafael Lopez. June 2012
!    Modified "by hand" for the cases of large exponets to prevent overflows and underflows
!        in these cases, computes exp(-x)*I(n,x) and exp(x)*K(n,xk)
!    Rafael Lopez. September 2012
!
  subroutine BesselIK3031(x, xk, bi, bk)
    USE DAM320_D
    USE DAM320_CONST_D, ONLY : uno, umed, re
    implicit none
    real(KREAL) :: x, xk, xk2, xi
    integer(KINT) :: i
    real(KREAL) :: bi(0:31), bk(0:31)
!    Functions I[n,x], n = 0, ... 31
    xi = uno / x
    if (x .lt. 25.d0) then
        if (x .lt. 5.d0) then     ! 0 <= x < 5  err < -3.4299D-16
            bi(30) = x**30 * (3.5110745847373330D-42+x*(-8.0811828719049700D-56+x*(2.8315117619747550D-44 &
                    +x*(-3.9166272370850020D-54+x*(1.1060593705504530D-46+x*(-1.1882958358740280D-53 &
                    +x*(2.7931809034799450D-49+x*(-5.8206419844160510D-54+x*(5.1568824750773520D-52 &
                    +x*(-5.9068426858077880D-55+x*(8.3518175805148500D-55+x*(-1.0659829749760950D-56 &
                    +x*(1.3934417916885080D-57)))))))))))))
                    ! 0 <= x < 5  err < -2.7897D-16
            bi(31) = x**31 * (5.6630235237698920D-44+x*(-1.0599480294971600D-57+x*(4.4242371280630050D-46 &
                    +x*(-5.1356955154504190D-56+x*(1.6758475130655230D-48+x*(-1.5578285901846000D-55 &
                    +x*(4.1076027008234130D-51+x*(-7.6299280671188140D-56+x*(7.3643206772596990D-54 &
                    +x*(-7.7433875465967250D-57+x*(1.1520621487618010D-56+x*(-1.3979454261870770D-58 &
                    +x*(1.8616039179304130D-59)))))))))))))
        else     ! 5 <= x < 25  err < -1.9290D-21
            bi(30) = x**30 * (3.5110745847831470D-42+x*(-1.7238263428856790D-43+x*(2.1846610969406550D-44 &
                    +x*(-8.7707798208835000D-46+x*(5.7873114099517210D-47+x*(-1.8854021658405470D-48 &
                    +x*(8.3062355957227200D-50+x*(-2.1280782558923740D-51+x*(6.6593106672057050D-53 &
                    +x*(-1.2377554135176170D-54+x*(2.6678028399215230D-56+x*(-2.8461146754300660D-58 &
                    +x*(3.5828863497023440D-60))))))))))))) &
                    / (1.0000000000000000D0+x*(-4.9096830622241990D-2 &
                    +x*(-1.8423153925650720D-3+x*(1.4613891149136280D-4+x*(-1.6162213643870030D-7 &
                    +x*(-1.6887470353484870D-7+x*(3.4459534515852720D-9+x*(5.7970995189981710D-11 &
                    +x*(-3.4381654120388520D-12+x*(5.8535507864623770D-14+x*(-4.3491301115247370D-16 &
                    +x*(7.8092105486894960D-19+x*(4.4210655754250420D-21)))))))))))))
                    ! 5 <= x < 25  err < -1.3747D-21
            bi(31) = x**31 * (5.6630235238222040D-44+x*(-2.6684280757363620D-45+x*(3.3724768551882990D-46 &
                    +x*(-1.3075032339780700D-47+x*(8.5823313600052900D-49+x*(-2.7129725333877830D-50 &
                    +x*(1.1879543289347150D-51+x*(-2.9648164114257000D-53+x*(9.2294508041833000D-55 &
                    +x*(-1.6767157602890010D-56+x*(3.6069514925787450D-58+x*(-3.7708678815063620D-60 &
                    +x*(4.7800567851157520D-62))))))))))))) &
                    / (1.0000000000000000D0+x*(-4.7120201132821210D-2 &
                    +x*(-1.8572415954501800D-3+x*(1.3724228259218630D-4+x*(7.1924769277672790D-8 &
                    +x*(-1.5685226533469500D-7+x*(2.8445162434624360D-9+x*(5.8299884905140610D-11 &
                    +x*(-2.8870781333093780D-12+x*(4.1976311925164600D-14+x*(-2.0174838599013050D-16 &
                    +x*(-8.9881338175249200D-19+x*(9.4245348897042900D-21)))))))))))))
        endif
    else
        if (x .lt. 65.d0) then     ! 25 <= x < 65  err < -2.7454D-23
            bi(30) = exp(x) * sqrt(xi) * (3.9895180778545880D-1+xi*(-5.0149643165809060D1 &
                    +xi*(3.0462907118739570D3+xi*(-1.1784738860196870D5+xi*(3.2238665635235780D6 &
                    +xi*(-6.5517295867227240D7+xi*(1.0116163747677580D9+xi*(-1.1928482357390670D10 &
                    +xi*(1.0636609888391650D11+xi*(-6.9801072526154880D11+xi*(3.1934942057766720D12 &
                    +xi*(-9.1288743616271200D12 &
                    +xi*(1.2308858704227130D13))))))))))))) &
                    / (1.0000000000000000D0+xi*(3.2420158846913340D2 &
                    +xi*(5.2494929749746460D4+xi*(5.6364619849683460D6+xi*(4.4734159732311700D8 &
                    +xi*(2.8034825865977840D10+xi*(1.4079392774848810D12+xi*(6.0205568199595470D13 &
                    +xi*(2.0284849415731540D15+xi*(6.4334448887899970D16+xi*(1.3532958268312990D18 &
                    +xi*(3.4951927354755450D19+xi*(3.3104972838372450D20+xi*(8.0531191908298600D21))))))))))))))
                    ! 25 <= x < 65  err < -1.1243D-22
            bi(31) = exp(x) * sqrt(xi) * (3.9899276402769520D-1+xi*(-5.2977705594478490D1 &
                    +xi*(3.3875130271247960D3+xi*(-1.3751217880500270D5+xi*(3.9358970684157950D6 &
                    +xi*(-8.3463208222743900D7+xi*(1.3413324834600750D9+xi*(-1.6423642236823000D10 &
                    +xi*(1.5173972104625420D11+xi*(-1.0296220310863240D12+xi*(4.8614327030717260D12 &
                    +xi*(-1.4315651450474540D13 &
                    +xi*(1.9850329559172500D13))))))))))))) &
                    / (1.0000000000000000D0+xi*(3.4775790138577910D2 &
                    +xi*(6.0283008535093000D4+xi*(6.9493461216187580D6+xi*(5.8794663755254620D8 &
                    +xi*(3.9913003197542320D10+xi*(2.1049852898628640D12+xi*(1.0064597940651360D14 &
                    +xi*(3.3915200229573280D15+xi*(1.3072223036464260D17+xi*(2.4285256893735090D18 &
                    +xi*(8.9601749002339200D19+xi*(5.8514168194253360D20+xi*(2.5822645229929570D22))))))))))))))
        else     !  x >= 65  err < 1.4226D-15            computes exp(-x) * I(i,x)
            bi(30) = sqrt(xi) * (3.9894228036172320D-1+xi*(-7.6367803115347670D1 &
                    +xi*(6.8136291716485200D3+xi*(-3.6954984534382150D5+xi*(1.3307427017768200D7 &
                    +xi*(-3.2531884242194920D8+xi*(5.2644114801173530D9+xi*(-5.1472251121566690D10 &
                    +xi*(2.3237952056720110D11))))))))) &
                    / (1.0000000000000000D0+xi*(2.5844930507795900D2 &
                    +xi*(3.2380296944806460D4+xi*(2.5855871367036410D6+xi*(1.4527708027583150D8 &
                    +xi*(5.9623229896883620D9+xi*(1.7828412065652310D11+xi*(3.6763051888702340D12 &
                    +xi*(4.4114601915439180D13)))))))))
                    !  err < 3.9796D-15
            bi(31) = sqrt(xi) * (3.9894228028748360D-1+xi*(-8.0701062733833300D1 &
                    +xi*(7.5914053714797560D3+xi*(-4.3312307979676490D5+xi*(1.6369991608953390D7 &
                    +xi*(-4.1907545115541400D8+xi*(7.0852849971036730D9+xi*(-7.2207049140987870D10 &
                    +xi*(3.3896530230529160D11))))))))) &
                    / (1.0000000000000000D0+xi*(2.7808743331478030D2 &
                    +xi*(3.7475201060413190D4+xi*(3.2191487388802860D6+xi*(1.9472791520286910D8 &
                    +xi*(8.6178526231976700D9+xi*(2.7875889930553510D11+xi*(6.2497427939552160D12 &
                    +xi*(8.3292335660636800D13)))))))))
        endif
    endif
    do i = 30, 1, -1
        bi(i-1) = bi(i+1) + re(i+i) * xi * bi(i)
    enddo
!    Functions K[n,x], n = 0, ... 31
    xk2 = xk * xk
    xi = uno / xk
    if (xk .lt. 1.8d0) then     ! 0 <= xk < 1.8  err < 7.3468D-17
        bk(0) = -log(umed*xk) * (1.0000000000000000D0+xk2*(2.4999999999999960D-1 &
                +xk2*(1.5625000000002980D-2+xk2*(4.3402777776785650D-4+xk2*(6.7816840441615740D-6 &
                +xk2*(6.7816825183797480D-8+xk2*(4.7095840125542120D-10+xk2*(2.4002744550453120D-12 &
                +xk2*(9.8091585038713500D-15))))))))) &
                + (-5.7721566490153280D-1+xk2*(1.0569608377461490D-1 &
                +xk2*(1.4418505235927360D-2+xk2*(5.4518996021712680D-4+xk2*(1.0214014193798720D-5 &
                +xk2*(1.1570346171202710D-7+xk2*(8.8201157393109500D-10+xk2*(4.8365517544342580D-12 &
                +xk2*(2.1117652087933440D-14)))))))))
!        0 <= xk < 1.8  err < 4.2473D-16
        bk(1) = log(umed*xk) * xk * (5.0000000000000000D-1+xk2*(6.2499999999999980D-2 &
                +xk2*(2.6041666666668300D-3+xk2*(5.4253472221687950D-5+xk2*(6.7816840364383320D-7 &
                +xk2*(5.6514025708569590D-9+xk2*(3.3639722934454360D-11+xk2*(1.5004676478633540D-13 &
                +xk2*(5.4274715382643900D-16))))))))) &
                + xi * (1.0000000000000000D0 &
                +xk2*(3.8607832450787250D-2+xk2*(-4.2049020943821730D-2+xk2*(-2.8371119832441660D-3 &
                +xk2*(-7.4930429866409100D-5+xk2*(-1.0892175495975930D-6+xk2*(-1.0113270821769760D-8 &
                +xk2*(-6.5293914913889730D-11+xk2*(-3.2945603125166970D-13)))))))))
    else
        if (x .lt. 65.d0) then
!             xk >= 1.8  err < 1.2039D-17
            bk(0) = sqrt(xi) * exp(-xk) * (1.2533141373155000D0+xi*(1.7168113083556290D1 &
                    +xi*(8.4058065238156000D1+xi*(1.8451128616426320D2+xi*(1.8669475343307380D2 &
                    +xi*(8.0260256475123400D1+xi*(1.1540179557584240D1 &
                    +xi*(2.5982512903262070D-1)))))))) &
                    / (1.0000000000000000D0+xi*(1.3823172367487210D1 &
                    +xi*(6.8726216510427700D1+xi*(1.5491078396788470D2+xi*(1.6439268456283490D2 &
                    +xi*(7.7405808022562250D1+xi*(1.3529690413964630D1+xi*(5.4457906513011510D-1))))))))
!             xk >= 1.8  err < -1.9134D-17
            bk(1) = sqrt(xi) * exp(-xk) * (1.2533141373155000D0+xi*(1.6936161397080210D1 &
                    +xi*(8.2772897704525600D1+xi*(1.8584554680747990D2+xi*(2.0189606898235020D2 &
                    +xi*(1.0245683525072580D2+xi*(2.1105315978984250D1 &
                    +xi*(1.1660416083420830D0)))))))) &
                    / (1.0000000000000000D0+xi*(1.3138101697995840D1 &
                    +xi*(6.1233616494596590D1+xi*(1.2675776853743860D2+xi*(1.1952843443193260D2 &
                    +xi*(4.7118033617852210D1+xi*(6.0393000847364940D0+xi*(1.0811703622238420D-1))))))))
        else                !    computes exp(x) * K(i,x)
!             xk >= 1.8  err < 1.2039D-17
            bk(0) = sqrt(xi) * exp(x-xk) * (1.2533141373155000D0+xi*(1.7168113083556290D1 &
                    +xi*(8.4058065238156000D1+xi*(1.8451128616426320D2+xi*(1.8669475343307380D2 &
                    +xi*(8.0260256475123400D1+xi*(1.1540179557584240D1 &
                    +xi*(2.5982512903262070D-1)))))))) &
                    / (1.0000000000000000D0+xi*(1.3823172367487210D1 &
                    +xi*(6.8726216510427700D1+xi*(1.5491078396788470D2+xi*(1.6439268456283490D2 &
                    +xi*(7.7405808022562250D1+xi*(1.3529690413964630D1+xi*(5.4457906513011510D-1))))))))
!             xk >= 1.8  err < -1.9134D-17
            bk(1) = sqrt(xi) * exp(x-xk) * (1.2533141373155000D0+xi*(1.6936161397080210D1 &
                    +xi*(8.2772897704525600D1+xi*(1.8584554680747990D2+xi*(2.0189606898235020D2 &
                    +xi*(1.0245683525072580D2+xi*(2.1105315978984250D1 &
                    +xi*(1.1660416083420830D0)))))))) &
                    / (1.0000000000000000D0+xi*(1.3138101697995840D1 &
                    +xi*(6.1233616494596590D1+xi*(1.2675776853743860D2+xi*(1.1952843443193260D2 &
                    +xi*(4.7118033617852210D1+xi*(6.0393000847364940D0+xi*(1.0811703622238420D-1))))))))
        endif
    endif
    do i = 1, 30
            bk(i+1) = bk(i-1) + re(i+i) * xi * bk(i)
    enddo
    return
    end
! 
!    Numerical integrals:
! 
!          B(m,k) = 2 * Integral[s**(2k) * xs**(2m)
!             * khat(-m,xs * sqrt(rab**2+r**2 * (1 + 1/s**2), {s,0,1}]
!
!    bvk0:  k = 0,  m = 0, -1
!    bvkm1: k = -1, m = 0, 1
! 
!    khat(n,z) = z**n * K(n,z)
!    where K(n,z) stands for the corresponding Macdonald function
! 
!    These subroutines are no longer used. They are kept only for eventually testing purposes
!
  subroutine bvk0(xa, xb, xa2, xb2, Rabsq, r, rsq, bm1, b0)
    USE DAM320_D
    USE DAM320_CONST_D, ONLY: cero, uno, dos, umed, pi
    USE DAM320_LEGENDRE_D
    implicit none
    real(KREAL) :: arg, aux, b0, bk0, bk1, bm1, rabsq, r, rsq, sqr, xa, xa2, xb, xb2, xs2, xv2
    integer(KINT) :: iq
    bm1 = cero
    b0 = cero
    if ( xb2*rsq .gt. xa2*(rabsq+rsq)) then    !    Case of    xb*r > xa*Sqrt(R**2+r**2)
        do iq = nqleg, 1, -1
            xs2 = xb2 + xa2 * u(iq) * u(iq)
            arg = sqrt( xs2 * (rabsq + rsq * (uno + uno / (u(iq) * u(iq)))) )
            call bkhat01(arg,bk0,bk1)
            bm1 = bm1 + w(iq) * bk1 / xs2
            b0  = b0  + w(iq) * bk0
        enddo
        bm1 = bm1 + bm1
        b0 = b0 + b0
    else        !    Case of    xb*r < xa*Sqrt(R**2+r**2)
        aux = rabsq + rsq
        do iq = nqleg, 1, -1
            xv2 = xa2 + xb2 * u(iq) * u(iq)
            arg = sqrt( xv2 * (rsq + aux  / (u(iq) * u(iq))) )
            call bkhat01(arg,bk0,bk1)
            bm1 = bm1 + w(iq) * bk1 / xv2
            b0  = b0  + w(iq) * bk0  / (u(iq) * u(iq))
        enddo
        sqr = sqrt(rabsq+rsq)
        aux = umed * pi * exp(-(xa*r+xb*sqr))
        bm1 = dos * (aux / (xa*xb) - bm1)
        b0  = dos * (aux / (xa*sqr) - b0)
    endif
    return
    end
!
!   ***************************************************************
!
  subroutine bvkm1(xa, xb, xa2, xb2, Rabsq, r, rsq, b0, b1)
    USE DAM320_D
    USE DAM320_CONST_D, ONLY: cero, uno, dos, umed, pi
    USE DAM320_LEGENDRE_D
    implicit none
    real(KREAL) :: arg, aux, b0, b1, bk0, bk1, r, rabsq, rsq, sqr, xa, xa2, xb, xb2, xs2, xv2
    integer(KINT) :: iq
    b1 = cero
    b0 = cero
    if ( xb2*rsq .gt. xa2*(rabsq+rsq) .or. r .lt. 1.d-14) then    !    Case of    xb*r > xa*(R**2+r**2)
        aux = rabsq + rsq
        do iq = nqleg, 1, -1
            xs2 = xb2 + xa2 * u(iq) * u(iq)
            arg = sqrt( xs2 * (rabsq + rsq * (uno + uno / (u(iq) * u(iq)))) )
            call bkhat01(arg,bk0,bk1)
            b0 = b0 + w(iq) * bk0 / (u(iq) * u(iq))
            b1 = b1 + w(iq) * bk1 / (aux * u(iq) * u(iq) + rsq)
        enddo
        b0 = b0 + b0
        b1 = b1 + b1
    else        !    Case of    xb*r <= xa*sqrt(R**2+r**2)
        do iq = nqleg, 1, -1
            xv2 = xa2 + xb2 * u(iq) * u(iq)
            arg = sqrt( xv2 * (rsq + (rabsq + rsq) / (u(iq) * u(iq))) )
            call bkhat01(arg,bk0,bk1)
            b0  = b0  + w(iq) * bk0
            b1  = b1  + w(iq) * bk1 / (rabsq + rsq*(uno + u(iq) * u(iq)))
        enddo
        sqr = sqrt(rabsq+rsq)
        aux = umed * pi * exp(-(xa*r+xb*sqr) )
        b0 = dos * (aux / (xb*r) - b0)
        b1 = dos * (aux / (r*sqr) - b1)
    endif
    return
    end
!
!    -------------------------------------------------------------------------------------------------------    
!
!    Subroutine for computing multipolar moments of atomic fragments of a two-center
!    charge distribution of STO
!    Algorithm:
!        If zb >= za: 
!            Numerical integration with Legendre quadrature of 25 (optionally 35) points
!        else:
!            Asymptotic integrals:
!                qasint(l) = Integrate[f_l(u), {u,0,Infinity}]
!            Complementary integrals:
!                qcomp(l) = Integrate[f_l(u), {u,1/2,Infinity}]
!            If qcomp(l) < threshold (1.e-12):
!                asymptotic integral taken
!            else if Abs[qcomp(l)] < Abs[qasint(l)]:
!                qasint(l) - qcomp(l)  taken
!            else
!                Numerical integration with Legendre quadrature of 25 (optionally 35) points
!            endif
!        endif
!        
!
!    Rafa April 2012
  
  subroutine multfrg2c(nga, la, ngb, lb, za, zb, R)                                                                                                                                   
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE DAM320_LEGENDRE_D
    implicit none
    integer(KINT) :: i, l, la, lb, lmin, m, na, nb, nga, ngb
    real(KREAL) :: aux, R, za, zb
    if (za .gt. uno) then    ! Legendre quadrature rule with 25 points
        nqleg2 = 25
        u2 => uleg25
        w2 => wleg25
    else                    ! Legendre quadrature rule with 35 points
        nqleg2 = 35
        u2 => uleg35
        w2 => wleg35
    endif
    na = nga - la
    nb = ngb - lb
    cina(0) = 1
    aux = uno / (dos * za*za *R*R)
    do i = 1, na/2
        cina(i) = -cina(i-1) * re(na-i-i+2) * re(na-i-i+1) * ri(i) * aux
    enddo
    cinb(0) = 1
    aux = uno / (dos * zb*zb *R*R)
    do i = 1, nb/2
        cinb(i) = -cinb(i-1) * re(nb-i-i+2) * re(nb-i-i+1) * ri(i) * aux
    enddo
    pow2(0) = raiz2
    do i = 1, la + lb
        pow2(i) = pow2(i-1) + pow2(i-1)
    enddo
    qlmdst = cero    ! Initializes qlmdst
    if (za .gt. zb) then
        lmin = 0
        kmltan = kmltan + 1
        call multipan(na, la, nb, lb, lmin, lmaxexp, za, zb, R)
        if (lmin .le. lmaxexp) then
            do l = lmin, lmaxexp
                do m = -l, l
                    qlmdst(l*(l+1)+m+1) = cero
                enddo
            enddo
            kmltquad = kmltquad + 1
            call multipquad(na, la, nb, lb, lmin, lmaxexp, za, zb, R)
        endif
    else
        kmltquad = kmltquad + 1
        call multipquad(na, la, nb, lb, 0, lmaxexp, za, zb, R)
    endif
    qlm2c(1:(lmaxexp+1)*(lmaxexp+1)) = qlm2c(1:(lmaxexp+1)*(lmaxexp+1)) + qlmdst(1:(lmaxexp+1)*(lmaxexp+1))
    return
    end
!
!   ******************************************************************
!
!     Computes the multipolar moments analytically: see eqs (55) for asymptotic integral and (64) for complementary integral
!    of article "Auxiliary Functions for Integrals with Slater-type Orbitals II. Gauss Transform Methods"
!    Int. J. Quantum Chem. 108, 25-39, 2007.
!    Notice that eq(64) has an erratum, where it says 2p! must say 2^(p+1) p!
!
  subroutine multipan(na, la, nb, lb, lmin, lmax, za, zb, R)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    integer(KINT), intent(in) :: la, lb, lmax, na, nb
    integer(KINT), intent(out) :: lmin
    real(KREAL), intent(inout) :: R, za, zb
    integer(KINT) :: i, j, k, kk, kma, kmb, kp, kq, l, m, ma, mb
    real(KREAL) :: argk1, argk1sq, argk1sqi, argk2, argk2sq, argk2sqi, aux, auxi, bux, cux, dux, sgn, thrasint
    real(KREAL) :: bkv1(-2*mxn+1:mxltot), bkv2(-2*mxn+1:mxltot), powzamzb(0:2*mxn+lmaxexp+1), powzamzbi(0:2*mxn+lmaxexp+1)
    real(KREAL) :: powR(0:lmaxexp)
    ilow = -(na+la+nb+lb+1)
    iupp = lmax+la+lb
    qlmasint = cero    ! Initializes qlmasint
    aux = pt25 * R * R * (za*za - zb*zb)
    auxi = umed / aux
    powR(0) = uno
    do i = 1, lmaxexp
        powR(i) = powR(i-1) * R
    enddo
    powzamzb(0) = uno    !  powzamzb(i) = (R^2*(za^2-zb^2)/4)^i
    powzamzbi(0) = uno    !  powzamzbi(i) = (2/(R^2*(za^2-zb^2)))^i
    do i = 1, lmax+na+la+nb+lb+1
        powzamzb(i) = aux * powzamzb(i-1)
        powzamzbi(i) = auxi * powzamzbi(i-1)
    enddo
    auxu(0) = uno
    do i = 1, nb+la+lb
        auxu(i) = -auxu(i-1)
    enddo
!    Modified Bessel K functions of semiinteger order: bka(l+1/2,z) with arguments  R*zb  and  R*sqrt(umed*(za*za+zb*zb))
    argk1 = R * zb
    argk1sq = argk1 * argk1
    argk1sqi = uno / argk1sq
    argk2 = R * sqrt(umed*(za*za+zb*zb))
    argk2sq = argk2 * argk2
    argk2sqi = uno / argk2sq
    bkv1(0) = sqrt(umed * pi) * exp(-argk1)
    bkv1(-1) = bkv1(0) / argk1
    bkv2(0) = sqrt(umed * pi) * exp(-argk2)
    bkv2(-1) = bkv2(0) / argk2
    do i = 0, iupp-1        ! Upwards recursion
        bkv1(i+1) = dosl1(i) * bkv1(i) + argk1sq * bkv1(i-1)
        bkv2(i+1) = dosl1(i) * bkv2(i) + argk2sq * bkv2(i-1)
    enddo
    do i = -1, ilow+1, -1    ! Downwards recursion
        bkv1(i-1) = argk1sqi * ( bkv1(i+1) - dosl1(i) * bkv1(i) )
        bkv2(i-1) = argk2sqi * ( bkv2(i+1) - dosl1(i) * bkv2(i) )
    enddo
!    Computes the multipolar moments of the fragment on A
    aux = cuatro * R**(la+lb+na+na+nb+nb+1) * za**na * zb**nb
    do mb = -lb, lb
        do ma = -la, la
            bux = aux * roblk(ma,mb)    ! Introduces the normalization factors and the density matrix elements
            sgn = uno
            do kp = lb, abs(mb), -1
                kmb = kp*(kp+1)+mb+1
                do k = abs(ma), la
                    kma = k*(k+1)+ma+1
                    do kk = i1l1l2(kma,kmb), i2l1l2(kma,kmb)
                        if (k+kp-2*npl1l2(kk)+abs(mlm(lml1l2(kk))) .lt. 0) cycle
                        cux = bux * sgn * bin(ind(la+abs(ma))+k+abs(ma)+1) * bin(ind(lb+abs(mb))+kp+abs(mb)+1) &
                                * ccl1l2(kk) * fact(k+kp-2*npl1l2(kk)+abs(mlm(lml1l2(kk)))) * pow2(k+kp-npl1l2(kk)) &
                                * facts(k+kp-npl1l2(kk)) * ri(2*(k+kp-2*npl1l2(kk))+1)  &
                                * facti(k+kp-2*npl1l2(kk)-abs(mlm(lml1l2(kk))))
                        do i = 0, na/2
                            do j = 0, nb/2
                                dux = cux * cina(i) * cinb(j)
                                do l = max(abs(mlm(lml1l2(kk))),k+kp-2*npl1l2(kk),lmin), lmax
                                    qlmasint(l*(l+1)+mlm(lml1l2(kk))+1) = qlmasint(l*(l+1)+mlm(lml1l2(kk))+1) &
                                            + dux * bin(ind(l+abs(mlm(lml1l2(kk))))+k+kp-2*npl1l2(kk)+abs(mlm(lml1l2(kk)))+1)&
                                            * fact(l-abs(mlm(lml1l2(kk)))) * facti(l+abs(mlm(lml1l2(kk)))) * powR(l) &
                                            * dot_product( bin(ind(lb+nb+k-npl1l2(kk)-j)+1 : ind(lb+nb+k-npl1l2(kk)-j+1)) &
                                                    * auxu(0 : lb+nb+k-npl1l2(kk)-j) &
                                                    * fact(l+la+na+npl1l2(kk)-k-i : l+la+na+lb+nb-i-j) &
                                            , powzamzbi(l+la+na+npl1l2(kk)-k-i+1 : l+la+na+lb+nb-i-j+1) &
                                                    * bkv1(l+la-nb+2*npl1l2(kk)-2*k-kp+j : l+la+lb+npl1l2(kk)-k-kp) )
                                    do kq = 0, lb+nb+k-npl1l2(kk)-j
                                        scomp(kq) = dot_product(facti(0:l+la+na+npl1l2(kk)-k-i+kq) &
                                                * powzamzb(0:l+la+na+npl1l2(kk)-k-i+kq) &
                                                , bkv2(l+la-nb+2*npl1l2(kk)-2*k-kp+j+kq:-na-nb-k-kp+npl1l2(kk)+i+j:-1) )
                                    enddo
                                    qlmdst(l*(l+1)+mlm(lml1l2(kk))+1) = qlmdst(l*(l+1)+mlm(lml1l2(kk))+1) &
                                            + dux * bin(ind(l+abs(mlm(lml1l2(kk))))+k+kp-2*npl1l2(kk)+abs(mlm(lml1l2(kk)))+1)&
                                            * fact(l-abs(mlm(lml1l2(kk)))) * facti(l+abs(mlm(lml1l2(kk)))) * powR(l) &
                                            * dot_product( bin(ind(lb+nb+k-npl1l2(kk)-j)+1 : ind(lb+nb+k-npl1l2(kk)-j+1)) &
                                                    * auxu(0 : lb+nb+k-npl1l2(kk)-j) &
                                                    * fact(l+la+na+npl1l2(kk)-k-i : l+la+na+lb+nb-i-j) &
                                            , powzamzbi(l+la+na+npl1l2(kk)-k-i+1 : l+la+na+lb+nb-i-j+1) &
                                                    * scomp(0 : lb+nb+k-npl1l2(kk)-j) )
                                enddo
                            enddo
                        enddo
                    enddo
                enddo
                sgn = -sgn
            enddo
        enddo
    enddo
    lmin = lmax + 1
    if (za*R .ge. umed) then
        thrasint = 1.d-4
    else
        thrasint = 1.d-10
    endif
!    Checks the highest value of l for which the multipolar moments thus computed are reliable
    do l = 0, lmax
        do m = -l, l
            if (abs(qlmasint(l*(l+1)+m+1)) .lt. 1.d-10) then
                qlmdst(l*(l+1)+m+1) = cero
            else
                qlmdst(l*(l+1)+m+1) = qlmasint(l*(l+1)+m+1) - qlmdst(l*(l+1)+m+1)
                if (abs(qlmdst(l*(l+1)+m+1) / qlmasint(l*(l+1)+m+1)) .lt. thrasint) lmin = l
            endif
        enddo
        if (lmin .eq. l) exit
    enddo
    return
    end
!
!   ******************************************************************
!
!     Computes the multipolar moments by numerical integration (Legendre quadrature) 
  subroutine multipquad(na, la, nb, lb, lmin, lmax, za, zb, R)
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    USE DAM320_LEGENDRE_D
    implicit none
    integer(KINT) :: i, ierr, j, k, kk, kma, kmb, kp, l, lmax, lmin, la, lb, ma, mb, na, nb
    real(KREAL) :: aux, bux, cux, dux, R, sgn, za, zb
    real(KREAL) :: argk(mxleg), argk2(mxleg), argki2(mxleg), umuk(mxleg), powR(0:lmaxexp)
    ilow = -(na+la+nb+lb+1)
    iupp = 0

    allocate(bkmat(nqleg2,ilow:iupp), powu(nqleg2,0:lmax+na+la), pow1mu(nqleg2,0:nb+la+lb), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating: bkmat, powu and pow1mu. Stop')
    powR(0) = uno
    do i = 1, lmaxexp
        powR(i) = powR(i-1) * R
    enddo
    powu(1:nqleg2,0) = uno
    do i = 1, lmax+na+la
        powu(1:nqleg2,i) = umed * powu(1:nqleg2,i-1) * u2(1:nqleg2)
    enddo
    pow1mu(1:nqleg2,0) = uno
    do i = 1, nb+la+lb
        pow1mu(1:nqleg2,i) = pow1mu(1:nqleg2,i-1) * (uno-umed*u2(1:nqleg2))
    enddo
    argk(1:nqleg2) = R * sqrt(za*za*umed*u2(1:nqleg2) + zb*zb*(uno-umed*u2(1:nqleg2)))
    argk2(1:nqleg2) = argk(1:nqleg2) * argk(1:nqleg2)
    argki2(1:nqleg2) = uno / argk2(1:nqleg2)
!    Bessel K functions of semiinteger order: bka(l+1/2,z) with argument  za^2*u+zb^2*(1-u)   u: Legendre quadrature abscissae
    bkmat(1:nqleg2,0) = sqrt(umed * pi) * exp(-argk(1:nqleg2))
    bkmat(1:nqleg2,-1) = bkmat(1:nqleg2,0) / argk(1:nqleg2)
    do i = 0, iupp-1        ! Upwards recursion
        bkmat(1:nqleg2,i+1) = dosl1(i) * bkmat(1:nqleg2,i) + argk2(1:nqleg2) * bkmat(1:nqleg2,i-1)
    enddo
    do i = -1, ilow+1, -1    ! Downwards recursion
        bkmat(1:nqleg2,i-1) = argki2(1:nqleg2) * ( bkmat(1:nqleg2,i+1) - dosl1(i) * bkmat(1:nqleg2,i) )
    enddo
!    Computes the multipolar moments of the fragment on A
    aux = dos * R**(la+lb+na+na+nb+nb+1) * za**na * zb**nb    ! Introduces the factor (1/2) of the change of variable in integration
    do mb = -lb, lb
        do ma = -la, la
            bux = aux * roblk(ma,mb)    ! Introduces the normalization factors and the density matrix elements
            sgn = uno
            do kp = lb, abs(mb), -1
                kmb = kp*(kp+1)+mb+1
                do k = abs(ma), la
                    kma = k*(k+1)+ma+1
                    do kk = i1l1l2(kma,kmb), i2l1l2(kma,kmb)
                        if (k+kp-2*npl1l2(kk)+abs(mlm(lml1l2(kk))) .lt. 0) cycle
                        cux = bux * sgn * bin(ind(la+abs(ma))+k+abs(ma)+1) * bin(ind(lb+abs(mb))+kp+abs(mb)+1) &
                                * ccl1l2(kk) * fact(k+kp-2*npl1l2(kk)+abs(mlm(lml1l2(kk)))) * pow2(k+kp-npl1l2(kk)) &
                                * facts(k+kp-npl1l2(kk)) * ri(2*(k+kp-2*npl1l2(kk))+1)  &
                                * facti(k+kp-2*npl1l2(kk)-abs(mlm(lml1l2(kk))))
                        do i = 0, na/2
                            do j = 0, nb/2
                                dux = cux * cina(i) * cinb(j)
                                umuk(1:nqleg2) = w2(1:nqleg2) * pow1mu(1:nqleg2,lb+nb+k-npl1l2(kk)-j) &
                                        * bkmat(1:nqleg2,-(na+nb+k+kp-npl1l2(kk)-i-j+1))
                                do l = max(abs(mlm(lml1l2(kk))),k+kp-2*npl1l2(kk),lmin), lmax
                                    qlmdst(l*(l+1)+mlm(lml1l2(kk))+1) = qlmdst(l*(l+1)+mlm(lml1l2(kk))+1) &
                                            + dux * bin(ind(l+abs(mlm(lml1l2(kk))))+k+kp-2*npl1l2(kk)+abs(mlm(lml1l2(kk)))+1)&
                                            * fact(l-abs(mlm(lml1l2(kk)))) * facti(l+abs(mlm(lml1l2(kk)))) * powR(l) &
                                            * dot_product( powu(1:nqleg2,l+la+na+npl1l2(kk)-k-i), umuk(1:nqleg2) )
                                enddo
                            enddo
                        enddo
                    enddo
                enddo
                sgn = -sgn
            enddo
        enddo
    enddo
    deallocate(bkmat, powu, pow1mu)
    return
    end
!
!    ********************************************************
!
!    Subroutine for computing molecular multipolar moments from the multipolar moments of the &
!     fragments. Generated with trasladamultipolos2.nb with the procedure described in the &
!     libro de electrostatica.
!
  subroutine multmolec(qlm, qlmnuc)
    USE DAM320_D
    USE DAM320_DATA_D, zn_orig => zn
    USE DAM320_CONST_D
    implicit none
    real(KREAL) :: rab2, xab, yab, zab
    integer(KINT) :: i, ia, ierr, l, m
    real(KREAL) :: qlm((mxmult+1)**2), qlmnuc((mxmult+1)**2)
    real(KREAL) :: zlm(0:mxmult,-mxmult:mxmult)
    real(KREAL), allocatable :: zn(:)
    allocate(zn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating zn in multmolec. Stop')
    if (lvalence) then
        do i = 1, ncen
            zn(i) = atom_core(zn_orig(i))
        enddo
    else
        zn = zn_orig
    endif
    qlm = cero
    qlmnuc = cero
    do ia = 1, ncen
        xab = rcen(1,ia)
        yab = rcen(2,ia)
        zab = rcen(3,ia)
        rab2 = xab*xab+yab*yab+zab*zab
        zlm(0,0) = uno
        zlm(1,-1) = yab
        zlm(1,0) = zab
        zlm(1,1) = xab
        do l = 1, mxmult-1
            zlm(l+1,l+1) = dosl1(l)*(xab*zlm(l,l)-yab*zlm(l,-l))
            zlm(l+1,-(l+1)) = dosl1(l)*(yab*zlm(l,l)+xab*zlm(l,-l))
            zlm(l+1,l) = dosl1(l)*zab*zlm(l,l)
            zlm(l+1,-l) = dosl1(l)*zab*zlm(l,-l)
            do m = 0, l-1
                zlm(l+1,m)=(dosl1(l)*zab*zlm(l,m)-re(l+m)*rab2*zlm(l-1,m))*ri(l-m+1)
                zlm(l+1,-m)=(dosl1(l)*zab*zlm(l,-m)-re(l+m)*rab2*zlm(l-1,-m))*ri(l-m+1)
            enddo
        enddo
!    Contribution of the nuclear charge of center ia to the multipoles
        qlmnuc(1) = qlmnuc(1) + zn(ia)
        qlmnuc(2) = qlmnuc(2) + zlm(1,-1)*zn(ia)
        qlmnuc(3) = qlmnuc(3) + zlm(1,0)*zn(ia)
        qlmnuc(4) = qlmnuc(4) + zlm(1,1)*zn(ia)
        qlmnuc(5) = qlmnuc(5) + 0.0833333333333333D0*zlm(2,-2)*zn(ia)
        qlmnuc(6) = qlmnuc(6) + 0.3333333333333333D0*zlm(2,-1)*zn(ia)
        qlmnuc(7) = qlmnuc(7) + zlm(2,0)*zn(ia)
        qlmnuc(8) = qlmnuc(8) + 0.3333333333333333D0*zlm(2,1)*zn(ia)
        qlmnuc(9) = qlmnuc(9) + 0.0833333333333333D0*zlm(2,2)*zn(ia)
        qlmnuc(10) = qlmnuc(10) + 0.0027777777777778D0*zlm(3,-3)*zn(ia)
        qlmnuc(11) = qlmnuc(11) + 0.0166666666666667D0*zlm(3,-2)*zn(ia)
        qlmnuc(12) = qlmnuc(12) + 0.1666666666666667D0*zlm(3,-1)*zn(ia)
        qlmnuc(13) = qlmnuc(13) + zlm(3,0)*zn(ia)
        qlmnuc(14) = qlmnuc(14) + 0.1666666666666667D0*zlm(3,1)*zn(ia)
        qlmnuc(15) = qlmnuc(15) + 0.0166666666666667D0*zlm(3,2)*zn(ia)
        qlmnuc(16) = qlmnuc(16) + 0.0027777777777778D0*zlm(3,3)*zn(ia)
        qlmnuc(17) = qlmnuc(17) + 0.0000496031746032D0*zlm(4,-4)*zn(ia)
        qlmnuc(18) = qlmnuc(18) + 0.0003968253968254D0*zlm(4,-3)*zn(ia)
        qlmnuc(19) = qlmnuc(19) + 0.0055555555555556D0*zlm(4,-2)*zn(ia)
        qlmnuc(20) = qlmnuc(20) + 0.1000000000000000D0*zlm(4,-1)*zn(ia)
        qlmnuc(21) = qlmnuc(21) + zlm(4,0)*zn(ia)
        qlmnuc(22) = qlmnuc(22) + 0.1000000000000000D0*zlm(4,1)*zn(ia)
        qlmnuc(23) = qlmnuc(23) + 0.0055555555555556D0*zlm(4,2)*zn(ia)
        qlmnuc(24) = qlmnuc(24) + 0.0003968253968254D0*zlm(4,3)*zn(ia)
        qlmnuc(25) = qlmnuc(25) + 0.0000496031746032D0*zlm(4,4)*zn(ia)
        if (ngini(ia) .le. 0) cycle    ! If center without associated basis set, cycles
!    Contribution of the electronic fragments to the multipoles
        qlm(1) = qlm(1) - rmultip(1,ia)
        qlm(2) = qlm(2) - (zlm(1,-1)*rmultip(1,ia)+rmultip(2,ia))
        qlm(3) = qlm(3) - (zlm(1,0)*rmultip(1,ia)+rmultip(3,ia))
        qlm(4) = qlm(4) - (zlm(1,1)*rmultip(1,ia)+rmultip(4,ia))
        qlm(5) = qlm(5) - (0.0833333333333333D0*zlm(2,-2)*rmultip(1,ia)+0.5000000000000000D0*zlm(1,1) &
                *rmultip(2,ia)+0.5000000000000000D0*zlm(1,-1)*rmultip(4,ia)+rmultip(5,ia))
        qlm(6) = qlm(6) - (0.3333333333333333D0*zlm(2,-1)*rmultip(1,ia)+zlm(1,0)*rmultip(2,ia)+zlm(1,-1) &
                *rmultip(3,ia)+rmultip(6,ia))
        qlm(7) = qlm(7) - (zlm(2,0)*rmultip(1,ia)-1.0000000000000000D0*zlm(1,-1)*rmultip(2,ia) &
                +2.0000000000000000D0*zlm(1,0)*rmultip(3,ia)-1.0000000000000000D0*zlm(1,1)*rmultip(4,ia) &
                +rmultip(7,ia))
        qlm(8) = qlm(8) - (0.3333333333333333D0*zlm(2,1)*rmultip(1,ia)+zlm(1,1)*rmultip(3,ia)+zlm(1,0) &
                *rmultip(4,ia)+rmultip(8,ia))
        qlm(9) = qlm(9) - (0.0833333333333333D0*zlm(2,2)*rmultip(1,ia)-0.5000000000000000D0*zlm(1,-1) &
                *rmultip(2,ia)+0.5000000000000000D0*zlm(1,1)*rmultip(4,ia)+rmultip(9,ia))
        qlm(10) = qlm(10) - (0.0027777777777778D0*zlm(3,-3)*rmultip(1,ia)+0.0416666666666667D0*zlm(2,2) &
                *rmultip(2,ia)+0.0416666666666667D0*zlm(2,-2)*rmultip(4,ia)+0.5000000000000000D0*zlm(1,1) &
                *rmultip(5,ia)+0.5000000000000000D0*zlm(1,-1)*rmultip(9,ia)+rmultip(10,ia))
        qlm(11) = qlm(11) - (0.0166666666666667D0*zlm(3,-2)*rmultip(1,ia)+0.1666666666666667D0*zlm(2,1) &
                *rmultip(2,ia)+0.0833333333333333D0*zlm(2,-2)*rmultip(3,ia)+0.1666666666666667D0*zlm(2,-1) &
                *rmultip(4,ia)+zlm(1,0)*rmultip(5,ia)+0.5000000000000000D0*zlm(1,1)*rmultip(6,ia) &
                +0.5000000000000000D0*zlm(1,-1)*rmultip(8,ia)+rmultip(11,ia))
        qlm(12) = qlm(12) - (0.1666666666666667D0*zlm(3,-1)*rmultip(1,ia)+(zlm(2,0)+0.0833333333333333D0 &
                *zlm(2,2))*rmultip(2,ia)+0.6666666666666666D0*zlm(2,-1)*rmultip(3,ia)-0.0833333333333333D0 &
                *zlm(2,-2)*rmultip(4,ia)-1.0000000000000000D0*zlm(1,1)*rmultip(5,ia)+2.0000000000000000D0 &
                *zlm(1,0)*rmultip(6,ia)+zlm(1,-1)*rmultip(7,ia)+zlm(1,-1)*rmultip(9,ia)+rmultip(12,ia))
        qlm(13) = qlm(13) - (zlm(3,0)*rmultip(1,ia)-1.0000000000000000D0*zlm(2,-1)*rmultip(2,ia) &
                +3.0000000000000000D0*zlm(2,0)*rmultip(3,ia)-1.0000000000000000D0*zlm(2,1) &
                *rmultip(4,ia)-3.0000000000000000D0*zlm(1,-1)*rmultip(6,ia)+3.0000000000000000D0*zlm(1,0) &
                *rmultip(7,ia)-3.0000000000000000D0*zlm(1,1)*rmultip(8,ia)+rmultip(13,ia))
        qlm(14) = qlm(14) - (0.1666666666666667D0*zlm(3,1)*rmultip(1,ia)-0.0833333333333333D0*zlm(2,-2) &
                *rmultip(2,ia)+0.6666666666666666D0*zlm(2,1)*rmultip(3,ia)+(zlm(2,0)-0.0833333333333333D0 &
                *zlm(2,2))*rmultip(4,ia)-1.0000000000000000D0*zlm(1,-1)*rmultip(5,ia)+zlm(1,1)*rmultip(7,ia) &
                +2.0000000000000000D0*zlm(1,0)*rmultip(8,ia)-1.0000000000000000D0*zlm(1,1)*rmultip(9,ia) &
                +rmultip(14,ia))
        qlm(15) = qlm(15) - (0.0166666666666667D0*zlm(3,2)*rmultip(1,ia)-0.1666666666666667D0*zlm(2,-1) &
                *rmultip(2,ia)+0.0833333333333333D0*zlm(2,2)*rmultip(3,ia)+0.1666666666666667D0*zlm(2,1) &
                *rmultip(4,ia)-0.5000000000000000D0*zlm(1,-1)*rmultip(6,ia)+0.5000000000000000D0*zlm(1,1) &
                *rmultip(8,ia)+zlm(1,0)*rmultip(9,ia)+rmultip(15,ia))
        qlm(16) = qlm(16) - (0.0027777777777778D0*zlm(3,3)*rmultip(1,ia)-0.0416666666666667D0*zlm(2,-2) &
                *rmultip(2,ia)+0.0416666666666667D0*zlm(2,2)*rmultip(4,ia)-0.5000000000000000D0*zlm(1,-1) &
                *rmultip(5,ia)+0.5000000000000000D0*zlm(1,1)*rmultip(9,ia)+rmultip(16,ia))
        qlm(17) = qlm(17) - (0.0000496031746032D0*zlm(4,-4)*rmultip(1,ia)+0.0013888888888889D0*zlm(3,3) &
                *rmultip(2,ia)+0.0013888888888889D0*zlm(3,-3)*rmultip(4,ia)+0.0416666666666667D0*zlm(2,2) &
                *rmultip(5,ia)+0.0416666666666667D0*zlm(2,-2)*rmultip(9,ia)+0.5000000000000000D0*zlm(1,1) &
                *rmultip(10,ia)+0.5000000000000000D0*zlm(1,-1)*rmultip(16,ia)+rmultip(17,ia))
        qlm(18) = qlm(18) - (0.0003968253968254D0*zlm(4,-3)*rmultip(1,ia)+0.0083333333333333D0*zlm(3,2) &
                *rmultip(2,ia)+0.0027777777777778D0*zlm(3,-3)*rmultip(3,ia)+0.0083333333333333D0*zlm(3,-2) &
                *rmultip(4,ia)+0.1666666666666667D0*zlm(2,1)*rmultip(5,ia)+0.0416666666666667D0*zlm(2,2) &
                *rmultip(6,ia)+0.0416666666666667D0*zlm(2,-2)*rmultip(8,ia)+0.1666666666666667D0*zlm(2,-1) &
                *rmultip(9,ia)+zlm(1,0)*rmultip(10,ia)+0.5000000000000000D0*zlm(1,1)*rmultip(11,ia) &
                +0.5000000000000000D0*zlm(1,-1)*rmultip(15,ia)+rmultip(18,ia))
        qlm(19) = qlm(19) - (0.0055555555555556D0*zlm(4,-2)*rmultip(1,ia)+(0.0833333333333333D0*zlm(3,1) &
                +0.0027777777777778D0*zlm(3,3))*rmultip(2,ia)+0.0333333333333333D0*zlm(3,-2)*rmultip(3,ia) &
                +(0.0833333333333333D0*zlm(3,-1)-0.0027777777777778D0*zlm(3,-3))*rmultip(4,ia)+zlm(2,0) &
                *rmultip(5,ia)+0.3333333333333333D0*zlm(2,1)*rmultip(6,ia)+0.0833333333333333D0*zlm(2,-2) &
                *rmultip(7,ia)+0.3333333333333333D0*zlm(2,-1)*rmultip(8,ia)-1.0000000000000000D0*zlm(1,1) &
                *rmultip(10,ia)+2.0000000000000000D0*zlm(1,0)*rmultip(11,ia)+0.5000000000000000D0*zlm(1,1) &
                *rmultip(12,ia)+0.5000000000000000D0*zlm(1,-1)*rmultip(14,ia)+zlm(1,-1)*rmultip(16,ia) &
                +rmultip(19,ia))
        qlm(20) = qlm(20) - (0.1000000000000000D0*zlm(4,-1)*rmultip(1,ia)+(zlm(3,0)+0.0500000000000000D0 &
                *zlm(3,2))*rmultip(2,ia)+0.5000000000000000D0*zlm(3,-1)*rmultip(3,ia)-0.0500000000000000D0 &
                *zlm(3,-2)*rmultip(4,ia)-1.0000000000000000D0*zlm(2,1)*rmultip(5,ia)+(3.0000000000000000D0 &
                *zlm(2,0)+0.2500000000000000D0*zlm(2,2))*rmultip(6,ia)+zlm(2,-1) &
                *rmultip(7,ia)-0.2500000000000000D0*zlm(2,-2)*rmultip(8,ia)+zlm(2,-1) &
                *rmultip(9,ia)-3.0000000000000000D0*zlm(1,1)*rmultip(11,ia)+3.0000000000000000D0*zlm(1,0) &
                *rmultip(12,ia)+zlm(1,-1)*rmultip(13,ia)+3.0000000000000000D0*zlm(1,-1)*rmultip(15,ia) &
                +rmultip(20,ia))
        qlm(21) = qlm(21) - (zlm(4,0)*rmultip(1,ia)-1.0000000000000000D0*zlm(3,-1)*rmultip(2,ia) &
                +4.0000000000000000D0*zlm(3,0)*rmultip(3,ia)-1.0000000000000000D0*zlm(3,1)*rmultip(4,ia) &
                +zlm(2,-2)*rmultip(5,ia)-4.0000000000000000D0*zlm(2,-1)*rmultip(6,ia)+6.0000000000000000D0 &
                *zlm(2,0)*rmultip(7,ia)-4.0000000000000000D0*zlm(2,1)*rmultip(8,ia)+zlm(2,2) &
                *rmultip(9,ia)-6.0000000000000000D0*zlm(1,-1)*rmultip(12,ia)+4.0000000000000000D0*zlm(1,0) &
                *rmultip(13,ia)-6.0000000000000000D0*zlm(1,1)*rmultip(14,ia)+rmultip(21,ia))
        qlm(22) = qlm(22) - (0.1000000000000000D0*zlm(4,1)*rmultip(1,ia)-0.0500000000000000D0*zlm(3,-2) &
                *rmultip(2,ia)+0.5000000000000000D0*zlm(3,1)*rmultip(3,ia)+(zlm(3,0)-0.0500000000000000D0 &
                *zlm(3,2))*rmultip(4,ia)-1.0000000000000000D0*zlm(2,-1)*rmultip(5,ia)-0.2500000000000000D0 &
                *zlm(2,-2)*rmultip(6,ia)+zlm(2,1)*rmultip(7,ia)+(3.0000000000000000D0 &
                *zlm(2,0)-0.2500000000000000D0*zlm(2,2))*rmultip(8,ia)-1.0000000000000000D0*zlm(2,1) &
                *rmultip(9,ia)-3.0000000000000000D0*zlm(1,-1)*rmultip(11,ia)+zlm(1,1)*rmultip(13,ia) &
                +3.0000000000000000D0*zlm(1,0)*rmultip(14,ia)-3.0000000000000000D0*zlm(1,1)*rmultip(15,ia) &
                +rmultip(22,ia))
        qlm(23) = qlm(23) - (0.0055555555555556D0*zlm(4,2)*rmultip(1,ia)+(-0.0833333333333333D0 &
                *zlm(3,-1)-0.0027777777777778D0*zlm(3,-3))*rmultip(2,ia)+0.0333333333333333D0*zlm(3,2) &
                *rmultip(3,ia)+(0.0833333333333333D0*zlm(3,1)-0.0027777777777778D0*zlm(3,3)) &
                *rmultip(4,ia)-0.3333333333333333D0*zlm(2,-1)*rmultip(6,ia)+0.0833333333333333D0*zlm(2,2) &
                *rmultip(7,ia)+0.3333333333333333D0*zlm(2,1)*rmultip(8,ia)+zlm(2,0) &
                *rmultip(9,ia)-1.0000000000000000D0*zlm(1,-1)*rmultip(10,ia)-0.5000000000000000D0*zlm(1,-1) &
                *rmultip(12,ia)+0.5000000000000000D0*zlm(1,1)*rmultip(14,ia)+2.0000000000000000D0*zlm(1,0) &
                *rmultip(15,ia)-1.0000000000000000D0*zlm(1,1)*rmultip(16,ia)+rmultip(23,ia))
        qlm(24) = qlm(24) - (0.0003968253968254D0*zlm(4,3)*rmultip(1,ia)-0.0083333333333333D0*zlm(3,-2) &
                *rmultip(2,ia)+0.0027777777777778D0*zlm(3,3)*rmultip(3,ia)+0.0083333333333333D0*zlm(3,2) &
                *rmultip(4,ia)-0.1666666666666667D0*zlm(2,-1)*rmultip(5,ia)-0.0416666666666667D0*zlm(2,-2) &
                *rmultip(6,ia)+0.0416666666666667D0*zlm(2,2)*rmultip(8,ia)+0.1666666666666667D0*zlm(2,1) &
                *rmultip(9,ia)-0.5000000000000000D0*zlm(1,-1)*rmultip(11,ia)+0.5000000000000000D0*zlm(1,1) &
                *rmultip(15,ia)+zlm(1,0)*rmultip(16,ia)+rmultip(24,ia))
        qlm(25) = qlm(25) - (0.0000496031746032D0*zlm(4,4)*rmultip(1,ia)-0.0013888888888889D0*zlm(3,-3) &
                *rmultip(2,ia)+0.0013888888888889D0*zlm(3,3)*rmultip(4,ia)-0.0416666666666667D0*zlm(2,-2) &
                *rmultip(5,ia)+0.0416666666666667D0*zlm(2,2)*rmultip(9,ia)-0.5000000000000000D0*zlm(1,-1) &
                *rmultip(10,ia)+0.5000000000000000D0*zlm(1,1)*rmultip(16,ia)+rmultip(25,ia))
    enddo
    return
    end
!**********************************************************************
!    subroutine consta1
!
!    Computes and stores auxiliary constants
!        re(i) = dfloat(i)
!        r1(i) = 1.d0 / dfloat(i)
!        fact(i) = dfloat(i!)
!        facti(i) = 1.d0 / dfloat(i!)
!        facts(i) = dfloat((i+1/2)!)
!
!**********************************************************************
  subroutine consta1
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    integer(KINT) :: i, ierr, ikt, ip, j, k, k1, k12, knt, kntlm, l, l1, l1l1, l2, l2l2, la, lb, lm, lmtot, lp
    integer(KINT) :: m, m1, m1a, m2, m2a, ma, mb, md, ms, n, np
    real(KREAL) :: aux, aux1, aux2, auxk, auxm, bux, cux, sd, sgn, ss
!    auxiliary parameters and functions
    pi = acos(-uno)
    raizpi = sqrt(pi)
    pimed = umed * pi
    re(0) = cero
    ri(0) = 1.d300
    dosl1(0) = uno
    dosl1i(0) = uno
    do i = 1, mxreal
        re(i) = re(i-1) + uno        ! dfloat(i)
        re(-i) = -re(i)
        ri(i) = uno / re(i)           ! uno / dfloat(i)
        ri(-i) = -ri(i)
        dosl1(i) = re(i) + re(i) + uno    ! dfloat(i+i+1)
        dosl1(-i) = -re(i) - re(i) + uno
        dosl1i(i) = uno / dosl1(i)        ! dfloat( 1/(i+i+1) )
        dosl1i(-i) = uno / dosl1(-i)
    enddo
    fact(0) = uno
    facti(0) = uno
    facts(-1) = raizpi
    facts(0) = facts(-1) * umed
    do i = 1, mxfact
        fact(i) = fact(i-1) * re(i)               !  i!
        facts(i) = facts(i-1) * re(i+i+1) * umed    ! (i+1/2)!
        facti(i) = uno / fact(i)                    !  uno / i!
    enddo
    return
    end
!**********************************************************************
!    subroutine consta2
!
!    Computes and stores auxiliary constants
!        ind(i) = i*(i+1)/2
!        root(i) = dfloat(sqrt(i))
!        rooti(i) = 1.d0 / dfloat(sqrt(i))
!        bin(l*(l+1)/2+m+1) = Binomial(l,m)
!        ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m)
!            / (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
!
!       and many other
!
!**********************************************************************
  subroutine consta2
    USE DAM320_D
    USE DAM320_CONST_D
    USE DAM320_DATA_D
    implicit none
    integer(KINT) :: i, ierr, ikt, ip, j, k, k1, k12, knt, kntlm, l, l1, l1l1, l2, l2l2, la, lb, lm, lmtot, lp
    integer(KINT) :: m, m1, m1a, m2, m2a, ma, mb, md, ms, n, np
    real(KREAL) :: aux, aux1, aux2, auxk, auxm, bux, cux, sd, sgn, ss

!    auxiliary parameters and functions
    allocate(umedpow(0:lmaxexp), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating umedpow in consta. Stop')
    umedpow(0) = uno                            !
    do i = 1, lmaxexp                            !
        umedpow(i) = umedpow(i-1) * umed            ! 1 / 2^i
    enddo
    mxind = (mxltot+1)*(mxltot+2)/2
    allocate(ind(0:mxind), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ind in consta. Stop')
    ind(0) = 0
    do i = 1, mxind
        ind(i) = ind(i-1) + i         !  i*(i+1)/2
    enddo
    root(0) = cero
    do i = 1, mxroot
        root(i) = sqrt(re(i))        !  sqrt(i)
        rooti(i) = uno / root(i)     !  uno / sqrt(i)
    enddo
    mxbin = max(mxltot,mxlenpol)
    allocate(bin((mxbin+1)*(mxbin+2)/2), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating bin in consta. Stop')
    lm = 0
    do l = 0, mxbin
        do m = 0, l
            lm = lm + 1
            bin(lm) = fact(l) * facti(m) * facti(l-m)
        end do
    end do
    allocate(ang((lmaxexp+1)*(lmaxexp+2)/2), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ang in consta. Stop')
!    ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m) / (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
    ang(1) = umed / raizpi
    lm = 1
    do l = 1, lmaxexp
        lm = lm + 1
        ang(lm) = ang(1) * sqrt(re(2*l+1))
        aux = ang(lm) * raiz2
        do m = 1, l
            lm = lm + 1
            aux = aux / sqrt(re(l-m+1)*re(l+m))
            ang(lm) = aux
        enddo
    enddo
!     Tabulates the coefficients for the decomposition of products
!     of two functions depending on phi (sin (m*phi), cos (m*phi))
!     into functions of the same type
    mxemes = mxltot
    allocate(ssv(-mxemes:mxemes,-mxemes:mxemes), sdv(-mxemes:mxemes,-mxemes:mxemes), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ssv and sdv in consta. Stop')
    allocate(msv(-mxemes:mxemes,-mxemes:mxemes), mdv(-mxemes:mxemes,-mxemes:mxemes), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating msv and mdv in consta. Stop')
    do m2 = -mxemes, mxemes
        do m1 = -mxemes, mxemes
            call emes ( m1, m2, ms, md, ss, sd )
            msv(m1,m2) = ms
            mdv(m1,m2) = md
            ssv(m1,m2) = ss
            sdv(m1,m2) = sd
        enddo
    enddo
!    Coefficients for the decomposition of products of regular spherical harmonics into
!    regular spherical harmonics
    mxlcof = mxltot*(mxltot+3)/2
    mxkcof = mxlcof*(mxlcof+3)/2
    allocate(app(0:2*mxltot+1,0:mxkcof), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating app in consta. Stop')
    if (longoutput) write(6,"('Size of app   = ', i15, ' bytes')") size(app)

    allocate(bpp(0:2*mxltot+1,0:mxkcof), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating bpp in consta. Stop')
    if (longoutput) write(6,"('Size of bpp   = ', i15, ' bytes')") size(bpp)

    call acof
    call bcof
!    Tabulates some auxiliary indices for locating the previous coefficients
    allocate(indk12((mxltot+1)**2,(mxltot+1)**2), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating indk12 in consta. Stop')
    do l2 = 0,mxltot
        do l1 = 0,mxltot
            do m2 = -l2, l2
                do m1 = -l1, l1
                    l1l1 = ind(l1)
                    l2l2 = ind(l2)
                    m1a = abs(m1)
                    m2a = abs(m2)
                    if ( l1.eq.l2 ) then
                        k1 = l1l1 + max(m1a,m2a)
                        k12 = ind(k1) + l1l1 + min(m1a,m2a)
                    elseif (l1.gt.l2) then
                        k1 = l1l1 + m1a
                        k12 = ind(k1) + l2l2 + m2a
                    else
                        k1 = l2l2 + m2a
                        k12 = ind(k1) + l1l1 + m1a
                    endif
                    indk12(l1*(l1+1)+m1+1,l2*(l2+1)+m2+1) = k12
                end do
            end do
        end do
    end do
!
!    Arrays  llm, mlm, i1l1l2, i2l1l2, lml1l2, npl1l2, ccl1l2
!    corresponding to the decomposition of the product of two solid spherical harmonics placed in the same center 
!    in terms of spherical harmonics placed at the same center.
!    The meaning of the indices is as follows. 
!    The decomposition of the product is:
!
!        z_l^m(r_A) * z_lp^mp(r_A) = sum_la sum_mu  c_{la,mu}^{l,m;lp,mp} * r_A^(2*la) * z_{l+lp-2*la}^{mu}(r_A)
!
!    the summation on la runs over:    0 <= la <= min(l,lp,(l+lp-|mu|)/2
!    the summation on mu contains two terms at most
!    the values of la and mu, and the corresponding coefficients c_{la,mu}^{l,m;lp,mp} on the r.h.s. are sequentially 
!    stored in arrays:  npl1l2 (for la), ccl1l2 (for c_{la,mu}^{l,m;lp,mp}).
!    Besides them, some related indices are stored:      
!        llm(lm) --> extracts the value of  l  corresponding to an index lm, 
!        mlm(lm) --> extracts the value of  m  corresponding to an index lm, 
!        (l+lp-2*la) * (l+lp-2*la+1) + mu + 1 --> lml1l2   (i.e., the contracted index for the indices in the harmonic on the r.h.s.)
!    The arrays i1l1l2, and i2l1l1 contain the positions in the arrays at which
!    the values of la, mu, c_{la,mu}^{l,m;lp,mp}... corresponding to {l,m;lp,mp} start and end
!    The pairs of indices {l,m} are contracted to a single one as:  lm = l*(l+1)+m+1.
!    Therefore, the values of la, mu, c_{la,mu}^{l,m;lp,mp}... corresponding to {l,m;lp,mp} start at
!        i1l1l2(l*(l+1)+m+1,lp*(lp+1)+mp+1)  and end at  i2l1l2(l*(l+1)+m+1,lp*(lp+1)+mp+1)
!     
!    The next loop block determines the size of the arrays
!
    ikt = 0
    do la = 0, mxltot
        do lb = 0, mxltot
            do ma = -la, la
                do mb = -lb, lb
                    ms = msv(ma,mb)
                    md = mdv(ma,mb)
                    ss = ssv(ma,mb)
                    sd = sdv(ma,mb)
                    if (ss .ne. cero) then
                        do l = la+lb, max(abs(la-lb),abs(ms)), -2
                            ikt = ikt+1
                        enddo
                    endif
                    if (sd .ne. cero) then
                        do l = la+lb, max(abs(la-lb),abs(md)), -2
                            ikt = ikt+1
                        enddo
                    endif
                enddo
            enddo
        enddo
    enddo
    idimlml1l2 = ikt
!     allocates memory for arrays  llm, mlm, i1l1l2, i2l1l2, lml1l2, npl1l2, ccl1l2
    lmtot = (mxltot+1)*(mxltot+1)
    allocate(llm(lmtot))
    if (.not. allocated(llm)) call error(1,'Memory error when allocating llm. Stop')
    if (longoutput) write(6,"('Size of llm   = ', i15, ' bytes')") size(llm)

    allocate(mlm(lmtot))
    if (.not. allocated(mlm)) call error(1,'Memory error when allocating mlm. Stop')
    if (longoutput) write(6,"('Size of mlm   = ', i15, ' bytes')") size(mlm)

    allocate(i1l1l2(lmtot,lmtot))
    if (.not. allocated(i1l1l2)) call error(1,'Memory error when allocating i1l1l2. Stop')
    if (longoutput) write(6,"('Size of i1l1l2   = ', i15, ' bytes')") size(i1l1l2)

    allocate(i2l1l2(lmtot,lmtot))
    if (.not. allocated(i2l1l2)) call error(1,'Memory error when allocating i2l1l2. Stop')
    if (longoutput) write(6,"('Size of i2l1l2   = ', i15, ' bytes')") size(i2l1l2)

    allocate(lml1l2(idimlml1l2))
    if (.not. allocated(lml1l2)) call error(1,'Memory error when allocating lmlalb. Stop')
    if (longoutput) write(6,"('Size of lml1l2   = ', i15, ' bytes')") size(lml1l2)

    allocate(npl1l2(idimlml1l2))
    if (.not. allocated(npl1l2)) call error(1,'Memory error when allocating nplalb. Stop')
    if (longoutput) write(6,"('Size of npl1l2   = ', i15, ' bytes')") size(npl1l2)

    allocate(ccl1l2(idimlml1l2))
    if (.not. allocated(ccl1l2)) call error(1,'Memory error when allocating cclalb. Stop')
    if (longoutput) write(6,"('Size of ccl1l2   = ', i15, ' bytes')") size(ccl1l2)

!    Computes and stores  arrays  llm, mlm, i1l1l2, i2l1l2, lml1l2, npl1l2, ccl1l2
    lm = 0
    do l = 0, mxltot
        do m = -l, l
            lm = lm + 1
            llm(lm) = l
            mlm(lm) = m
        enddo
    enddo
    ikt = 0
    do la = 0, mxltot
        do lb = 0, mxltot
            do ma = -la, la
                do mb = -lb, lb
                    i1l1l2(la*(la+1)+ma+1, lb*(lb+1)+mb+1) = ikt + 1
                    k12 = indk12(la*(la+1)+ma+1,lb*(lb+1)+mb+1)
                    ms = msv(ma,mb)
                    md = mdv(ma,mb)
                    ss = ssv(ma,mb)
                    sd = sdv(ma,mb)
                    if (ms .ge. md) then
                        do l = abs(la-lb), la+lb, 2
                            if (l .ge. abs(md) .and. sd .ne. cero .and. abs(bpp(l,k12)) .gt. 1.d-13) then
                                ikt = ikt+1
                                lml1l2(ikt) = l*(l+1) + md + 1
                                ccl1l2(ikt) = sd * bpp(l,k12)
                                npl1l2(ikt) = (la+lb-l) / 2
                            endif
                            if (l .ge. abs(ms) .and. ss .ne. cero .and. abs(app(l,k12)) .gt. 1.d-13) then
                                ikt = ikt+1
                                lml1l2(ikt) = l*(l+1) + ms + 1
                                ccl1l2(ikt) = ss * app(l,k12)
                                npl1l2(ikt) = (la+lb-l) / 2
                            endif
                        enddo
                    else
                        do l = abs(la-lb), la+lb, 2
                            if (l .ge. abs(ms) .and. ss .ne. cero .and. abs(app(l,k12)) .gt. 1.d-13) then
                                ikt = ikt+1
                                lml1l2(ikt) = l*(l+1) + ms + 1
                                ccl1l2(ikt) = ss * app(l,k12)
                                npl1l2(ikt) = (la+lb-l) / 2
                            endif
                            if (l .ge. abs(md) .and. sd .ne. cero .and. abs(bpp(l,k12)) .gt. 1.d-13) then
                                ikt = ikt+1
                                lml1l2(ikt) = l*(l+1) + md + 1
                                ccl1l2(ikt) = sd * bpp(l,k12)
                                npl1l2(ikt) = (la+lb-l) / 2
                            endif
                        enddo
                    endif
                    i2l1l2(la*(la+1)+ma+1,lb*(lb+1)+mb+1) = ikt
                enddo
            enddo
        enddo
    enddo
!    Tabulates the coefficients of Chebyshev T polynomials in decreasing powers of the variable
    knt = 0
    do j = 0, mxlenpol-1
        sgn = uno
        do n = 0, j/2
            knt = knt + 1
            chebTcf(knt) = cero
            do k = 0, j/2-n
                chebTcf(knt) = chebTcf(knt) + bin(ind(j)+2*(n+k)+1) * bin(ind(n+k)+k+1)
            enddo
            chebTcf(knt) = sgn * chebTcf(knt)
            sgn = -sgn
        enddo
    enddo
    deallocate(app, bpp)
!    Constants for overlap integrals with ellipsoidal coordinates
    allocate (ap((mxn+1)*(mxn+1)*(mxn+3)))
    if (.not. allocated(ap)) call error(1,'Memory error when allocating ap. Stop')
    if (longoutput) write(6,"('Size of ap   = ', i15, ' bytes')") size(ap)
    allocate (alfasol((2*mxl+1)*(mxl+1)*(mxl+2)*(30+mxl*(43+17*mxl))/60))
    if (.not. allocated(alfasol)) call error(1,'Memory error when allocating alfasol. Stop')
    if (longoutput) write(6,"('Size of alfasol   = ', i15, ' bytes')") size(alfasol)
    allocate (ipntap(0:mxn,0:mxn))
    if (.not. allocated(ipntap)) call error(1,'Memory error when allocating ipntap. Stop')
    if (longoutput) write(6,"('Size of ipntap   = ', i15, ' bytes')") size(ipntap)
    allocate (ipntalfa((mxl+1)*(mxl+2)/2,0:mxl))
    if (.not. allocated(ipntalfa)) call error(1,'Memory error when allocating ipntalfa. Stop')
    if (longoutput) write(6,"('Size of ipntalfa   = ', i15, ' bytes')") size(ipntalfa)
!    ap(n,np,p) = (-1)**p * Sum[ n! np! (-1)**i / ((n-i)! (np-p-i)! (p-i)! i!) , {i,Max(0,p-np),min(n,p)}]
!        these constants are stored in a one-dimension array: ap(n,np,p)->an(ipntap(n,np)+p)
!        where ipntap(n,np) is a pointer to the ap(n,np,0) element in the array

    ipntap(0,0) = 1
    ap(1) = uno    !    ap(0,0,0)
    ipntap(0,1) = 2
    ap(2) = uno    !    ap(0,1,0)
    ap(3) = -uno    !    ap(0,1,1)
    knt = 3
    do np = 2, mxn
        knt = knt + 1
        ipntap(0,np) = knt
        ap(knt) = uno    !    ap(0,np,0) = 1
        do ip = 1, np-1
            knt = knt + 1
            ap(knt) = ap(ipntap(0,np-1)+ip) - ap(ipntap(0,np-1)+ip-1)
        enddo
        knt = knt + 1
        ap(knt) = - ap(ipntap(0,np-1)+np-1)
    enddo
    do n = 1, mxn
        do np = 0, mxn
            knt = knt + 1
            ipntap(n,np) = knt
            ap(knt) = uno    !    ap(n,np,0) = 1
            do ip = 1, n+np-1
                knt = knt + 1
                ap(knt) = ap(ipntap(n-1,np)+ip) + ap(ipntap(n-1,np)+ip-1)
            enddo
            knt = knt + 1
            ap(knt) = ap(ipntap(n-1,np)+n+np-1)
        enddo
    enddo
!    Coefficients for the decomposition of the products of regular harmonics in powers of ellipsoidal coordinates:
!
!    z_L^M(r_A) z_{L'}^M(r_B) = \frac{1}{2} \, (1+cos 2 M \phi) (/2)^{L+L'} 
!        \sum_{k=0}^{L+L'} \sum_{j=0}^{2k} \xi^{2k-j} \, \eta^j \; \alpha_{kj}^{LM \, L'M}
!
!    algorithm for allocaling the position of an element \alpha_{kj}^{LM \, L'M} in the array alfa:
!        \alpha_{kj}^{LM \, L'M} -> alfasol( ipntalfa( l + m*(2*mxl-m+1) /2 + 1 ,L') + k^2 + j )
    knt = 1
    kntlm = 0
    auxm = uno    !    auxm = (-1)**m * 2**m * ( (m-1/2)! m! / sqrt(pi) )**2
    do m = 0, mxl
        kntlm = kntlm + 1
        ipntalfa(kntlm,m) = knt
        auxk = auxm
        alfasol(knt) = auxk * facti(m) * facti(m)
        knt = knt + 1
        do k = 1, m+m
            auxk = -auxk
            do i = 0, k-1
                if (m-k+i .ge. 0 .and. m .ge. i) then
                    alfasol(knt) = auxk * facti(m-k+i) * facti(m-i) * facti(k-i) * facti(i)
                else
                    alfasol(knt) = cero
                endif
                knt = knt + 1
                alfasol(knt) = cero
                knt = knt + 1
            enddo
            if (m .ge. k) then
                alfasol(knt) = auxk * facti(m) * facti(m-k) * facti(k)
            else
                alfasol(knt) = cero
            endif
            knt = knt + 1
        enddo
        do lp = m, mxl-1
            ipntalfa(kntlm,lp+1) = knt
            aux1 = -re(lp+lp+1) * ri(lp-m+1)
            aux2 = -re(lp+m) * ri(lp-m+1)
            do k = 0, lp+m+1
                do j = 0, k+k
                    if (k .lt. lp+m+1) then
                        bux = alfasol(ipntalfa(kntlm,lp)+k*k+j)
                    else
                        bux = cero
                    endif
                    cux = cero
                    if (k .gt. 0) then
                        if (j .gt. 0 .and. j .lt. k+k) bux = bux - alfasol(ipntalfa(kntlm,lp)+(k-1)*(k-1)+j-1)
                        if (lp .gt. m) then
                            if (k .le. lp+m) then
                                if (j .le. k+k-2) cux = cux + alfasol(ipntalfa(kntlm,lp-1)+(k-1)*(k-1)+j)
                                if (j .gt. 0) then
                                    if (j .lt. k+k) cux = cux - dos * alfasol(ipntalfa(kntlm,lp-1)+(k-1)*(k-1)+j-1)
                                    if (j .gt. 1) cux = cux + alfasol(ipntalfa(kntlm,lp-1)+(k-1)*(k-1)+j-2)
                                endif
                            endif
                        endif
                    endif
                    alfasol(knt) = aux1 * bux + aux2 * cux
                    if (abs(alfasol(knt)) .lt. alfacutoff) alfasol(knt) = cero
                    knt = knt + 1
                enddo
            enddo
        enddo
        do l = m, mxl-1
            kntlm = kntlm + 1
            ipntalfa(kntlm,m) = knt
            aux1 = re(l+l+1) * ri(l-m+1)
            aux2 = -re(l+m) * ri(l-m+1)
            do k = 0, l+m+1
                do j = 0, k+k
                    if (k .lt. l+m+1) then
                        bux = alfasol(ipntalfa(kntlm-1,m)+k*k+j)
                    else
                        bux = cero
                    endif
                    cux = cero
                    if (k .gt. 0) then
                        if (j .gt. 0 .and. j .lt. k+k) bux = bux + alfasol(ipntalfa(kntlm-1,m)+(k-1)*(k-1)+j-1)
                        if (l .gt. m) then
                            if (k .le. l+m) then
                                if (j .le. k+k-2) cux = cux + alfasol(ipntalfa(kntlm-2,m)+(k-1)*(k-1)+j)
                                if (j .gt. 0) then
                                    if (j .lt. k+k) cux = cux + dos * alfasol(ipntalfa(kntlm-2,m)+(k-1)*(k-1)+j-1)
                                    if (j .gt. 1) cux = cux + alfasol(ipntalfa(kntlm-2,m)+(k-1)*(k-1)+j-2)
                                endif
                            endif
                        endif
                    endif
                    alfasol(knt) = aux1 * bux + aux2 * cux
                    if (abs(alfasol(knt)) .lt. alfacutoff) alfasol(knt) = cero
                    knt = knt + 1
                enddo
            enddo
            do lp = m, mxl-1
                ipntalfa(kntlm,lp+1) = knt
                aux1 = -re(lp+lp+1) * ri(lp-m+1)
                aux2 = -re(lp+m) * ri(lp-m+1)
                do k = 0, l+lp+2
                    do j = 0, k+k
                        if (k .lt. l+lp+2) then
                            bux = alfasol(ipntalfa(kntlm,lp)+k*k+j)
                        else
                            bux = cero
                        endif
                        cux = cero
                        if (k .gt. 0) then
                            if (j .gt. 0 .and. j .lt. k+k) bux = bux - alfasol(ipntalfa(kntlm,lp)+(k-1)*(k-1)+j-1)
                            if (lp .gt. m) then
                                if (k .le. l+lp+1) then
                                    if (j .le. k+k-2) cux = cux + alfasol(ipntalfa(kntlm,lp-1)+(k-1)*(k-1)+j)
                                    if (j .gt. 0) then
                                        if (j .lt. k+k) cux = cux - dos * alfasol(ipntalfa(kntlm,lp-1)+(k-1)*(k-1)+j-1)
                                        if (j .gt. 1) cux = cux + alfasol(ipntalfa(kntlm,lp-1)+(k-1)*(k-1)+j-2)
                                    endif
                                endif
                            endif
                        endif
                        alfasol(knt) = aux1 * bux + aux2 * cux
                        if (abs(alfasol(knt)) .lt. alfacutoff) alfasol(knt) = cero
                        knt = knt + 1
                    enddo
                enddo
            enddo
        enddo
        auxm = - auxm * re(m+1) * re(m+1) * re(m+m+1) * re(m+m+1)
    enddo

    return
    end
!
!   *******************************************************************
!
  subroutine acof
    USE DAM320_D
    USE DAM320_DATA_D, only: mxltot
    USE DAM320_CONST_D
    implicit none
    integer(KINT) :: k1, k2, k20, k200, kk, kk0, kk00, l, lp, m, m1, mp, n
    real(KREAL) :: aux, bux
    app = cero
!
!   starting elements app(00,lm)(n) = delta(l,n)
!
    k1 = 0
    do l = 0 , mxltot
        do m = 0 , l
            kk = ind(k1)
            app(l,kk) = uno
            k1 = k1 + 1
        enddo
    enddo
!
!   elements app(lm,m'm')(n)
!
    do mp = 1 , mxltot
        k2 = ind(mp) + mp
        k20 = ind(mp-1) + mp-1
        do l = mp , mxltot
            if ( l.eq.mp ) then
                m1 = mp
            else
                m1 = 0
            endif
            do m = m1 , l
                k1 = ind(l) + m
                kk = ind(k1) + k2
                kk0 = ind(k1) + k20
                do n = l-mp , l+mp , 2
                    if ( n.ge.m+mp) then
                        app(n,kk) = (2*mp-1) * ( app(n-1,kk0) * ri(n+n-1) - app(n+1,kk0) * ri(n+n+3) )
                    endif
                enddo
            enddo
        enddo
    enddo
!
!   elements app(lm,l'm')(n)
!
    do mp = 0 , mxltot
        k200 = 0
        do lp = mp+1 , mxltot
            k2 = ind(lp) + mp
            k20 = ind(lp-1) + mp
            if ( lp.gt.mp+1 ) k200 = ind(lp-2) + mp
            do l = lp , mxltot
                if ( l.eq.lp ) then
                    m1 = mp
                else
                    m1 = 0
                endif
                do m = m1 , l
                    k1 = ind(l) + m
                    kk = ind(k1) + k2
                    kk0 = ind(k1) + k20
                    kk00 = ind(k1) + k200
                    do n = l-lp , l+lp , 2
                        if ( n.ge.m+mp) then
                            aux = app(n+1,kk0) * re(n+m+mp+1) * dosl1i(n+1)
                            if ( n.gt.m+mp ) aux = aux + app(n-1,kk0) * re(n-m-mp) * dosl1i(n-1)
                            aux = aux * dosl1(lp-1)
                            if ( lp.gt.mp+1 ) aux = aux - re(lp+mp-1) * app(n,kk00)
                            app(n,kk) = aux * ri(lp-mp)
                        endif
                    enddo
                enddo
            enddo
        enddo
    enddo
    return
    end
!
!   *******************************************************************
!
  subroutine bcof
    USE DAM320_D
    USE DAM320_DATA_D, only: mxltot
    USE DAM320_CONST_D
    implicit none
    integer(KINT) :: k1, k2, k20, k200, kk, kk0, kk00, l, lp, m, m1, mmp, mp, n
    real(KREAL) :: aux, bux, t1, t2
    bpp = cero
!
!   starting elements bpp(lm,00)(n) = delta(l,n)
!
    k1 = 0
    do l = 0 , mxltot
        do m = 0 , l
            kk = ind(k1)
            bpp(l,kk) = uno
            k1 = k1 + 1
        enddo
    enddo
!
!   elements bpp(lm,m'm')(n)
!
    do mp = 1 , mxltot
        k2 = ind(mp) + mp
        k20 = ind(mp-1) + mp-1
        do l = mp , mxltot
            if ( l.eq.mp ) then
                m1 = mp
            else
                m1 = 0
            endif
            do m = m1 , l
                k1 = ind(l) + m
                kk = ind(k1) + k2
                kk0 = ind(k1) + k20
                do n = l-mp , l+mp , 2
                    if ( mp.gt.m ) then
                        t1 = uno
                        t2 = uno
                    else
                        t1 = -re(n-(m-mp+1)) * re(n-(m-mp+1)+1)
                        t2 = -re(n+(m-mp+1)) * re(n+(m-mp+1)+1)
                    endif
                    if ( n.ge.abs(m-mp)) then
                        if (n.eq.0) then
                            bux=cero
                        else
                                bux=t1*bpp(n-1,kk0) * dosl1i(n-1)
                        endif
                        bpp(n,kk) = dosl1(mp-1) * ( bux - t2 * bpp(n+1,kk0) * dosl1i(n+1) )
                    endif
                enddo
            enddo
        enddo
    enddo
!
!   elements bpp(lm,l'm')(n)
!
    do mp = 0 , mxltot
        k200 = 0
        do lp = mp+1 , mxltot
            k2 = ind(lp) + mp
            k20 = ind(lp-1) + mp
            if ( lp.gt.mp+1 ) k200 = ind(lp-2) + mp
            do l = lp , mxltot
                if ( l.eq.lp ) then
                    m1 = mp
                else
                    m1 = 0
                endif
                do m = m1 , l
                    k1 = ind(l) + m
                    kk = ind(k1) + k2
                    kk0 = ind(k1) + k20
                    kk00 = ind(k1) + k200
                    do n = l-lp , l+lp , 2
                        mmp = abs(m-mp)
                        if ( n.ge.mmp) then
                            aux = bpp(n+1,kk0) * re(n+mmp+1) * dosl1i(n+1)
                            if ( n.gt.mmp ) aux = aux + bpp(n-1,kk0) * re(n-mmp) * dosl1i(n-1)
                            aux = aux * dosl1(lp-1)
                            if ( lp.gt.mp+1 ) aux = aux - re(lp+mp-1) * bpp(n,kk00)
                            bpp(n,kk) = aux * ri(lp-mp)
                        endif
                    enddo
                enddo
            enddo
        enddo
    enddo
    return
    end
!
!   ******************************************************************
!
  subroutine emes ( m1, m2, ms, md, ss, sd )
    USE DAM320_D
    USE DAM320_CONST_D, ONLY: uno, cero, umed
    implicit none
    integer(KINT) :: m1, m1a, m2, m2a, ms, md
    real(KREAL) :: s1, s2, s12, ss, sd
    s1 = sign(1,m1)
    s2 = sign(1,m2)
    s12 = s1 * s2
    m1a = iabs(m1)
    m2a = iabs(m2)
    ms = s12 * ( m1a + m2a )
    md = s12 * iabs( m1a - m2a )
    if ( ms.eq.md ) then
        ss = uno
        sd = cero
        return
    endif
    if ( m1.lt.0 .and. m2.lt.0 ) then
        ss = -umed
    else
        ss = umed
    endif
    if ( s12.gt.cero ) then
        sd = umed
    elseif ( md.eq.0 ) then
        sd = cero
    elseif ( sign(1,m1a-m2a) .eq. s1 ) then
        sd = - umed
    else
        sd = umed
    endif
    return
    end

!**********************************************************************
!
!   subroutine rotar
!
!    this subroutine yields the rotation matrices rl(m',m;l) of reals spherical harmonics
!    receives the trigonometric functions of Euler angles defining the rotation
!
!**********************************************************************
  subroutine rotar(lmax, cosal, sinal, cosbet, sinbet, cosga, singa)
    USE DAM320_D
    USE DAM320_DATA_D
    USE DAM320_CONST_D
    implicit none
    integer(KINT) :: l, lmax
    real(KREAL) :: cosag, cosal, cosamg, cosbet, cosga, sinag, sinal, sinamg, singa, sinbet, tgbet2
!    Initial matrices d0, r0, d1 and r1
    rl(:,:,:) = cero
    dl(:,:,:) = cero
    dl(0,0,0)  = uno
    rl(0,0,0)  = uno
    if(lmax.eq.0) return
    dl(1,1,1)  = (uno + cosbet) * umed
    dl(1,0,1)  =-sinbet/raiz2
    dl(1,-1,1) = (uno - cosbet) * umed
    dl(0,1,1)  =-dl(1,0,1)
    dl(0,0,1)  = dl(1,1,1)-dl(1,-1,1)
    dl(0,-1,1) = dl(1,0,1)
    dl(-1,1,1) = dl(1,-1,1)
    dl(-1,0,1) = dl(0,1,1)
    dl(-1,-1,1)= dl(1,1,1)
    cosag  = cosal * cosga - sinal * singa
    cosamg = cosal * cosga + sinal * singa
    sinag  = sinal * cosga + cosal * singa
    sinamg = sinal * cosga - cosal * singa
    rl(0,0,1)  = dl(0,0,1)
    rl(1,0,1)  = raiz2 * dl(0,1,1) * cosal
    rl(-1,0,1) = raiz2 * dl(0,1,1) * sinal
    rl(0,1,1)  = raiz2 * dl(1,0,1) * cosga
    rl(0,-1,1) =-raiz2 * dl(1,0,1) * singa
    rl(1,1,1)  = dl(1,1,1) * cosag - dl(1,-1,1) * cosamg
    rl(1,-1,1) =-dl(1,1,1) * sinag - dl(1,-1,1) * sinamg
    rl(-1,1,1) = dl(1,1,1) * sinag - dl(1,-1,1) * sinamg
    rl(-1,-1,1)= dl(1,1,1) * cosag + dl(1,-1,1) * cosamg
!    the remaining matrices are calculated using symmetry and recurrence relations by means of the subroutine dlmn.
    if ( abs(sinbet) .lt. 1.d-14 ) then
        tgbet2 = cero
    elseif ( abs(sinbet) .lt. 1.d-10 ) then
        tgbet2 = cero
        write(6,"('WARNING in ROTAR: sinbet = ', e17.10, ' takes  0')") sinbet
    else
        tgbet2 = ( uno - cosbet ) / sinbet
    endif
    do l = 2, lmax
        call dlmn(l, sinal, cosal, cosbet, tgbet2, singa, cosga)
    enddo
    return
    end
!**********************************************************************
!
!   subroutine dlmn
!
!   this subroutine generates the matrices dl(m',m;l) for a fixed value
!   of the orbital quantum number l, and it needs the dl(l-2;m',m) and 
!   dl(l-1;m',m) matrices. this subroutine uses symmetry and recurrence
!   relations. the matrices dl(m',m;l) are the rotation matrices for   
!   complex spherical harmonics
!
!**********************************************************************
  subroutine dlmn(l, sinal, cosal, cosbet, tgbet2, singa, cosga)
    USE DAM320_D
    USE DAM320_DATA_D
    USE DAM320_CONST_D
    implicit none
    integer(KINT) :: iinf, isup, l, m, mp
    real(KREAL) :: al, al1, ali, aux, cosag, cosagm, cosal, cosaux, cosbet, cosga, cosmal, cosmga, cux, d1, d2
    real(KREAL) :: sgn, sinag, sinagm, sinal, singa, sinmal, sinmga, tal1, tgbet2
    iinf=1-l
    isup=-iinf
!    computation of the dl(m',m;l) matrix, mp is m' and m is m.
!    first row by recurrence: see equations 19 and 20 of reference (6)
    dl(l,l,l) = dl(isup,isup,l-1) * (uno + cosbet) * umed
    dl(l,-l,l) = dl(isup,-isup,l-1) * (uno - cosbet) * umed
    do m = isup, iinf, -1
        dl(l,m,l) = -tgbet2 * root(l+m+1) * rooti(l-m) * dl(l,m+1,l)
    enddo
!    the rows of the upper quarter triangle of the dl(m',m;l) matrix see equation 21 of reference (6)
    al = l
    al1 = al - uno
    tal1 = al + al1
    ali = uno / al1
    cosaux = cosbet * al * al1
    do mp = l-1, 0, -1
        aux = rooti(l+mp) * rooti(l-mp) * ali
        cux = root(l+mp-1) * root(l-mp-1) * al
        do m = isup, iinf, -1
            dl(mp,m,l) = aux * rooti(l+m) * rooti(l-m) * (tal1 * (cosaux - re(m) * re(mp)) * dl(mp,m,l-1) &
                    - root(l+m-1) * root(l-m-1) * cux * dl(mp,m,l-2) )
        enddo
        iinf=iinf+1
        isup=isup-1
    enddo
!    the remaining elements of the dl(m',m;l) matrix are calculated using the corresponding symmetry relations:
!        reflection ---> ((-1)**(m-m')) dl(m,m';l) = dl(m',m;l), m'<=m
!        inversion ---> ((-1)**(m-m')) dl(-m',-m;l) = dl(m',m;l)
!    reflection
    sgn = uno
    iinf = -l
    isup = l-1
    do m = l, 1, -1
        do mp = iinf, isup
            dl(mp,m,l) = sgn * dl(m,mp,l)
            sgn = -sgn
        enddo
        iinf=iinf+1
        isup=isup-1
    enddo
!    inversion
    iinf=-l
    isup=iinf
    do m = l-1, -l, -1
        sgn = -uno
        do mp = isup, iinf,- 1
            dl(mp,m,l) = sgn * dl(-mp,-m,l)
            sgn = -sgn
        enddo
        isup=isup+1
    enddo
!    computation of the rotation matrices rl(m',m;l) for real spherical harmonics using the matrices dl(m',m;l) 
!    for complex spherical harmonics: see equations 10 to 18 of reference (6)
    rl(0,0,l) = dl(0,0,l)
    cosmal = cosal
    sinmal = sinal
    sgn = - uno
    do mp = 1, l
        cosmga = cosga
        sinmga = singa
        aux = raiz2 * dl(0,mp,l)
        rl(mp,0,l) = aux * cosmal
        rl(-mp,0,l)= aux * sinmal
        do m = 1, l
            aux = raiz2 * dl(m,0,l)
            rl(0,m,l) = aux * cosmga
            rl(0,-m,l)=-aux * sinmga
            d1 = dl(-mp,-m,l)
            d2 = sgn * dl(mp,-m,l)
            cosag = cosmal * cosmga - sinmal * sinmga
            cosagm= cosmal * cosmga + sinmal * sinmga
            sinag = sinmal * cosmga + cosmal * sinmga
            sinagm= sinmal * cosmga - cosmal * sinmga
            rl(mp,m,l)  = d1 * cosag + d2 * cosagm
            rl(mp,-m,l) =-d1 * sinag + d2 * sinagm
            rl(-mp,m,l) = d1 * sinag + d2 * sinagm
            rl(-mp,-m,l)= d1 * cosag - d2 * cosagm
            aux    = cosmga * cosga - sinmga * singa
            sinmga = sinmga * cosga + cosmga * singa
            cosmga = aux
        enddo
        sgn = - sgn
        aux    = cosmal * cosal - sinmal * sinal
        sinmal = sinmal * cosal + cosmal * sinal
        cosmal = aux
    enddo
    return
    end
!
!    Fit of modified Macdonald functions k0 and k1
!    Generated with notebook paramBesselKf90_3.nb
!
!****************************************************************
!
  subroutine bkhat01(z, bk0, bk1)
    USE DAM320_D
    implicit none
    real(KREAL) :: aux, bk0, bk1, rlog, z, z2, zi
    if (z .le. 1.8d0) then
!        10**-15 < z <= 1.8  (err = 7.3468D-17)
        z2 = .25d0*z*z
        rlog = log(0.5d0*z)
        bk0 = -1.0000D0 * rlog * (1.0000000000000000D0+z2*(1.0000000000000000D0+z2            &
        *(2.5000000000001130D-1+z2*(2.7777777777594400D-2+z2*(1.7361111125963260D-3+z2                    &
        *(6.9444437725185450D-5+z2*(1.9290301179647520D-6+z2*(3.9340324052638480D-8+z2                    &
        *(6.3756707141301610D-10))))))))) + (-5.7721566490153280D-1+z2*(4.2278433509845960D-1+z2          &
        *(2.3069608377483780D-1+z2*(3.4892157453896110D-2+z2*(2.6147876336124720D-3+z2                    &
        *(1.1848034479311580D-4+z2*(3.6127194068217630D-6+z2*(7.9242063944650890D-8+z2                    &
        *(1.3839664472348050D-9)))))))))
!        10**-15 < z <= 1.8  (err = 4.2473D-16)
        bk1 = 4.0000D0 * z2  * rlog * (5.0000000000000000D-1+z2*(2.5000000000000000D-1+z2     &
        *(4.1666666666667270D-2+z2*(3.4722222222124620D-3+z2*(1.7361111118894510D-4+z2                    &
        *(5.7870366894629970D-6+z2*(1.3778750539477600D-7+z2*(2.4590924410413850D-9+z2                    &
        *(3.5302235881270210D-11))))))))) + (1.0000000000000000D0+z2*(1.5443132980314900D-1+z2            &
        *(-6.7278433510114770D-1+z2*(-1.8157516692762660D-1+z2*(-1.9182190045800730D-2+z2                 &
        *(-1.1153587707879350D-3+z2*(-4.1423957285968900D-5+z2*(-1.0697755019491690D-6+z2                 &
        *(-2.1591230464109430D-8)))))))))
    elseif(z .lt. 600.d0) then
!        1.8 < z  (err=1.0061D-16)
        zi = 1.d0 / z
        aux = exp(-z) * sqrt(zi)
        bk0 = aux * (1.2533141373152170D0+zi*(-1.5666426710532970D-1+zi               &
        *(8.8123644851101700D-2+zi*(-9.1795176503866800D-2+zi*(1.4055136902394020D-1+zi                   &
        *(-2.8437279833389170D-1+zi*(7.1251686584285390D-1+zi*(-2.0921711844554900D0+zi                   &
        *(6.7577540949229080D0+zi*(-2.2331565150122780D1+zi*(7.0449069557489330D1+zi                      &
        *(-2.0069537694811510D2+zi*(4.9567487059272380D2+zi*(-1.0296253384056660D3+zi                     &
        *(1.7539857229375550D3+zi*(-2.3899833699867430D3+zi*(2.5291558670376100D3+zi                      &
        *(-1.9962712021697260D3+zi*(1.1033260139443670D3+zi*(-3.8028779919124170D2+zi                     &
        *(6.1440875201303570D1)))))))))))))))))))))
!        1.8 < z  (err=-1.0123D-16)
        bk1 = z * aux * (1.2533141373157980D0+zi*(4.6999280143085300D-1+zi            &
        *(-1.4687274470936440D-1+zi*(1.2851334527076200D-1+zi*(-1.8071117233866830D-1+zi                  &
        *(3.4760646977082130D-1+zi*(-8.4259576146178000D-1+zi*(2.4195149352744930D0+zi                    &
        *(-7.7028852839112420D0+zi*(2.5239007367635500D1+zi*(-7.9277211874370080D1+zi                     &
        *(2.2547662438213300D2+zi*(-5.5688131706378400D2+zi*(1.1578823651681650D3+zi                      &
        *(-1.9754768955632640D3+zi*(2.6967292925819820D3+zi*(-2.8594816162412640D3+zi                     &
        *(2.2616983049159020D3+zi*(-1.2526588604239380D3+zi*(4.3266400225821900D2+zi                      &
        *(-7.0047317298430970D1)))))))))))))))))))))
    else
        bk0 = 0.d0
        bk1 = 0.d0
    endif
    return
    end
!
!    -------------------------------------------------------------------------------------------------------
!
  subroutine totalchargeSTO
    USE DAM320_D
    USE DAM320_DATA_D
    USE DAM320_CONST_D
    implicit none
    integer(KINT) :: i, i1, i2, ia, ib, ierr, ii, ishift, j, la, lb, lrotar, m, na, nb, nfa, nfb, nga1, nga2, ngb1, ngb2
    real(KREAL) :: aux, charge, cosal, cosbet, cosga, rab, rna, rnab, rnb, sinal, sinbet, singa, xab, xy, yab, za, zb, zab
    real(KREAL) :: roaux(-mxl:mxl,-mxl:mxl)
    allocate(sol(0:mxl), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating sol. Stop')
    allocate(rl(-mxl:mxl,-mxl:mxl,0:mxl), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating rl. Stop')
    allocate(dl(-mxl:mxl,-mxl:mxl,0:mxl), stat = ierr)
    if (ierr .ne. 0) call error(1,'Memory error when allocating dl. Stop')
    charge = cero
    do ia = 1, ncen
        if (ngini(ia) .le. 0) cycle
        nga1 = ngini(ia)
        nga2 = ngfin(ia)
        do i1 = nga1, nga2
            na = nn(i1)
            la = ll(i1)
            za = xx(i1)
            rna = rnor(i1)
            nfa = nf(i1)
            do i2 = nga1, nga2
                nb = nn(i2)
                lb = ll(i2)
                if (la .ne. lb) cycle
                zb = xx(i2)
                rnb = rnor(i2)
                nfb = nf(i2)
                aux = rna * rnb * fact(na+nb) / (za+zb)**(na+nb+1)
                do m = -min(la,lb), min(la,lb)
                    charge = charge + dmat(nfa+la+m,nfb+lb+m) * aux
                enddo
            enddo
        enddo
        if (lzdo) cycle
        do ib = 1, ncen
            if (ia .eq. ib .or. ngini(ib) .le. 0) cycle
            ngb1 = ngini(ib)
            ngb2 = ngfin(ib)
            do i1 = nga1, nga2
                na = nn(i1)
                la = ll(i1)
                za = xx(i1)
                rna= rnor(i1)
                nfa = nf(i1)
                do i2 = ngb1, ngb2
                    nb = nn(i2)
                    lb = ll(i2)
                    zb = xx(i2)
                    rnb = rnor(i2)
                    nfb = nf(i2)
!    Computes Euler angles and rotation matrices from the AB aligned axis system to the molecular system and conversely
                    xab = rcen(1,ib) - rcen(1,ia)
                    yab = rcen(2,ib) - rcen(2,ia)
                    zab = rcen(3,ib) - rcen(3,ia)
                    xy = sqrt(xab*xab + yab*yab)
                    rab = sqrt(xab*xab + yab*yab + zab*zab)
                    if (rab .lt. 1.d-10) then
                        write(6,"('Centers ',i8,' and ',i8,' coincide. Stop')") ia, ib
                        call error(1,' Stop')
                    endif
                    if (xy .gt. 1.d-10) then
                        sinal = yab / xy
                        cosal = xab / xy
                    else
                        sinal = cero
                        cosal = uno
                    endif
                    sinbet = xy / rab
                    cosbet = zab / rab
                    singa = cero
                    cosga = uno
                    lrotar = max(la,lb)
                    call rotar (lrotar, cosal, sinal, cosbet, sinbet, cosga, singa)
!    Reads the pertinent block of density matrix and rotates it to the AB aligned system. Loads the result in array roblk.
!    Angular normalization factors are introduced at the end of the loading process.
                    do i = -la, la
                        ishift = i+la+nfa
                        do j = -lb, lb
                            roblk(i,j) = dmat(ishift,j+lb+nfb)
                        enddo
                    enddo
!    Rotation on center B!     allocate(rl(-mxl:mxl,-mxl:mxl,0:mxl), stat = ierr)
!     if (ierr .ne. 0) call error(1,'Memory error when allocating rl. Stop')
                    do i = -la, la
                        do j = -lb, lb
                            roaux(i,j) = dot_product(roblk(i,-lb:lb),rl(-lb:lb,j,lb))
                        enddo
                    enddo
!    Rotation on center A
                    do i = -la, la
                        do j = -lb, lb
                            roblk(i,j) =  dot_product(roaux(-la:la,j), rl(-la:la,i,la))
                        enddo
                    enddo
                    call abintegs(na, la, za, nb, lb, zb, rab)
                    call overlap(na-la, la, za, nb-lb, lb, zb, rab)
                    do m = -min(la,lb), min(la,lb)
                        charge = charge + rna * rnb * ang(ind(la)+abs(m)+1) * ang(ind(lb)+abs(m)+1) * roblk(m,m) &
                                * sol(abs(m))
                    enddo
                enddo
            enddo
        enddo
    enddo
    if (lzdo) then
        write(6,"(/'Total valence electron charge computed from density matrix = ', e22.15,/)") -charge
    else
        write(6,"(/'Total electron charge computed from density matrix = ', e22.15,/)") -charge
    endif
    write(6,"('Highest value of l in the expansion of atomic densities = ', i4)") lmaxexp
    deallocate(dl, rl, sol)
    return
    end
!
!    -------------------------------------------------------------------------------------------------------
!
!    Integrals:      A_j(\beta) = \int_1^\infty d\xi \; \xi^j \; e^{-\beta \, \xi}
!    and
!                B_j(\nu) = \int_{-1}^1 d\nu \; \nu^j \; e^{-\nu \, \xi}
!
  subroutine abintegs(na, la, za, nb, lb, zb, R)
    USE DAM320_D
    USE DAM320_DATA_D
    USE DAM320_CONST_D
    implicit none
    integer(KINT) :: i, imax, j, jlim, jmax, la, lb, na, nb
    real(KREAL), parameter :: threshb = 1.d-18, threshg = 1.d-18
    real(KREAL) :: beta, betai, expb, expg, expgi, expgj, g2, gamma, gammai, R, si, suma, za, zb
!
!    Integrals:  A_j(\beta) = \int_1^\infty d\xi \; \xi^j \; e^{-\beta \, \xi}
!
    beta = umed * (za+zb) * R
    expb = exp(-beta)
    betai = uno / beta
    av(0) = expb * betai
    jmax = na + nb + 2*(la+lb)
    do j = 1, jmax
        av(j) = (re(j) * av(j-1) + expb) * betai
    enddo
!
!    Integrals:  B_j(\gamma) = \int_{-1}^1 d\nu \; \nu^j \; e^{-\gamma \, \nu}
!
    gamma = umed * (za-zb) * R
    if (gamma .eq. cero) then
        bv = cero
        do j = 0, jmax, 2
            bv(j) = dos * ri(j+1)
        enddo
    else
        gammai = uno / gamma
        g2 = gamma * gamma
        expg = exp(gamma)
        expgi = uno / expg
        jlim = abs(gamma)
        if(jmax .lt. jlim) jlim = jmax
        if (abs(gamma) .lt. threshg) then
                bv(0) = dos
        else
                bv(0) = dos * sinh(gamma) * gammai
        endif
        expgj = expg
        do j = 1, jlim        !    ascending recursion from j = 0 to jlim
                expgj = -expgj
                bv(j) = gammai * (expgj - expgi + re(j) * bv(j-1) )
        enddo
        if (jmax .gt. jlim) then
            jmax = 2*((jmax+1)/2)    ! Using an even value for jmax  prevents possible accuracy loss in bv(jmax)
            suma = cero
            si = ri(jmax+1) * ri(jmax+2)
            imax = 100
            do i = 0, imax
                suma = suma + si * ( (re(jmax+2+i+i)+gamma) * expgi + (re(jmax+2+i+i)-gamma) * expg )
                if (si .lt. suma*threshb) go to 100
                si = si * g2 * ri(jmax+i+i+3) * ri(jmax+i+i+4)
            enddo
            suma = suma + si * ( (re(jmax+2+i+i)+gamma) * expgi + (re(jmax+2+i+i)-gamma) * expg )
            write(6,"('The series for the integral B(',i3,',',e22.15,') did not converge with the prescribed accuracy after ',&
                    i4,' terms')") jmax, gamma, imax
            write(6,"('Value of the series= ', e22.15, '  last summand = ', e22.15)") &
                    suma, si * ( (re(jmax+2+i+i)+gamma) * expgi + (re(jmax+2+i+i)-gamma) * expg )
100        continue
            bv(jmax) = suma
            expgj = expg
            do j = jmax-1, jlim+1, -1
                expgj = - expgj
                bv(j) = ri(j+1) * (expgj + expgi + gamma * bv(j+1) )
            enddo
        endif
    endif
    return
    end
!
!    -------------------------------------------------------------------------------------------------------
!
  subroutine overlap(na, la, za, nb, lb, zb, R)
    USE DAM320_D
    USE DAM320_DATA_D
    USE DAM320_CONST_D
    implicit none
    integer(KINT) :: ialfa, iap, ip, j, k, la, lb, m, na, nb
    real(KREAL) :: aux, suma, sumkj, R, za, zb
    iap = ipntap(na,nb)
    aux = pi * (umed * R)**(na+nb+la+lb+1)
    do m = 0, min(la,lb)
        ialfa = ipntalfa(la+m*(2*mxl-m+1)/2 + 1, lb)
        suma = cero
        do ip = 0, na+nb
            sumkj = cero
            do k = 0, la+lb
                do j = 0, k+k
                    sumkj = sumkj + av(na+nb+k+k-j-ip) * bv(j+ip) * alfasol(ialfa+k*k+j)
                enddo
            enddo
            suma = suma + sumkj * ap(iap+ip)
        enddo
        sol(m) = aux * suma
    enddo
    sol(0) = sol(0) + sol(0)
    return
    end
!
!    -------------------------------------------------------------------------------------------------------
!
  subroutine testoverlap(na, la, za, rna, nb, lb, zb, rnb, R, ldst)
    USE DAM320_DATA_D
    USE DAM320_CONST_D
    implicit none
    logical :: ldst
    integer(KINT) :: ialfa, iap, ip, j, k, la, lb, m, na, nb
    real(KREAL) :: aux, suma, sumkj, R, rna, rnb, za, zb

    iap = ipntap(na,nb)
    aux = pt25 * sqrt(re(la+la+1)*re(lb+lb+1)) * (umed * R)**(na+nb+la+lb+1) * rna * rnb ! Includes normalization of functions with m = 0
    ialfa = ipntalfa(la+1,lb)
    suma = cero
    do ip = 0, na+nb
        sumkj = cero
        do k = 0, la+lb
            do j = 0, k+k
                sumkj = sumkj + av(na+nb+k+k-j-ip) * bv(j+ip) * alfasol(ialfa+k*k+j)
            enddo
        enddo
        suma = suma + sumkj * ap(iap+ip)
    enddo
    if(abs(aux * suma) .lt. thresoverlap) then
        ldst = .false.
    else
        ldst = .true.
    endif
    return
    end
!
!    -------------------------------------------------------------------------------------------------------
!
  subroutine error(ierr, msg)
    USE DAM320_D
    implicit none
    integer(KINT) :: ierr
    character(*) :: msg
    write(6,"(a)") msg
    write(6,"('Error code = ', i4)") ierr
    stop
    end
