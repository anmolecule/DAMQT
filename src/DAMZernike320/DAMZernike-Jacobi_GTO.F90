!  Copyright 2011-2019, Rafael Lopez, Gabriel Aires Urquiza de Carvalho
! 
!  This file is part of Zernike_Jacobi_320 package.
!  Zernike_Jacobi_320 is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
! 
!  You should have received a copy of the GNU General Public License
!  along with Zernike_Jacobi_320.  If not, see <http://www.gnu.org/licenses/>.
!
!------------------------------------------------------------------------
! 
! Program for computation of Zernike 3D and Jacobi moments of a molecular density of GTO
!
! Version of March 2018
!
  program DAMZernike_Jacobi_GTO_320
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: i, ia, ierr, j, k, l, la, m, ma
    real(KREAL) :: aux
    real(KREAL4) :: tarray(2), tiempo, dtime
    external :: omeganlm_jacobi, omeganlm_zernike, frad_jacobi, frad_zernike
    namelist / options / iswindows, lechelon, ljacobi, lmthfile, longoutput, lexpansion, lrstarrel, lvalence, lzdo, &
            nquadpoints, kexpansion, rstar, thresmult, thresoverlap
    tiempo = dtime(tarray)
!    Defaults for the NAMELIST OPTIONS
    kexpansion = 10           ! Highest k in expansion functions
    lechelon = .false.        ! if true number of functions per l equal to max(lexpansion+1,kexpansion)-l
    lexpansion = 20           ! Highest l in expansion functions
    ljacobi = .false.         ! if .true. uses Jacobi P(0,2+2l) polynomials as radial functions instead of Zernike 3D
    lmthfile = .false.        ! if .true. generates a projectname.mth file with data about the moments computation
    longoutput = .false.      ! If .true. a more detailed output is given
    lrstarrel = .false.       ! If .true. ball radius equal to distance of farthest atom plus rstar
    lvalence = .false.        ! If .true. only valence electrons are considered
    lzdo = .false.            ! If .true. ZDO approximation holds
    nquadpoints = 128         ! Number of quadrature points
    rstar = 10.d0             ! Ball radius for expansion
    thresmult = 1.d-10        ! Threshold for printing multipole moments
    thresoverlap = 1.d-12     ! Threshold for distributions neglect
    iswindows = .false.       ! .true. if running on a MS-windows system
!    End of Defaults for the NAMELIST OPTIONS

    read(5,OPTIONS)    !    Reads the namelist OPTIONS
    read(5,*) projectname
    write(6,"(1x,'project name : ',a,/,1x,'==============')") projectname
    write(6,"('lexpansion = ', i3, ' kexpansion = ', i3,/)") lexpansion, kexpansion
!     nquadpoints = min(120,nquadpoints)
    write(6,"(/'****  rstar = ', e17.10, ' ****     Number of quadrature points = ', i5,/)") rstar, nquadpoints

    if (iswindows) then
        dirsep = "\\"
        i = index(projectname,dirsep,.true.)    ! Checks position of last directory name separator
        if (i .eq. 0) then    ! This is intended for MinGW, whose directory separator in windows is also /
                dirsep = "/"
                i = index(projectname,dirsep,.true.)    ! Checks position of last directory name separator
        endif
    else
        dirsep = "/"
        i = index(projectname,dirsep,.true.)    ! Checks position of last directory name separator
    end if
    mxltot = mxldst + lexpansion

    if (lzdo) then
        write(6,"(/'IMPORTANT: ZDO approximation used, fits one-center part of density',/)")
    endif

    call consta    !    Computes and stores several auxiliary constants and functions

!    Reads geometry, basis set and density matrix generated by an external program 
    lgbsgz = .false.
    inquire(file=trim(projectname)//".ggbs.gz", exist=lgbsgz, iostat=ierr)
    if (ierr .eq. 0 .and. lgbsgz) then
        call system ("gunzip "//trim(projectname)//".ggbs.gz")
    endif
    ldengz = .false.
    inquire(file=trim(projectname)//".den.gz", exist=ldengz, iostat=ierr)
    if (ierr .eq. 0 .and. ldengz) then
        call system ("gunzip "//trim(projectname)//".den.gz")
    endif

    call leedatgauss

    if (ldengz) then
        call system ("gzip "//trim(projectname)//".den")
    endif
    if (lgbsgz) then
        call system ("gzip "//trim(projectname)//".ggbs")
    endif

    write(6,"(/'****  rstar = ', e17.10, ' ****     Number of quadrature points = ', i5,/)") rstar, nquadpoints


!    Computation of Zernike 3D or Jacobi moments

    if (lechelon) kexpansion = max(lexpansion, kexpansion)
    if (ljacobi) then
        call expand(omeganlm_jacobi, frad_jacobi)
    else
        call expand(omeganlm_zernike, frad_zernike)
    endif

!    Computes the total molecular multipolar moments from the Zernike expansion

    tiempo = dtime(tarray)
    write(6,"(1x,//80('='),/'Timing in seconds for fingerprints (user, system, total):',/5x,'(',e12.5,',',e12.5,',',e12.5')')") &
            tarray(1), tarray(2), tarray(1)+tarray(2)
    write(6,"(1x,'Elapsed time = ', e12.5)") tiempo
    stop
    end
!
!    ***************************************************************
!
  subroutine leedatgauss
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: i, ia, icarga, ierr, indnf, indng, ios, j, k, k1, k2, knt, nbasis
    real(KREAL) :: aux, bux, distmax, zntot
    real(KREAL) :: centcharge(3), xaux(mxprimit), cfaux(mxprimit)
!    Reads the number of centers
    open(15,file=trim(projectname)//".ggbs",form='formatted', iostat = ierr)
    if (ierr .ne. 0) call error(ierr,'Error when opening file '//trim(projectname)//'.ggbs. Stop')
    read(15,*) ncen

!    Allocates memory for geometry and basis set
    ncaps = mxcap ! just for allocating

    allocate(atmnam(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating atmnam. Stop')

    allocate(cfa(mxgauss), cfb(mxgauss), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating cfa, cfb. Stop')

    allocate(cfcontr0(mxcap*mxprimit), stat = ierr)
    if (.not. allocated(cfcontr0)) call error(ierr,'Memory error when allocating cfcontr0. Stop')

    allocate(ipntprim(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ipntprim. Stop')

    allocate(isort(mxprimit), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating isort. Stop')

    allocate(ll(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ll. Stop')

    allocate(lmaxc(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating lmaxc. Stop')

    allocate(ncontr(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ncontr. Stop')

    allocate(nf(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating nf. Stop')

    allocate(ngini(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ngini. Stop')

    allocate(ngfin(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ngfin. Stop')

    allocate(nprimit(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating nprimit. Stop')

    allocate(nzn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating nzn. Stop')

    allocate(rcen(3,ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating rcen. Stop')

    allocate(rnor(ncaps), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating rnor. Stop')

    allocate(xia(mxgauss), xib(mxgauss), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating xia, xib. Stop')

    allocate(xxg0(mxcap*mxprimit), stat = ierr)
    if (.not. allocated(xxg0)) call error(ierr,'Memory error when allocating xxg0. Stop')

    allocate(zn(ncen), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating zn. Stop')

    centcharge = 0.d0
    zntot = 0.d0
!    Reads the number of centers, geometry and basis set 
    do ia = 1, ncen
        read(15,*) rcen(1,ia), rcen(2,ia), rcen(3,ia), zn(ia)
        centcharge = centcharge + zn(ia) * rcen(:,ia)
        zntot = zntot + zn(ia)
        if (abs(zn(ia)-re(int(zn(ia) + umbrzn))) .gt. umbrzn) then
            nzn(ia) = 0
        else
            nzn(ia) = int(zn(ia) + umbrzn)
        endif
        atmnam(ia) = atmnms(nzn(ia))
    enddo
!     Transforms the coordinates to get the center of positive (nucelar) charges at the origin of coordinates
    centcharge = centcharge / zntot
    if (dot_product(centcharge,centcharge) .gt. 1.d-14) then
        write(6,"('Position of the center of positive charges: ',3(1x,e22.15))") centcharge
        write(6,"('Shifts the nuclear coordinates to put the center of positive charges at the origin')")
        do ia = 1, ncen
            rcen(1,ia) = rcen(1,ia) - centcharge(1)
            rcen(2,ia) = rcen(2,ia) - centcharge(2)
            rcen(3,ia) = rcen(3,ia) - centcharge(3)
        enddo
    endif
    if (lrstarrel) then
        distmax = 0.d0
        do ia = 1, ncen
            distmax = max(distmax,dot_product(rcen(:,ia),rcen(:,ia)))
        enddo
        rstar = rstar + sqrt(distmax)
    endif


!     Basis set::
!         for each center:
!              number of contractions
!              for each contraction:
!                   number of primitives
!                   l  quantum number
!                   exponents of the primitives
!                   contraction coefficients
!     Primitives are sorted in increasing order of exponents.
!     An array is created with pointers to the beginning of
!     exponents and coefficients of a contracted function.
!     Arrays  nf, ngini  and  ngfin are initialized.
!
!    Contraction coefficients correspond to the expansion in UNNORMALIZED primitives

    lmaxbase = 0
    ncaps = 0
    icarga = 0
    indnf = 1
    indng = 1
    do ia = 1, ncen
        read(15,*) ncontr(ia)
        if (ncontr(ia) .le. 0) then
            ngini(ia) = -1
            ngfin(ia) = -1
            cycle
        endif
        ngini(ia) = indng
        ngfin(ia) = indng + ncontr(ia) - 1
        indng = indng + ncontr(ia)
        lmaxc(ia) = 0
        do j = 1, ncontr(ia)
            ncaps = ncaps + 1
            if (ncaps .gt. mxcap)  call error(1,'Error: maximum number of shells in basis set exceeded. Stop')
            read(15,*) nprimit(ncaps), ll(ncaps)
            if (icarga+nprimit(ncaps) .gt. mxcap*mxprimit)  call error(1,'Error: maximum number of total primitives exceeded. &
                            &\nChange parameter mxcap in DAMGLOBALxxxx.F90 and remake. \nStop')
            if (ll(ncaps) .gt. lmaxbase) lmaxbase = ll(ncaps)
            if (ll(ncaps) .gt. lmaxc(ia)) lmaxc(ia) = ll(ncaps)
            nf(ncaps) = indnf
            indnf = indnf + 2*ll(ncaps) + 1
            if(nprimit(ncaps) .gt. mxprimit) call error(1,'Error: maximum number of primitives per contraction exceeded. Stop')
            ipntprim(ncaps) = icarga+1
            read(15,*) (xaux(k), k = 1, nprimit(ncaps))
            read(15,*) (cfaux(k), k = 1, nprimit(ncaps))
!            sorts primitives in increasing exponents
            call sort(nprimit(ncaps),xaux)
            do k = 1, nprimit(ncaps)
                xxg0(icarga+k) = xaux(k)
                cfcontr0(icarga+k) = cfaux(isort(k))
            enddo
!            computes and stores the radial normalization factor
            aux = cero
            bux = ll(ncaps) + 1.5d0
            do k1 = 1, nprimit(ncaps)
                do k2 = 1, k1-1
                    aux=aux + dos*cfcontr0(icarga+k1)*cfcontr0(icarga+k2)/(xaux(k1)+xaux(k2))**bux
                enddo
                aux = aux + cfcontr0(icarga+k1) * cfcontr0(icarga+k1) / (dos*xaux(k1))**bux
            enddo
            rnor(ncaps) = sqrt( dos / (facts(ll(ncaps))*aux) )
!            actualizes the index for loading
            icarga = icarga+nprimit(ncaps)
        enddo
    enddo
    nprimitot = icarga
    nbas = indnf-1

    allocate(xxg(nprimitot), stat = ierr)
    if (.not. allocated(xxg)) call error(ierr,'Memory error when allocating xxg. Stop')

    allocate(cfcontr(nprimitot), stat = ierr)
    if (.not. allocated(cfcontr)) call error(ierr,'Memory error when allocating cfcontr. Stop')

    xxg(1:nprimitot) = xxg0(1:nprimitot)
    cfcontr(1:nprimitot) = cfcontr0(1:nprimitot)

    deallocate(xxg0, cfcontr0)

    if (ncaps .gt. mxcap) then
        write(6,"('Number of function shells = ', i4, ' higher  than maximum allowed = ',i4)")  ncaps, mxcap
        write(6,"('Modify parameter  mxcap  in module DAM320_D of file DAM320_GLOBAL.F90 and recompile.')")
        call error(1,' Stop')
    endif
    if (lmaxbase .gt. mxl) then
        write(6,"('Basis functions with not allowed values of  l. ')")
        write(6,"('Highest allowed value: ', i2 , ' Highest value in basis set: ', i2)") mxl, lmaxbase
        call error(1,' Stop')
    endif

!    Allocates the array containing the density matrix
    allocate(dmat(nbas,nbas), stat = ierr)
    if (.not. allocated(dmat)) call error(ierr,'Memory error when allocating dmat. Stop')
    if (longoutput) write(6,"('Estimated highest size of dmat   = ', i15, ' bytes')") size(dmat)

!    Reads the density matrix in lower triangle form:  read ((dmat(i,j), j = 1, i), i = 1, nbasis)
    open(16,file=trim(projectname)//".den",form='formatted', iostat = ierr)
    if (ierr .ne. 0) call error(ierr,'Cannot open file '//trim(projectname)//'.den. Stop')
    read(16,*, iostat = ios) nbasis, ((dmat(i,j),j=1,i),i=1,nbasis)
    if ( ios .ne. 0 .or. nbas .ne. nbasis ) then
        write(6,"('ERROR reading density matrix. Check whether the density matrix correspond to this basis set.')")
        call error(1,' Stop')
    endif
    close(16)
    do i = 2, nbasis
        do j = 1, i-1
            dmat(j,i) = dmat(i,j)
        enddo
    enddo

!    prints out the input data
    write(6,"(27x,'GEOMETRY')")
    write(6,"(/t1, ' no. of center:', t22, 'x', t34, 'y', t46, 'z', t58, 'charge', t70, 'n. of shells')")
    do ia = 1, ncen
        write(6,"(t6, i5, t15, f12.7, t27, f12.7, t39, f12.7, t53, f10.5, t75, i3)") &
                ia, rcen(1,ia), rcen(2,ia), rcen(3,ia) , zn(ia), ngfin(ia)-ngini(ia)+1
    enddo
    write(6,"(27x,'GTO BASIS SET')")
    if (longoutput) then
        icarga = 0
        knt = 0
        do ia = 1, ncen
            if (ncontr(ia) .le. 0) cycle
            write(6,"(/1x,'atom no.',1x,i5,'(',a2,')')") ia, atmnam(ia)
            write(6,"(1x,'number of contractions = ',i6)") ncontr(ia)
            do j = 1, ncontr(ia)
                knt = knt + 1
                write(6,"(/1x,'contraction no. ',i6,' ; l = ',i2)") j,  ll(knt)
                write(6,"('exponents: ', 8(1x,e12.5))") (xxg(icarga+k), k = 1, nprimit(knt))
                write(6,"('coefficients: ', 8(1x,e12.5))") (cfcontr(icarga+k),k=1,nprimit(knt))
                icarga = icarga+nprimit(knt)
            enddo
        enddo
    endif
    write(6,"('Number of basis functions = ', i8)") nbas
    write(6,"('Number of primitive functions = ', i8)") nprimitot
    call totalchargeGTO
    return
    end
!
!    ***************************************************************
!
!    Subroutine for expanding the density of a molecule in orthogonal polynomials times spherical harmonics 
!    centered at origin
! 
  subroutine expand(clmn_subr, frad_fun)
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: i, i1, i12p, i1p, i1pini, i1pfin, i2, i2p, i2pini, i2pfin, ia, ib, ierr, ii, ir, irinf, irshft, irsup
    integer(KINT) :: ishift, j, k, klmi, kml, knt, kntdst, kntdstef, knticf, kntlm
    integer(KINT) :: l, la, lb, ldmrot, lk, lm, lma, lmax, lmb, lmin, m, ma, mb
    integer(KINT) :: n, na, nb, nfa, nfb, nga1, nga2, ngb1, ngb2
    real(KREAL) :: amodule, aux, az, bpmodule, bpx, bpy, bpz, bux, bx, bx2, bz, cosalfa, cosbeta, cosgamma, cux
    real(KREAL) :: den, dosx, exa, exb, factor, pmodule, prdesc
    real(KREAL) :: rab, rabinv, rdif, rn, rna, rnab, rnb, rp2, sinalfa, sinbeta, singamma, suma
    real(KREAL) :: x, x12inv, xa, xab, xb, xinv, xip, xjp, xkp, xy, ya, yab, yb, yip, yjp, ykp, za, zab, zb, zip, zjp, zkp
    logical :: lf0, lprint, lmultmod, lrotar
    real(KREAL) :: roaux(-mxl:mxl,-mxl:mxl), qlm1c(0:mxldst), vinvariant(0:kexpansion)
    real(KREAL4) :: tarray(2), tiempo, tarraynw(2), tiemponw, dtime
    real(KREAL), allocatable :: fcent(:,:)
    interface
        subroutine clmn_subr
        end subroutine clmn_subr
    end interface
    interface
        subroutine frad_fun
        end subroutine frad_fun
    end interface
    tiempo = dtime(tarray)
    ldimaux = lexpansion + lmaxbase + lmaxbase
    ldmrot = max(lmaxbase,lexpansion)
!    Allocates memory for arrays dl, fa, fcent, flm, flmmamb, ftot, rl, rlt
    allocate(dl(-ldmrot:ldmrot,-ldmrot:ldmrot,0:ldmrot), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating dl. Stop')
    allocate(fcent(nquadpoints,(lexpansion+1)**2), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating fcent. Stop')
    allocate(flm(nquadpoints,-lmaxbase:lmaxbase,-lmaxbase:lmaxbase,(lexpansion+1)**2), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating flm. Stop')
    allocate(flmmamb((ldimaux+1)*(ldimaux+1),-lmaxbase:lmaxbase,-lmaxbase:lmaxbase), stat = ierr)  ! allocates input data arrays
    if (ierr .ne. 0) call error(2,'Memory error when allocating flmmamb. Stop')
    allocate(ftot(nquadpoints,(lexpansion+1)**2), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ftot. Stop')
    allocate(gkl(-1:kexpansion), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating gkl. Stop')
    allocate(radfunction(nquadpoints, 0:kexpansion), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating radfunction. Stop')
    allocate(rl(-ldmrot:ldmrot,-ldmrot:ldmrot,0:ldmrot), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating rl. Stop')
    allocate(rlt((ldmrot+1)*(2*ldmrot+1)*(2*ldmrot+3)/3), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating rlt. Stop')
    allocate(rquad01(nquadpoints), rquadscal(nquadpoints), rquadaux(nquadpoints), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating rquad01, rquadscal and rquadaux. Stop')
    allocate(weights01(nquadpoints), weights(nquadpoints), vaux(nquadpoints), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating weights01, weights and weightaux. Stop')

!     Chebyshev quadrature rule:     rquad01: abscissae in the interval [0,1]
!                             rquadscal: abscissae in the interval [0,r^*]
!                            weights01: weights in the interval [0,1] 
!                             weights: weights in the interval [0,r^*]
    do i = 1, nquadpoints
        rquad01(i) = umed * ( uno - cos( pi*(dble(i)-umed) / dble(nquadpoints) ) )
        weights01(i) = pi * sqrt(1.d0 - (2.d0*rquad01(i)-1.d0)*(2.d0*rquad01(i)-1.d0)) / (2.d0*nquadpoints)
    enddo
!
!    Legendre quadrature rules (available up to order 120)
!     call qgleg(nquadpoints, rquad01, weights01, 0.d0, 1.d0, 0.d0)

    rquadscal = rstar * rquad01

!     if (longoutput) then
!         write(6,"('quadrature abscissae in the interval [0,1]: ', 8(1x,e17.10))") rquad01
!         write(6,"('quadrature abscissae in the interval [0,r^*]: ', 8(1x,e17.10))") rquadscal
!         write(6,"('quadrature weights in the interval [0,1]: ', 8(1x,e17.10))") rquad01
!     endif

    ftot = 0.d0
    kntdst = 0
    kntdstef = 0
    do ia = 1, ncen    ! Do over centers (ia)
        if (ngini(ia) .le. 0) cycle    ! If center without associated basis set, cycles
        nga1 = ngini(ia)
        nga2 = ngfin(ia)
        xa = rcen(1,ia)
        ya = rcen(2,ia)
        za = rcen(3,ia)
        do ib = ia, ncen                    ! Do over centers (ib)
            if (lzdo .and. ia .ne. ib) cycle
            if (ngini(ib) .le. 0) cycle    ! If center without associated basis set, skips to next center ib
            ngb1 = ngini(ib)
            ngb2 = ngfin(ib)
            xb = rcen(1,ib)
            yb = rcen(2,ib)
            zb = rcen(3,ib)
            rab = sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+(za-zb)*(za-zb))

!     Computes Euler angles to orient the frame so that A center lies on the local z axis and center B lies on the local xz plane

            pmodule = sqrt(xa*xa + ya*ya)
            amodule = sqrt(xa*xa + ya*ya + za*za)
            if (pmodule .gt. 1.d-15) then
                cosalfa = xa / pmodule
                sinalfa = ya / pmodule
            else
                cosalfa = uno
                sinalfa = cero
            endif
            if (amodule .gt. 1.d-15) then
                cosbeta = za / amodule
                sinbeta = pmodule / amodule
            else
                cosbeta = uno
                sinbeta = cero
            endif

!     Rotates unitary vectors an angle alfa around z axis and an angle beta around y axis

            xip = cosalfa * cosbeta
            yip = sinalfa * cosbeta
            zip = -sinbeta
            xjp = -sinalfa
            yjp = cosalfa
            zjp = cero
            xkp = cosalfa * sinbeta
            ykp = sinalfa * sinbeta
            zkp = cosbeta
            prdesc = xb*xkp + yb * ykp + zb * zkp
            bpx = xb - prdesc * xkp
            bpy = yb - prdesc * ykp
            bpz = zb - prdesc * zkp
            bpmodule = sqrt(bpx*bpx+bpy*bpy+bpz*bpz)
            if (bpmodule .lt. 1.d-12) then
                cosgamma = uno
                singamma = cero
            else
                cosgamma = (bpx*xip+bpy*yip+bpz*zip) / bpmodule
                singamma = (bpx*xjp+bpy*yjp+bpz*zjp) / bpmodule
            endif
            lrotar = .false.
            if (((max(lmaxc(ia), lmaxc(ib), lexpansion)) .gt. 0) .and. ( (cosalfa  .ne. uno) .or. (cosbeta  .ne. uno) &
                            .or. (cosgamma .ne. uno) ) ) then
                lrotar = .true.
                call rotar (ldmrot, cosalfa, sinalfa, cosbeta, sinbeta, cosgamma, singamma)

!    Stores the transpose of rl multiplied and divided by the angular normalization to give radial factors which multiply UNNORMALIZED spherical harmonics

                knt = 0
                do i = 0, ldmrot
                    do k = -i, i
                        do j = -i, i
                            knt = knt + 1
                            rlt(knt) = rl(k,j,i) * ang(ind(i)+abs(k)+1) / ang(ind(i)+abs(j)+1)
                        enddo
                    enddo
                enddo
            endif

!     Some auxiliary variables depending only on the centers A and B 

            az = max(sqrt(xa*xa+ya*ya+za*za), toldstorig)  ! Sets the minimum distance to origin equal to toldstorig to prevent division yb zero
            if (az .gt. toldstorig) then
                bz = (xb*xa+yb*ya+zb*za) / az
            else
                bz = zb
            endif
            bx2 = xb*xb+yb*yb+zb*zb-bz*bz
            if (bx2 .lt. 1.d-15) then
                bx = cero
                bz = sign(max(abs(bz), toldstorig),bz)   ! Sets the minimum distance to origin equal to toldstorig to prevent division by zero
            else
                bx = sqrt(bx2)
            endif

!             Loop over the distributions

            fcent = cero    ! array for accumulating radial factors corresponding to centers AB
            do i1 = nga1, nga2
                la = ll(i1)
                rna= rnor(i1)
                nfa = nf(i1)
                do i2 = ngb1, ngb2
                    lb = ll(i2)
                    nfb = nf(i2)
                    rnab = rna * rnor(i2)        ! Radial normalization of the GTOs
                    kntdst = kntdst + (2*la+1) * (2*lb+1)
!    Determines an approximation to the sigma overlap to see whether the integrals can be neglected
                    i1pini = ipntprim(i1)
                    i2pini = ipntprim(i2)
                    i1pfin = ipntprim(i1) + nprimit(i1) - 1
                    i2pfin = ipntprim(i2) + nprimit(i2) - 1
                    aux = cero
                    bux = la + lb + 1.5d0
                    do i1p = i1pini, i1pfin
                        do i2p = i2pini, i2pfin
                            cux = xxg(i1p) * xxg(i2p) * rab * rab / (xxg(i1p)+xxg(i2p))
                            if(cux.le.300.d0) aux = aux+cfcontr(i1p)*cfcontr(i2p)*exp(-cux)/(xxg(i1p)+xxg(i2p))**bux
                        enddo
                    enddo
                    if (mod(la+lb,2) .eq. 0) then
                        aux = facts(la+lb) * abs(aux) * rnab
                    else
                        aux = fact((la+lb+1)/2) * abs(aux) * rnab
                    endif
                    if (abs(aux) .lt. thresoverlap) cycle    ! Negigible charge distribution
                    kntdstef = kntdstef + (2*la+1) * (2*lb+1)
!    Reads the pertinent block of density matrix and rotates it to the AB aligned system. Loads the result in roblk.
!    Angular normalization factors are introduced at the end of the loading process.
                    if (lrotar) then
                        do i = -la, la
                            ishift = i+la+nfa
                            do j = -lb, lb
                                roblk(i,j) = dmat(ishift,j+lb+nfb)
                            enddo
                        enddo
!                        Rotation on center B
                        do i = -la, la
                            do j = -lb, lb
                                roaux(i,j) = dot_product(roblk(i,-lb:lb),rl(-lb:lb,j,lb))
                            enddo
                        enddo
!                        Rotation on center A and introduction of the angular and radial normalization
                        do i = -la, la
                            do j = -lb, lb
                                roblk(i,j) = ang(ind(la)+abs(i)+1) * ang(ind(lb)+abs(j)+1) * rnab &
                                        * dot_product(roaux(-la:la,j), rl(-la:la,i,la))
                            enddo
                        enddo
                    else
!                         Introduction of the angular and radial normalization in case of no rotation
                        do i = -la, la
                            ishift = i+la+nfa
                            do j = -lb, lb
                                roblk(i,j) = ang(ind(la)+abs(i)+1) * ang(ind(lb)+abs(j)+1) * rnab * dmat(ishift,j+lb+nfb)
                            enddo
                        enddo
                    endif

!                     Computes the radial factors associated to the translation of the distribution

                    call fradABgauss(i1, i2, az, bx, bz)

!                    Multiplies the radial factors by the density matrix and accumulates

                    do j = -lb, lb
                        do i = -la, la
                            aux = roblk(i,j)
                            if (ia .ne. ib) aux = aux + aux
                            do lm = 1, (lexpansion+1) * (lexpansion+1)
                                fcent(1:nquadpoints,lm) = fcent(1:nquadpoints,lm) + aux * flm(1:nquadpoints,i,j,lm)
                            enddo
                        enddo
                    enddo
                enddo    ! End of Do i2 over shells in ib
            enddo    ! End of Do i1 over shells in ia

!    Rotates the radial factors back to the molecular axis system and accumulates
!
!    IMPORTANT !!!     The radial factors computed here are those multiplying UNNORMALIZED real spherical harmonics in the
!                expansion of the density
!
            if (lrotar) then
                lm = 0
                kml = 0
                do l = 0, lexpansion
                    do m = -l, l
                        lm = lm + 1
                        lk = l*(l+1)+1
                        do k = -l, l
                            kml = kml + 1
                            ftot(1:nquadpoints,lm) = ftot(1:nquadpoints,lm) + fcent(1:nquadpoints,lk+k) * rlt(kml)
                        enddo
                    enddo
                enddo
            else
                lm = 0
                do l = 0, lexpansion
                    do m = -l, l
                        lm = lm + 1
                        ftot(1:nquadpoints,lm) = ftot(1:nquadpoints,lm) + fcent(1:nquadpoints,lm)
                    enddo
                enddo
            endif
        enddo    ! End of Do over centers (ib)
    enddo    ! End of Do over centers (ia)
    tiempo = dtime(tarray)
    write(6,"(1x,//80('='),/'Timing in seconds for radial factors (user, system, total):',/5x,'(',e12.5,',',e12.5,',',e12.5')')") &
            tarray(1), tarray(2), tarray(1)+tarray(2)
    write(6,"(1x,'Elapsed time = ', e12.5)") tiempo
    tiemponw = dtime(tarraynw)

    write(6,"('Total number of different distributions = ',i10)") kntdst
    write(6,"('Total number of non-negligible different distributions = ',i10)") kntdstef
    deallocate(dl, fcent, flm, flmmamb, rl, rlt)

!     Prints the valus of radial factors in quadrature points (unseal for testing)
!     do lm = 1, (lexpansion+1)*(lexpansion+1)
!         if (abs(ftot(1,lm)) .gt. 1.d-10) &
!             write(6,"('ftot(',i3,') = ', 8(1x,e17.10))") lm, ftot(1:nquadpoints,lm)
!     enddo

!     Computes the multipolar moments from the radial factors (unseal for testing)
!     lm = 0
!     weights = weights01 * rstar
!     do l = 0, lexpansion
!         weights = weights * rquadscal * rquadscal
!         do m = -l, l
!             lm = lm + 1
!             aux = 4.d0 * pi * dot_product(weights, ftot(1:nquadpoints,lm)) * ri(l+l+1)
!             if (abs(aux) .gt. 1.d-15) write(6,"('qlm(',i2,',',i3,') = ',e22.15)") l, m, aux
!         enddo
!     enddo

!     Computes Zernike 3D or Jacobi moments (integrals with normalized Zernike 3D or Jacobi functions)

    allocate(omeganlm(0:kexpansion,(lexpansion+1)*(lexpansion+1)), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating omeganlm. Stop')

    omeganlm = cero
    call clmn_subr

!     Computes molecular multipoles from Zernike 3D or Jacobi expansions

    call multipoles

    tiemponw = dtime(tarraynw)
    write(6,"(1x,//80('='),/'Timing in seconds for projection (user, system, total):',/5x,'(',e12.5,',',e12.5,',',e12.5')')") &
            tarraynw(1), tarraynw(2), tarraynw(1)+tarraynw(2)
    write(6,"(1x,'Elapsed time = ', e12.5)") tiemponw

!     Writes Zernike 3D or Jacobi moments to .zernike or .jacobi file

    if (ljacobi) then
        open(99,file=trim(projectname)//".jacobi",form='formatted', iostat=ierr)
        if (ierr .ne. 0) call error(ierr,'Cannot open file '//trim(projectname)//'.jacobi. Stop')
    else
        open(99,file=trim(projectname)//".zernike",form='formatted', iostat=ierr)
        if (ierr .ne. 0) call error(ierr,'Cannot open file '//trim(projectname)//'.zernike. Stop')
    endif

    write(99,*) rstar
    write(99,*) lexpansion, kexpansion
    do l = 0, lexpansion
        do m = -l, l
            write(99,"(8(1x,e22.15))") omeganlm(0:kexpansion,l*(l+1)+m+1)
        enddo
    enddo

!     Computes and prints fingerprints (rotationally invariant) associated to Zernike 3D or Jacobi expansions
    if (ljacobi) then
        write(6,"(/' Rotationally invariant fingerprints for Jacobi expansion: sqrt( sum_{m=-l}^l |c_kl^m|^2 )',/91(1H=),/)")
    else
        write(6,"(/' Rotationally invariant fingerprints for Zernike 3D expansion: sqrt( sum_{m=-l}^l |c_kl^m|^2 )',/95(1H=),/)")
    endif
    tiemponw = dtime(tarraynw)
    lm = 0
    n = kexpansion
    do l = 0, lexpansion
        vinvariant = 0.d0
        do m = -l, l
            lm = lm + 1
            vinvariant = vinvariant + omeganlm(0:n,lm)*omeganlm(0:n,lm)
        enddo
        write(6,"('l = ', i3, ': ', 8(1x,e17.10))") l, sqrt(vinvariant)
    enddo

!     Prints data to file projectname.mth for checking (for instance, with Mathematica) 

    if (lmthfile) then
        if (ljacobi) then
            open(17,file=trim(projectname)//"-Jacobi.mth",form='formatted', iostat=ierr)
        else
            open(17,file=trim(projectname)//"-Zernike.mth",form='formatted', iostat=ierr)
        endif
        if (ierr .ne. 0) call error(ierr,'Cannot open file '//trim(projectname)//'.mth. Stop')
        if (ljacobi) then
            i = 1
        else
            i = 0
        endif
        write(17,*) i, rstar, lexpansion, kexpansion, nquadpoints
        write(17,"(10(1x,e22.15))") weights01(1:nquadpoints) * rstar
        write(17,"(10(1x,e22.15))") rquadscal(1:nquadpoints)
        lm = 0
        do l = 0, lexpansion
            do m = -l, l
                lm = lm + 1
                write(17,"(10(1x,e22.15))") ftot(1:nquadpoints,lm) / ang(ind(l)+abs(m)+1)
            enddo
        enddo
        do l = 0, lexpansion
            do m = -l, l
                write(17,"(10(1x,e22.15))") omeganlm(0:kexpansion,l*(l+1)+m+1)
            enddo
        enddo
        close(17)
    endif
    return
    end
!
!    ***************************************************************
!
!     Computes the Zernike 3D Moments (expansion coefficients of radial factors flm in Zernike 3D functions )
!
  subroutine omeganlm_zernike
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: k, l, m, n
    weights =  sqrt(rstar) * weights01
    rquadaux = rstar * rquad01 * rquad01
    n = kexpansion
    do l = 0, lexpansion    ! Loop over Zernike's functions
        weights = weights * rquadaux
        call zernike3DR(l)
        if (lechelon) n = kexpansion - l
        do k = 0, n
            vaux = weights * radfunction(1:nquadpoints,k)
            do m = -l, l
                omeganlm(k,l*(l+1)+m+1) = dot_product(vaux,ftot(1:nquadpoints, l*(l+1)+m+1)) / ang(ind(l)+abs(m)+1)
            enddo
        enddo
    enddo
    return
    end
!
!    ***************************************************************
!
!     Computes the Zernike 3D expansions of radial factors in the quadrature points
!
  subroutine frad_zernike
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: i, k, l, m, n
    ftot = 0.d0
    rquadaux = 1.d0 / (rstar*sqrt(rstar))
    n = kexpansion
    do l = 0, lexpansion    ! Loop over Zernike's functions
        call zernike3DR(l)
        if (lechelon) n = kexpansion - l
        do k = 0, n
            vaux = rquadaux * radfunction(1:nquadpoints,k)
            do m = -l, l
                do i = 1, nquadpoints
                    ftot(i,l*(l+1)+m+1) = ftot(i,l*(l+1)+m+1) + omeganlm(k,l*(l+1)+m+1) * vaux(i) * ang(ind(l)+abs(m)+1)
                enddo
            enddo
        enddo
        rquadaux = rquadaux * rquad01
    enddo
    return
    end
!
!    ***************************************************************
!
!     Computes the radial part of Zernike 3D functions divided by (r/r*)^l in the quadrature points
! 
  subroutine zernike3DR(l)
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: i, jshift, k, kshift, l, n
    real(KREAL) :: rqsq(nquadpoints)
    rqsq = rquad01 * rquad01
    jshift = (kexpansion+1)*l+1
    kshift = 2*l+7
    if (lechelon) then
        n = kexpansion - l
    else
        n = kexpansion
    endif
    do i = 1, nquadpoints
        gkl(-1) = 0.d0
        gkl(0) = 1.d0
        radfunction(i,0) = root(2*l+3)
        do k = 0, n-1
            gkl(k+1) = (cfgkl1(jshift+k) - cfgkl2(jshift+k) * rqsq(i)) * gkl(k) - cfgkl3(jshift+k) * gkl(k-1)
            radfunction(i,k+1) = akgkl(k+1) * root(kshift+4*k) * gkl(k+1)
        enddo
    enddo
    return
    end
!
!    ***************************************************************
!
!     Computes the Jacobi Moments (expansion coefficients of radial factors flm in Jacobi P(0,2+2l) polynomials)
!
  subroutine omeganlm_jacobi
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: k, l, m, n
    weights =  sqrt(rstar) * weights01
    rquadaux = rstar * rquad01 * rquad01
    n = kexpansion
    do l = 0, lexpansion    ! Loop over Zernike's functions
        weights = weights * rquadaux
        call jacobiP(l)
        if (lechelon) n = kexpansion - l
        do k = 0, n
            vaux = weights * radfunction(1:nquadpoints,k)
            do m = -l, l
                omeganlm(k,l*(l+1)+m+1) = dot_product(vaux,ftot(1:nquadpoints, l*(l+1)+m+1)) / ang(ind(l)+abs(m)+1)
            enddo
        enddo
    enddo
    return
    end
!
!    ***************************************************************
!
!     Computes the Jacobi ( P(0,2+2l) ) expansions of radial factors in the quadrature points
!
  subroutine frad_jacobi
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: i, k, l, m, n
    real(KREAL) :: aux
    ftot = 0.d0
    rquadaux = 1.d0 / (rstar*sqrt(rstar))
    n = kexpansion
    do l = 0, lexpansion    ! Loop over Zernike's functions
        call jacobiP(l)
        if (lechelon) n = kexpansion - l
        do k = 0, n
            vaux = rquadaux * radfunction(1:nquadpoints,k)
            do m = -l, l
                do i = 1, nquadpoints
                    ftot(i,l*(l+1)+m+1) = ftot(i,l*(l+1)+m+1) + omeganlm(k,l*(l+1)+m+1) * vaux(i) * ang(ind(l)+abs(m)+1)
                enddo
            enddo
        enddo
        rquadaux = rquadaux * rquad01
    enddo
    return
    end
!
!**********************************************************************
! 
!     Computes the Jacobi polynomials P(0,2+2l)(2t-1)
!
  subroutine jacobiP(l)
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: k, l, n
    real(KREAL) :: t
    if (lechelon) then
        n = kexpansion - l
    else
        n = kexpansion
    endif
    radfunction(1:nquadpoints,0) = 1.d0
    radfunction(1:nquadpoints,1) = 4.d0 * rquad01 - 3.d0 + dble(l+l) * (rquad01 - 1.d0)
    do k = 1, n-1
        radfunction(1:nquadpoints,k+1) = (dble(2*k+2*l+3) * (dble((k+l+1)*(k+l+2)) * (2.d0*rquad01-1.d0) - dble((l+1)*(l+1))) &
                * radfunction(1:nquadpoints,k) - dble(k*(k+l+2)*(k+2*l+2))*radfunction(1:nquadpoints,k-1)) &
                / dble((k+1)*(k+l+1)*(k+2*l+3))
    enddo
    do k = 0, n
        radfunction(1:nquadpoints,k) = radfunction(1:nquadpoints,k) * root(2*(k+l)+3)
    enddo
    return
    end
!
!    ***************************************************************
!
! Computes the multipolar moments from the Zernike 3D expansion or Jacobi expansion ( P^(0,2+2l) ). 
! Only the first Zernike 3D or Jacobi polynomial (n = l) of each  (l,m)  
! contributes to the corresponding multipolar moment, the remaining ones integrate to zero.
! Multipolar moments defined here as the coefficients that multiply the unnormalized irregular harmonics in the long-range 
! expansion of the electrostatic potential, q(l,m), are displayed in the third column.
! Rotationally invariant multipole moments: q(l,m) * sqrt((1+delta(m,0)) *  (l+|m|)!/(l-|m|)! ) 
! are listed in fourth column.
! Modules of the rotationally invariant multipole moments are displayed in the fifth column for each l
!
  subroutine multipoles
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: l, lm, m, n
    real(KREAL) :: aux, bux, buxmod
    if (lvalence) then
        write(6,"(//'Non-vanishing multipole components of electron valence computed from the expansion')")
    else
        write(6,"(//'Non-vanishing multipole components of electron cloud computed from the expansion')")
    endif
    write(6,"(82(1H=),//t5,'l', t10, 'm', t23,'q(l,m)',t45,'q(l,m) * sqrt((1+delta(m,0)) (l+|m|)!/(l-|m|)!)',t98,'qlmod'/)")
    lm = 0
    do l = 0, lexpansion
        buxmod = 0.d0
        do m = -l, l
            lm = lm + 1
            aux = omeganlm(0,lm) * fact(l-abs(m)) * facti(l+abs(m)) * sqrt(rstar**(2*l+3) * ri(2*l+3)) &
                    / (ang(ind(l)+abs(m)+1))
            if (m .ne. 0) aux = aux + aux
            bux = aux * sqrt(fact(l+abs(m)) * facti(l-abs(m)))
            if (m .eq. 0) bux = raiz2 * bux
            buxmod = buxmod + bux * bux
            if (m .lt. l) then
                if (abs(aux) .gt. thresmult) write(6,"(t4,i2,t8,i3,t16,1x,e22.15,15x,e22.15)") l, m, -aux, -bux
            else
                write(6,"(t4,i2,t8,i3,t16,1x,e22.15,15x,e22.15,14x,e22.15,/)") l, m, -aux, -bux, sqrt(buxmod)
            endif
        enddo
    enddo
    return
    end

!**********************************************************************
!    subroutine consta
!
!    Computes and stores auxiliary constants
!        re(i) = dfloat(i)
!        r1(i) = 1.d0 / dfloat(i)
!        fact(i) = dfloat(i!)
!        facti(i) = 1.d0 / dfloat(i!)
!        ind(i) = i*(i+1)/2
!        root(i) = dfloat(sqrt(i))
!        rooti(i) = 1.d0 / dfloat(sqrt(i))
!        ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m) 
!            / (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
!
!**********************************************************************
  subroutine consta
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: i, ierr, ikt, ip, j, k, k1, k12, knt, kntlm, l, l1, l1l1, l2, l2l2, la, lb, lm, lp
    integer(KINT) :: m, m1, m1a, m2, m2a, ma, mb, md, ms, mxang, n, np, nu
    real(KREAL) :: aux, aux1, aux2, auxk, auxm, bux, cux, sd, sgn, ss
!    auxiliary parameters and functions
    pi = acos(-uno)
    raizpi = sqrt(pi)
    pimed = umed * pi
    pimedsqr = sqrt(pimed)   ! Sqrt[pi/2]
    re(0) = cero
    ri(0) = 1.d300
    dosl1(0) = uno
    dosl1i(0) = uno
    do i = 1, mxreal
        re(i) = re(i-1) + uno        ! dfloat(i)
        re(-i) = -re(i)
        ri(i) = uno / re(i)           ! uno / dfloat(i)
        ri(-i) = -ri(i)
        dosl1(i) = re(i) + re(i) + uno    ! dfloat(iì)
        dosl1(-i) = -re(i) - re(i) + uno
        dosl1i(i) = uno / dosl1(i)        ! dfloat( 1/(i+i+1) )
        dosl1i(-i) = uno / dosl1(-i)
    enddo
    fact(0) = uno
    facti(0) = uno
    facts(-1) = raizpi
    facts(0) = facts(-1) * umed
    factsi(-1) = uno / facts(-1)    ! factsi in module GAUSS
    factsi(0) = uno / facts(0)
    do i = 1, mxfact
        fact(i) = fact(i-1) * re(i)               !  i!
        facts(i) = facts(i-1) * re(i+i+1) * umed    ! (i+1/2)!
        facti(i) = uno / fact(i)                    !  uno / i!
        factsi(i) = uno / facts(i)                !  uno / (i+1/2)!
    enddo
    mxind = (mxltot+1)*(mxltot+2)/2
    allocate(ind(0:mxind), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ind in consta. Stop')
    ind(0) = 0
    do i = 1, mxind
        ind(i) = ind(i-1) + i         !  i*(i+1)/2
    enddo
    root(0) = cero
    do i = 1, mxroot
        root(i) = sqrt(re(i))        !  sqrt(i)
        rooti(i) = uno / root(i)     !  uno / sqrt(i)
    enddo

    mxang = max(lexpansion,mxl)
    allocate(ang((mxang+1)*(mxang+2)/2), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ang in consta. Stop')
!    ang(l*(l+1)/2+m+1) = sqrt( (2*l+1) * fact(l-m) / (2 * pi * (1 + delta(m,0)) * fact(l+m)) )
    ang(1) = umed / raizpi
    lm = 1
    do l = 1, mxang
        lm = lm + 1
        ang(lm) = ang(1) * sqrt(re(2*l+1))
        aux = ang(lm) * raiz2
        do m = 1, l
            lm = lm + 1
            aux = aux / sqrt(re(l-m+1)*re(l+m))
            ang(lm) = aux
        enddo
    enddo

!     Computes and stores the coefficients for recursion of Zernike 3D functions
    n = (kexpansion+1)*(lexpansion+1)
    allocate(akgkl(0:kexpansion), cfgkl1(n), cfgkl2(n), cfgkl3(n), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating akgkl, cfgkl1, cfgkl2 and cfgkl3. Stop')
    akgkl(0) = 1.d0        ! akgkl(k) = (-1)^k (k-1/2)! / (sqrt(pi) * k!)
    do k = 0, kexpansion-1
        akgkl(k+1) = - re(2*k+1) * ri(2*k+2) * akgkl(k)
    enddo
    knt = 0
    do l = 0, lexpansion
        do k = 0, kexpansion
            knt = knt + 1
            cfgkl1(knt) = re(4*k+2*l+3) * dble(4*k*(2*k+2*l+3)+4*l*(l+2)+3) &
                    * ri(2*k+2*l+3) * ri(2*k+1) * ri(4*k+2*l+1)
            cfgkl2(knt) = re(4*k+2*l+3) * re(4*k+2*l+5) * ri(2*k+2*l+3) * ri(2*k+1)
            cfgkl3(knt) = dble(4*k*k) * re(4*k+2*l+5) * re(2*k+2*l+1) &
                    * ri(4*k+2*l+1) * ri(2*k+2*l+3) * ri(2*k-1) * ri(2*k+1)
        enddo
    enddo

!     Tabulates the coefficients for the decomposition of products
!     of two functions depending on phi (sin (m*phi), cos (m*phi))
!     into functions of the same type
    mxemes = mxltot
    allocate(ssv(-mxemes:mxemes,-mxemes:mxemes), sdv(-mxemes:mxemes,-mxemes:mxemes), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating ssv and sdv in consta. Stop')
    allocate(msv(-mxemes:mxemes,-mxemes:mxemes), mdv(-mxemes:mxemes,-mxemes:mxemes), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating msv and mdv in consta. Stop')
    do m2 = -mxemes, mxemes
        do m1 = -mxemes, mxemes
            call emes ( m1, m2, ms, md, ss, sd )
            msv(m1,m2) = ms
            mdv(m1,m2) = md
            ssv(m1,m2) = ss
            sdv(m1,m2) = sd
        enddo
    enddo
!    Coefficients for the decomposition of products of regular spherical harmonics into
!    regular spherical harmonics
    mxlcof = mxltot*(mxltot+3)/2
    mxkcof = mxlcof*(mxlcof+3)/2
    allocate(app(0:2*mxltot+1,0:mxkcof), stat = ierr)
    if (.not. allocated(app)) call error(ierr,'Memory error when allocating app. Stop')
    if (longoutput) write(6,"('Size of app   = ', i15, ' bytes')") size(app)
    allocate(bpp(0:2*mxltot+1,0:mxkcof), stat = ierr)
    if (.not. allocated(bpp)) call error(ierr,'Memory error when allocating bpp. Stop')
    if (longoutput) write(6,"('Size of bpp   = ', i15, ' bytes')") size(bpp)
    call acof
    call bcof
!    Tabulates some auxiliary indices for locating the previous coefficients
    allocate(indk12((mxltot+1)**2,(mxltot+1)**2), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating indk12 in consta. Stop')
    do l2 = 0,mxltot
        do l1 = 0,mxltot
            do m2 = -l2, l2
                do m1 = -l1, l1
                    l1l1 = ind(l1)
                    l2l2 = ind(l2)
                    m1a = abs(m1)
                    m2a = abs(m2)
                    if ( l1.eq.l2 ) then
                        k1 = l1l1 + max(m1a,m2a)
                        k12 = ind(k1) + l1l1 + min(m1a,m2a)
                    elseif (l1.gt.l2) then
                        k1 = l1l1 + m1a
                        k12 = ind(k1) + l2l2 + m2a
                    else
                        k1 = l2l2 + m2a
                        k12 = ind(k1) + l1l1 + m1a
                    endif
                    indk12(l1*(l1+1)+m1+1,l2*(l2+1)+m2+1) = k12
                end do
            end do
        end do
    end do

!    Polynomials P_k^(L,M;L',M')(0,0,1) of the shift-operators technique in the alligned-axes system

    allocate(ipntpolP(0:mxl+lexpansion,0:mxl), stat = ierr)    ! Pointers to the elements P_0^(L,0;L',0)
    if (ierr .ne. 0) call error(ierr,'Error allocating ipntpolP. Stop')

    n = (mxl+1) * (mxl+2) * (mxl+3) * (mxl+4) / 24 + lexpansion * (mxl+1) * (mxl+2) * (mxl+3) / 6

    allocate(polP(n), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Error allocating polP. Stop')

    call subpolP001(mxl+lexpansion, mxl)
    return
    end
!
!   *******************************************************************
!
  subroutine acof
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: k1, k2, k20, k200, kk, kk0, kk00, l, lp, m, m1, mp, n
    real(KREAL) :: aux, bux
    app = cero
!
!   starting elements app(00,lm)(n) = delta(l,n)
!
    k1 = 0
    do l = 0 , mxltot
        do m = 0 , l
            kk = ind(k1)
            app(l,kk) = uno
            k1 = k1 + 1
        enddo
    enddo
!
!   elements app(lm,m'm')(n)
!
    do mp = 1 , mxltot
        k2 = ind(mp) + mp
        k20 = ind(mp-1) + mp-1
        do l = mp , mxltot
            if ( l.eq.mp ) then
                m1 = mp
            else
                m1 = 0
            endif
            do m = m1 , l
                k1 = ind(l) + m
                kk = ind(k1) + k2
                kk0 = ind(k1) + k20
                do n = l-mp , l+mp , 2
                    if ( n.ge.m+mp) then
                        app(n,kk) = (2*mp-1) * ( app(n-1,kk0) * ri(n+n-1) - app(n+1,kk0) * ri(n+n+3) )
                    endif
                enddo
            enddo
        enddo
    enddo
!
!   elements app(lm,l'm')(n)
!
    do mp = 0 , mxltot
        k200 = 0
        do lp = mp+1 , mxltot
            k2 = ind(lp) + mp
            k20 = ind(lp-1) + mp
            if ( lp.gt.mp+1 ) k200 = ind(lp-2) + mp
            do l = lp , mxltot
                if ( l.eq.lp ) then
                    m1 = mp
                else
                    m1 = 0
                endif
                do m = m1 , l
                    k1 = ind(l) + m
                    kk = ind(k1) + k2
                    kk0 = ind(k1) + k20
                    kk00 = ind(k1) + k200
                    do n = l-lp , l+lp , 2
                        if ( n.ge.m+mp) then
                            aux = app(n+1,kk0) * re(n+m+mp+1) * dosl1i(n+1)
                            if ( n.gt.m+mp ) aux = aux + app(n-1,kk0) * re(n-m-mp) * dosl1i(n-1)
                            aux = aux * dosl1(lp-1)
                            if ( lp.gt.mp+1 ) aux = aux - re(lp+mp-1) * app(n,kk00)
                            app(n,kk) = aux * ri(lp-mp)
                        endif
                    enddo
                enddo
            enddo
        enddo
    enddo
    return
    end
!
!   *******************************************************************
!
  subroutine bcof
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: k1, k2, k20, k200, kk, kk0, kk00, l, lp, m, m1, mmp, mp, n
    real(KREAL) :: aux, bux, t1, t2
    bpp = cero
!
!   starting elements bpp(lm,00)(n) = delta(l,n)
!
    k1 = 0
    do l = 0 , mxltot
        do m = 0 , l
            kk = ind(k1)
            bpp(l,kk) = uno
            k1 = k1 + 1
        enddo
    enddo
!
!   elements bpp(lm,m'm')(n)
!
    do mp = 1 , mxltot
        k2 = ind(mp) + mp
        k20 = ind(mp-1) + mp-1
        do l = mp , mxltot
            if ( l.eq.mp ) then
                m1 = mp
            else
                m1 = 0
            endif
            do m = m1 , l
                k1 = ind(l) + m
                kk = ind(k1) + k2
                kk0 = ind(k1) + k20
                do n = l-mp , l+mp , 2
                    if ( mp.gt.m ) then
                        t1 = uno
                        t2 = uno
                    else
                        t1 = -re(n-(m-mp+1)) * re(n-(m-mp+1)+1)
                        t2 = -re(n+(m-mp+1)) * re(n+(m-mp+1)+1)
                    endif
                    if ( n.ge.abs(m-mp)) then
                        if (n.eq.0) then
                            bux=cero
                        else
                            bux=t1*bpp(n-1,kk0) * dosl1i(n-1)
                        endif
                        bpp(n,kk) = dosl1(mp-1) * ( bux - t2 * bpp(n+1,kk0) * dosl1i(n+1) )
                    endif
                enddo
            enddo
        enddo
    enddo
!
!   elements bpp(lm,l'm')(n)
!
    do mp = 0 , mxltot
        k200 = 0
        do lp = mp+1 , mxltot
            k2 = ind(lp) + mp
            k20 = ind(lp-1) + mp
            if ( lp.gt.mp+1 ) k200 = ind(lp-2) + mp
            do l = lp , mxltot
                if ( l.eq.lp ) then
                    m1 = mp
                else
                    m1 = 0
                endif
                do m = m1 , l
                    k1 = ind(l) + m
                    kk = ind(k1) + k2
                    kk0 = ind(k1) + k20
                    kk00 = ind(k1) + k200
                    do n = l-lp , l+lp , 2
                        mmp = abs(m-mp)
                        if ( n.ge.mmp) then
                            aux = bpp(n+1,kk0) * re(n+mmp+1) * dosl1i(n+1)
                            if ( n.gt.mmp ) aux = aux + bpp(n-1,kk0) * re(n-mmp) * dosl1i(n-1)
                            aux = aux * dosl1(lp-1)
                            if ( lp.gt.mp+1 ) aux = aux - re(lp+mp-1) * bpp(n,kk00)
                            bpp(n,kk) = aux * ri(lp-mp)
                        endif
                    enddo
                enddo
            enddo
        enddo
    enddo
    return
    end
!
!   ******************************************************************
!
  subroutine emes ( m1, m2, ms, md, ss, sd )
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: m1, m1a, m2, m2a, ms, md
    real(KREAL) :: s1, s2, s12, ss, sd
    s1 = sign(1,m1)
    s2 = sign(1,m2)
    s12 = s1 * s2
    m1a = iabs(m1)
    m2a = iabs(m2)
    ms = s12 * ( m1a + m2a )
    md = s12 * iabs( m1a - m2a )
    if ( ms.eq.md ) then
        ss = uno
        sd = cero
        return
    endif
    if ( m1.lt.0 .and. m2.lt.0 ) then
        ss = -umed
    else
        ss = umed
    endif
    if ( s12.gt.cero ) then
        sd = umed
    elseif ( md.eq.0 ) then
        sd = cero
    elseif ( sign(1,m1a-m2a) .eq. s1 ) then
        sd = - umed
    else
        sd = umed
    endif
    return
    end
    
!**********************************************************************
!
!   subroutine rotar
!
!    this subroutine yields the rotation matrices rl(m',m;l) of reals spherical harmonics
!    receives the trigonometric functions of Euler angles defining the rotation
!
!**********************************************************************
  subroutine rotar(lmax, cosal, sinal, cosbet, sinbet, cosga, singa)
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: l, lmax
    real(KREAL) :: cosag, cosal, cosamg, cosbet, cosga, sinag, sinal, sinamg, singa, sinbet, tgbet2
!    Initial matrices d0, r0, d1 and r1
    rl(:,:,:) = cero
    dl(:,:,:) = cero
    dl(0,0,0)  = uno
    rl(0,0,0)  = uno
    if(lmax.eq.0) return
    dl(1,1,1)  = (uno + cosbet) * umed
    dl(1,0,1)  =-sinbet/raiz2
    dl(1,-1,1) = (uno - cosbet) * umed
    dl(0,1,1)  =-dl(1,0,1)
    dl(0,0,1)  = dl(1,1,1)-dl(1,-1,1)
    dl(0,-1,1) = dl(1,0,1)
    dl(-1,1,1) = dl(1,-1,1)
    dl(-1,0,1) = dl(0,1,1)
    dl(-1,-1,1)= dl(1,1,1)
    cosag  = cosal * cosga - sinal * singa
    cosamg = cosal * cosga + sinal * singa
    sinag  = sinal * cosga + cosal * singa
    sinamg = sinal * cosga - cosal * singa
    rl(0,0,1)  = dl(0,0,1)
    rl(1,0,1)  = raiz2 * dl(0,1,1) * cosal
    rl(-1,0,1) = raiz2 * dl(0,1,1) * sinal
    rl(0,1,1)  = raiz2 * dl(1,0,1) * cosga
    rl(0,-1,1) =-raiz2 * dl(1,0,1) * singa
    rl(1,1,1)  = dl(1,1,1) * cosag - dl(1,-1,1) * cosamg
    rl(1,-1,1) =-dl(1,1,1) * sinag - dl(1,-1,1) * sinamg
    rl(-1,1,1) = dl(1,1,1) * sinag - dl(1,-1,1) * sinamg
    rl(-1,-1,1)= dl(1,1,1) * cosag + dl(1,-1,1) * cosamg
!    the remaining matrices are calculated using symmetry and recurrence relations by means of the subroutine dlmn.
    if ( abs(sinbet) .lt. 1.d-14 ) then
        tgbet2 = cero
    elseif ( abs(sinbet) .lt. 1.d-10 ) then
        tgbet2 = cero
        write(6,"('WARNING in ROTAR: sinbet = ', e17.10, ' takes  0')") sinbet
    else
        tgbet2 = ( uno - cosbet ) / sinbet
    endif
    do l = 2, lmax
        call dlmn(l, sinal, cosal, cosbet, tgbet2, singa, cosga)
    enddo
    return
    end
!**********************************************************************
!
!   subroutine dlmn
!
!   this subroutine generates the matrices dl(m',m;l) for a fixed value
!   of the orbital quantum number l, and it needs the dl(l-2;m',m) and 
!   dl(l-1;m',m) matrices. this subroutine uses symmetry and recurrence
!   relations. the matrices dl(m',m;l) are the rotation matrices for   
!   complex spherical harmonics
!
!**********************************************************************
  subroutine dlmn(l, sinal, cosal, cosbet, tgbet2, singa, cosga)
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: iinf, isup, l, m, mp
    real(KREAL) :: al, al1, ali, aux, cosag, cosagm, cosal, cosaux, cosbet, cosga, cosmal, cosmga, cux, d1, d2
    real(KREAL) :: sgn, sinag, sinagm, sinal, singa, sinmal, sinmga, tal1, tgbet2
    iinf=1-l
    isup=-iinf
!    computation of the dl(m',m;l) matrix, mp is m' and m is m.
!    first row by recurrence: see equations 19 and 20 of reference (6)
    dl(l,l,l) = dl(isup,isup,l-1) * (uno + cosbet) * umed
    dl(l,-l,l) = dl(isup,-isup,l-1) * (uno - cosbet) * umed
    do m = isup, iinf, -1
            dl(l,m,l) = -tgbet2 * root(l+m+1) * rooti(l-m) * dl(l,m+1,l)
    enddo
!    the rows of the upper quarter triangle of the dl(m',m;l) matrix see equation 21 of reference (6)
    al = l
    al1 = al - uno
    tal1 = al + al1
    ali = uno / al1
    cosaux = cosbet * al * al1
    do mp = l-1, 0, -1
        aux = rooti(l+mp) * rooti(l-mp) * ali
        cux = root(l+mp-1) * root(l-mp-1) * al
        do m = isup, iinf, -1
            dl(mp,m,l) = aux * rooti(l+m) * rooti(l-m) * (tal1 * (cosaux - re(m) * re(mp)) * dl(mp,m,l-1) &
                    - root(l+m-1) * root(l-m-1) * cux * dl(mp,m,l-2) )
        enddo
        iinf=iinf+1
        isup=isup-1
    enddo
!    the remaining elements of the dl(m',m;l) matrix are calculated using the corresponding symmetry relations:
!        reflection ---> ((-1)**(m-m')) dl(m,m';l) = dl(m',m;l), m'<=m
!        inversion ---> ((-1)**(m-m')) dl(-m',-m;l) = dl(m',m;l)
!    reflection
    sgn = uno
    iinf = -l
    isup = l-1
    do m = l, 1, -1
        do mp = iinf, isup
            dl(mp,m,l) = sgn * dl(m,mp,l)
            sgn = -sgn
        enddo
        iinf=iinf+1
        isup=isup-1
    enddo
!    inversion
    iinf=-l
    isup=iinf
    do m = l-1, -l, -1
        sgn = -uno
        do mp = isup, iinf,- 1
            dl(mp,m,l) = sgn * dl(-mp,-m,l)
            sgn = -sgn
        enddo
        isup=isup+1
    enddo
!    computation of the rotation matrices rl(m',m;l) for real spherical harmonics using the matrices dl(m',m;l) 
!    for complex spherical harmonics: see equations 10 to 18 of reference (6)
    rl(0,0,l) = dl(0,0,l)
    cosmal = cosal
    sinmal = sinal
    sgn = - uno
    do mp = 1, l
        cosmga = cosga
        sinmga = singa
        aux = raiz2 * dl(0,mp,l)
        rl(mp,0,l) = aux * cosmal
        rl(-mp,0,l)= aux * sinmal
        do m = 1, l
            aux = raiz2 * dl(m,0,l)
            rl(0,m,l) = aux * cosmga
            rl(0,-m,l)=-aux * sinmga
            d1 = dl(-mp,-m,l)
            d2 = sgn * dl(mp,-m,l)
            cosag = cosmal * cosmga - sinmal * sinmga
            cosagm= cosmal * cosmga + sinmal * sinmga
            sinag = sinmal * cosmga + cosmal * sinmga
            sinagm= sinmal * cosmga - cosmal * sinmga
            rl(mp,m,l)  = d1 * cosag + d2 * cosagm
            rl(mp,-m,l) =-d1 * sinag + d2 * sinagm
            rl(-mp,m,l) = d1 * sinag + d2 * sinagm
            rl(-mp,-m,l)= d1 * cosag - d2 * cosagm
            aux    = cosmga * cosga - sinmga * singa
            sinmga = sinmga * cosga + cosmga * singa
            cosmga = aux
        enddo
        sgn = - sgn
        aux    = cosmal * cosal - sinmal * sinal
        sinmal = sinmal * cosal + cosmal * sinal
        cosmal = aux
    enddo
    return
    end

!! ************************************************************************
! 
!       Subroutines for computing radial factors of two center distributions of CGTO
!
  subroutine fradABgauss(i1, i2, za, xb, zb)
    USE Zernike_Jacobi_GTO_D, lmxc => lexpansion, rflm => rquadscal
    implicit none

    logical lneglig(mxgauss*mxgauss)
    integer(kint) :: i, i1, i2, ij, indmx, indmxk, ipoint, j, ja, jb, k1, kmax, la, lb, lm
    integer(kint) :: lmmaxc, lmmaxccab, lmxcab, ktop, m, mp, na, nb, ngsa, ngsb, nna, nnb
    real(kreal), parameter :: umbrfmax = 1.d-15
    real(kreal) :: cijv(mxgauss*mxgauss)
    real(kreal) :: zlm((ldimaux+1)*(ldimaux+2)/2), zlmij((ldimaux+1)*(ldimaux+2)/2,mxgauss*mxgauss)
    real(kreal) :: aux, r, rabsq, rac, rbc, xb, xiij, xij, za, zb, zij

    la = ll(i1)
    lb = ll(i2)
    lmxcab = lmxc+la+lb
    lmmaxc = (lmxc+1)*(lmxc+1)
    flm = 0.d0
    rac = abs(za)
    rbc = sqrt(xb*xb+zb*zb)

!      reads exponents and contraction coefficients of the cgto functions at a and b
    ngsa = nprimit(i1)
    ngsb = nprimit(i2)
    do i = 1, ngsa
        xia(i) = xxg(ipntprim(i1)+i-1)
        cfa(i) = cfcontr(ipntprim(i1)+i-1)
    enddo

    do i = 1, ngsb
        xib(i) = xxg(ipntprim(i2)+i-1)
        cfb(i) = cfcontr(ipntprim(i2)+i-1)
    enddo

    ij = 0
    lmmaxccab = (lmxcab+1)*(lmxcab+2)/2
    rabsq = xb*xb + (zb-za) * (zb-za)

    do ja = 1, ngsa
        do jb = 1, ngsb
            ij = ij + 1
            xiij = 1.d0 / (xia(ja) + xib(jb))
            aux = xia(ja) * xib(jb) * rabsq * xiij
            if (aux .lt. 50.d0) then
                cijv(ij) = cfa(ja) * cfb(jb) * exp(-aux)
                xij = xb * xib(jb) * xiij
                zij = za + (zb - za) * xib(jb) * xiij
                call armonicosij(lmxcab, xij, zij, zlm)
                do lm = 1, lmmaxccab
                    if (abs(zlm(lm)) .gt. 1.d-100) then
                        zlmij(lm,ij) = zlm(lm)
                    else
                        zlmij(lm,ij) = 0.d0
                    endif
                enddo
                lneglig(ij) = .false.
            else
                lneglig(ij) = .true.
            endif
        enddo
    enddo

    do ipoint = 1, nquadpoints
        r = rflm(ipoint)
        call flmgauss(la, rac, lb, xb, zb, rbc, ngsa , ngsb, lmxcab, lneglig, zlmij, cijv, r)
        do mp = -lb, lb
            do m = -la, la
                do lm = 1, lmmaxc
                    flm(ipoint,m,mp,lm) =  flmmamb(lm,m,mp)
                enddo
            enddo
        enddo
    enddo
    return
    end subroutine fradABgauss
!  
! ************************************************************************
! 
  subroutine flmgauss(la, rac, lb, xb, zb, rbc, nga, ngb, lmaxini, lneglig, zlmij, cijv, r)
    USE Zernike_Jacobi_GTO_D
    implicit none
    logical lneglig(mxgauss*mxgauss)
    integer(KINT) :: i, ij, ip, itop, ja, jb, l, la, lb, ldim, lm, lmax, lmaxaux, lmaxbux, lmaxini, lmp, lmxcab, lmmax
    integer(KINT) :: m, nga, ngb
    real(KREAL) :: bsi(0:45), cijv(mxgauss*mxgauss), flmbas((ldimaux+1)*(ldimaux+2)/2), flmnnp((4+lmaxini)**2,mxl+1,mxl+1)
    real(KREAL) :: zlmij((ldimaux+1)*(ldimaux+2)/2,mxgauss*mxgauss)
    real(KREAL) :: a2, arg1, arg2, aux, bux, dlt, dosxiij, dosza, doszb, r, r2, ra, rac, rb, rbc, rgij
    real(KREAL) :: rgijsq, rmrijsq, rprijsq, rtop, xb, xij, xiij, za, zb, zij

    lmxcab = lmaxini
    ldim = 4+lmaxini
    r2 = r * r
    za = rac
    ij = 0
    lmmax = (lmxcab+1)*(lmxcab+2)/2
    do lm = 1, lmmax
        flmbas(lm) = 0.d0
    enddo
    do ja = 1, nga
        do jb = 1, ngb
            ij = ij + 1
            if (lneglig(ij)) cycle
            xiij = xia(ja) + xib(jb)
            xij = xb * xib(jb) / xiij
            zij = za + (zb - za) * xib(jb) / xiij
            rgijsq = xij * xij + zij * zij
            rgij = sqrt(rgijsq)
            rmrijsq = (r-rgij) * (r-rgij)
            rprijsq = (r+rgij) * (r+rgij)
            arg1 = 0.5d0 * xiij * rprijsq
            arg2 = 0.5d0 * xiij * rmrijsq
            if (min(arg1,arg2) .gt. 100.d0) cycle
            if (lmxcab .gt. 45) then
                write(6,"('Error in subroutine flmGTO, lmxcab = ', i3, ' higher than maximum allowed')")
                write(6,"('Higher value allowed due to Bessel functions parametrization = 45')")
                call error(1,'Stop')
            elseif (lmxcab .gt. 30) then
                itop = 44
                rtop = 91.d0
                call bibk91med(arg1,arg2,bsi(44),bsi(45))
            elseif (lmxcab .gt. 20) then
                itop = 29
                rtop = 61.d0
                call bibk61med(arg1,arg2,bsi(29),bsi(30))
            elseif(lmxcab .gt. 10) then
                itop = 19
                rtop = 41.d0
                call bibk41med(arg1,arg2,bsi(19),bsi(20))
            else
                itop = 9
                rtop = 21.d0
                call bibk21med(arg1,arg2,bsi(9),bsi(10))
            endif
            a2 = (arg1-arg2)*(arg1-arg2)
            do i = 1, itop
                bsi(itop-i) = (rtop-re(i+i))*bsi(itop+1-i) + a2*bsi(itop+2-i)
            enddo
            dosxiij = xiij + xiij
            aux = cijv(ij)
            lm = 0
            do l = 0, lmxcab
                bux = aux * bsi(l) * re(l+l+1)
                lm = lm + 1
                flmbas(lm) = flmbas(lm) + bux * zlmij(lm,ij)
                bux = (bux + bux) * ri(l) * ri(l+1)
                do m = 1, l
                    lm = lm + 1
                    flmbas(lm) = flmbas(lm) + bux * zlmij(lm,ij)
                    bux = bux * ri(l-m) * ri(l+m+1)
                enddo
                aux = aux * dosxiij
            enddo
        enddo  ! End of do on jb
    enddo  ! End of do on ja

    lmax = lmxcab
    if (la .eq. 0 .and. lb .eq. 0) then
        lm = 0
        lmp = 0
        do l = 0, lmax
            do m = -l, -1
                lm = lm + 1
                flmmamb(lm,0,0) = 0.d0
            enddo
            do m = 0, l
                lm = lm + 1
                lmp = lmp + 1
                flmmamb(lm,0,0) = flmbas(lmp)
            enddo
        enddo
        return
    endif
!     if .not. (la .eq. 0 .and. lb .eq. 0)  recursion on la and lb
    lm = 0
    do l = 0, lmax
        do m = 0, l
            lm = lm + 1
            flmnnp(lm,1,1) = flmbas(lm)
        enddo
    enddo

!    recursion on  n  for the subsequent recursion on l
!    notice that recursion on n  runs in steps of two 2
!    whereas the storage index runs in steps of one, thus:
!    n = n0 + 2  (i-1)
    r2 = r * r
    lmaxaux = lmax
    ra = rac
    aux = r2 + ra*ra
    dosza = ra+ra
    do i = 2, la+1
        lmaxaux = lmaxaux - 1
        flmnnp(1,i,1) = aux * flmnnp(1,i-1,1)  - dosza * r2 * ri(3) * flmnnp(2,i-1,1)
        lm = 1
        do l = 1, lmaxaux
            do m = 0, l-1
                lm = lm + 1
                flmnnp(lm,i,1) = aux * flmnnp(lm,i-1,1)  - dosza * ( re(l-m) * ri(l+l-1) * flmnnp(ind(l-1)+m+1,i-1,1) &
                        + r2 * re(l+m+1) * ri(l+l+3) * flmnnp(ind(l+1)+m+1,i-1,1) )
            enddo
            lm = lm + 1
            flmnnp(lm,i,1) = aux * flmnnp(lm,i-1,1)  - dosza * r2 * re(l+m+1) * ri(l+l+3) * flmnnp(ind(l+1)+l+1,i-1,1)
        enddo
    enddo

!    recursion on  np  for the subsequent recursion on lp
!    notice that recursion on np  runs in steps of two 2
!    whereas the storage index runs in steps of one, thus:
!    np = np0 + 2  (ip-1)
    rb = rbc
    aux = r2 + rb*rb
    doszb = zb+zb
    lmaxbux = lmax+1
    do ip = 2, lb+1
        lmaxbux = lmaxbux - 1
        lmaxaux = lmaxbux
        do i = 1, la+1
            lmaxaux = lmaxaux-1
!            l = 0  m = 0
            flmnnp(1,i,ip) = aux * flmnnp(1,i,ip-1) - doszb * r2 * ri(3) * flmnnp(2,i,ip-1) &
                    - xb * 0.6666666666666667d0 * r2 * flmnnp(3,i,ip-1)
            if (lmaxaux .eq. 0) cycle
!              l = 1  m = 0
            flmnnp(2,i,ip) = aux * flmnnp(2,i,ip-1) - doszb * ( flmnnp(1,i,ip-1) + r2 * .4d0 * flmnnp(4,i,ip-1) ) &
                    - xb * 1.2d0 * r2 * flmnnp(5,i,ip-1)
!              l = 1  m = 1
            flmnnp(3,i,ip) = aux * flmnnp(3,i,ip-1) - doszb * r2 * .6d0 * flmnnp(5,i,ip-1) - xb * ( 2.d0 * (flmnnp(1,i,ip-1) &
                    - r2 * .2d0 * flmnnp(4,i,ip-1)) + 2.4d0 * r2 * flmnnp(6,i,ip-1) )
            lm = 3
            do l = 2, lmaxaux
                lm = lm + 1
!                m = 0
                flmnnp(lm,i,ip) = aux * flmnnp(lm,i,ip-1) - doszb * ( re(l) * ri(l+l-1) * flmnnp(ind(l-1)+1,i,ip-1) &
                        + r2 * re(l+1) * ri(l+l+3) * flmnnp(ind(l+1)+1,i,ip-1) )  - xb * (- re(l) * re(l-1) * ri(l+l-1) &
                        * flmnnp(ind(l-1)+2,i,ip-1) + re(l+1) * re(l+2) * ri(l+l+3) * r2 * flmnnp(ind(l+1)+2,i,ip-1) )
                dlt = 2.d0
                do m = 1, l-1
                    lm = lm + 1
                    flmnnp(lm,i,ip) = aux * flmnnp(lm,i,ip-1) - doszb * ( re(l-m) * ri(l+l-1) &
                            * flmnnp(ind(l-1)+m+1,i,ip-1) + r2 * re(l+m+1) * ri(l+l+3) * flmnnp(ind(l+1)+m+1,i,ip-1) ) &
                            - xb * ( dlt * (ri(l+l-1) * flmnnp(ind(l-1)+m,i,ip-1) - r2 * ri(l+l+3) * flmnnp(ind(l+1)+m,i,ip-1))&
                            - re(l-m) * re(l-m-1) * ri(l+l-1) * flmnnp(ind(l-1)+m+2,i,ip-1) &
                            + re(l+m+1) * re(l+m+2) * ri(l+l+3) * r2 * flmnnp(ind(l+1)+m+2,i,ip-1) )
                    dlt = 1.d0
                enddo
                lm = lm + 1
                flmnnp(lm,i,ip) = aux * flmnnp(lm,i,ip-1) - doszb * ( r2 * re(l+l+1) * ri(l+l+3) &
                        * flmnnp(ind(l+1)+l+1,i,ip-1))- xb * ( ri(l+l-1) * flmnnp(ind(l-1)+l,i,ip-1) - r2 * ri(l+l+3)  &
                        * flmnnp(ind(l+1)+l,i,ip-1) + re(l+l+1) * re(l+l+2) * ri(l+l+3) * r2 * flmnnp(ind(l+1)+l+2,i,ip-1) )
            enddo   ! end of do on l
        enddo   ! end of do on i
    enddo   ! end of do on ip
    call recurflm(ldim, lmax, la, lb, r2, rac, xb, zb, flmnnp)
    return
    end subroutine flmgauss
! 
! ***************************************************************
! 
!     Subrutine for recursion of the radial factors of the distribution
!     Indices (l,m) are contracted to a single one:
!         lm = l2 + l + m + 1
! 
  subroutine recurflm(ldim, lmaxtot, la, lb, r2, za, xb, zb, fin)
    USE Zernike_Jacobi_GTO_D, fvoid => flm
    implicit none
    logical :: lcux
    integer(KINT) :: ierr, knt, l, la, lb, ldim, lg, lgg, lm, lmax, lmaxaux, lmaxbux, lmaxtot, lmpos
    integer(KINT) :: m, ma, mb, mm, n, nmax, np, npmax
    real(KREAL) :: fin(ldim*ldim,mxl+1,mxl+1), flmaux(ldim*ldim)
    real(KREAL), allocatable :: flm(:,:,:,:,:)
    real(KREAL) :: aux, aux2, bux, cux, r2, s1, s1m, s2, s2m, s3, s3m, s4, s4m, s5, s5m
    real(KREAL) :: s6, s6m, s7, s7m, s8, s8m, sxnn, sxnp, sxpn, sxpp, xb, za, zb, umdltm0, updltm1, umdltm1

    lmax = lmaxtot
!     nmax = max(1,la)
!     npmax = max(1,lb)
    nmax = la+1
    npmax = lb+1
    allocate(flm(ldim*ldim,la+1,lb+1,-(la+1):(la+1),-(lb+1):(lb+1)), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating flm. Stop')

!     loads the content of  fin  into  flm(lm,n,np,0,0)
    lmaxbux = lmax
    do np = 1, npmax
        lmaxaux = lmaxbux
        do n = 1, nmax
            lm = 0
            lmpos = 0
            do l = 0, lmaxaux
                do m = -l, -1
                    lm = lm + 1
                    flm(lm,n,np,0,0) = 0.d0
                enddo
                do m = 0, l
                    lm = lm + 1
                    lmpos = lmpos + 1
                    flm(lm,n,np,0,0) = fin(lmpos,n,np)
                enddo
            enddo
            lmaxaux = lmaxaux -1
        enddo
        lmaxbux = lmaxbux - 1
    enddo

!  =========================
!      recursion on L    
!  =========================

    if (la .ge. 1) then
        do lg = 1, la

!           recursion of factors corresponding to  n = 1

            aux = real(lg+lg-1) * 0.5d0
            aux2 = aux+aux
            lmaxaux = lmax-lg+1
            n = 1
            do np = 1, npmax

!              elements with M = lg  and  M = -lg
                lmaxaux = lmaxaux-1
                do l  = 0, lmaxaux
                    do m  = 0, l
                        s1 = 0.d0
                        s2 = 0.d0
                        s3 = 0.d0
                        s4 = 0.d0
                        s5 = 0.d0
                        s6 = 0.d0
                        s7 = 0.d0
                        s8 = 0.d0
                        s1m = 0.d0
                        s2m = 0.d0
                        s3m = 0.d0
                        s4m = 0.d0
                        s5m = 0.d0
                        s6m = 0.d0
                        s7m = 0.d0
                        s8m = 0.d0
                        umdltm0 = 1.d0               ! umdltm0 = 1 - delta(m,0)
                        updltm1 = 1.d0               ! updltm1 = 1 + delta(m,1)
                        umdltm1 = 1.d0               ! umdltm1 = 1 - delta(m,1)
                        if (m .eq. 0) umdltm0 = 0.d0
                        if (m .eq. 1) then
                            umdltm1 = 0.d0
                            updltm1 = 2.d0
                        endif
                        if (m .gt. 0) then
                            s1 = r2 * ri(l+l+3) * flm((l+3)*l+m+2,n,np,lg-1,0)
                            s1m = r2 * ri(l+l+3) * flm((l+3)*l-m+4,n,np,lg-1,0)
                        endif
                        if (lg .gt. 1) then
                            s5 = r2 * ri(l+l+3) * flm((l+3)*l-m+4,n,np,-lg+1,0)
                            s5m = r2 * ri(l+l+3) * flm((l+3)*l+m+2,n,np,-lg+1,0)
                            s7 = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l-m+2,n,np,-lg+1,0)
                            s7m = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l+m+4,n,np,-lg+1,0)
                        endif
                        s3 = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l+m+4,n,np,lg-1,0)
                        s3m = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l-m+2,n,np,lg-1,0)
                        if (l .gt. 0) then
                            if (m .gt. 0) then
                                s2 = ri(l+l-1) * flm((l-1)*l+m,n,np,lg-1,0)
                                if (lg .gt. 1) s6m = ri(l+l-1) * flm((l-1)*l+m,n,np,-lg+1,0)
                            endif
                            if (m .gt. 1) then
                                s2m = ri(l+l-1) * flm((l-1)*l-m+2,n,np,lg-1,0)
                                if (lg .gt. 1) s6 = ri(l+l-1) * flm((l-1)*l-m+2,n,np,-lg+1,0)
                            endif
                            if (m .lt. l-1) then
                                s4 = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l+m+2,n,np,lg-1,0)
                                s4m = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l-m,n,np,lg-1,0)
                                if (lg .gt. 1) then
                                    s8 = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l-m,n,np,-lg+1,0)
                                    s8m = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l+m+2,n,np,-lg+1,0)
                                endif
                            endif
                        endif
                        if (m .gt. 0) then
                            flm(l*l+l-m+1,n,np,lg,0) = aux * (umdltm1*umdltm0*(-s1m+s2m) + s3m - s4m &
                                    - updltm1*umdltm0*(-s5m+s6m) + s7m - s8m )
                            flm(l*l+l-m+1,n,np,-lg,0) = aux *(updltm1*umdltm0*(-s1+s2) - s3 + s4 + umdltm1*umdltm0*(-s5+s6) &
                                    + s7 - s8)
                        endif
                        flm(l*l+l+m+1,n,np,lg,0) = aux *(updltm1*umdltm0*(-s1+s2) + s3 - s4 - umdltm1*umdltm0*(s5-s6) &
                                - s7 + s8 )
                        flm(l*l+l+m+1,n,np,-lg,0) =aux*(umdltm1*umdltm0*(s1m-s2m) +s3m -s4m + updltm1*umdltm0*(-s5m+s6m) &
                                + s7m - s8m)
                    enddo     ! End of Do on m
                enddo     ! End of Do on l

!             elements with   -lg < M < lg
                do mm = -lg+1, lg-1
                    bux = ri(lg-abs(mm))
                    if (lg-1-abs(mm) .le. 0) then
                        cux = 0.d0
                        lcux = .false.
                    else
                        cux = bux * re(lg+abs(mm)-1)
                        lcux = .true.
                    endif
                    do l  = 0, lmaxaux
                        do m  = 0, l
                            s1 = re(l+m+1) * ri(l+l+3) * r2 * flm((l+3)*l+m+3,n,np,mm,0)
                            s1m = re(l+m+1) * ri(l+l+3) * r2 * flm((l+3)*l-m+3,n,np,mm,0)
                            s2 = 0.d0
                            s2m = 0.d0
                            if (m .lt. l) then
                                s2 = re(l-m) * ri(l+l-1) * flm((l-1)*(l-1)+l+m,n,np,mm,0)
                                s2m = re(l-m) * ri(l+l-1) * flm((l-1)*(l-1)+l-m,n,np,mm,0)
                            endif
                            if (m .gt. 0) then
                                flmaux(l*l+l-m+1) = bux * aux2 * (s1m+s2m - za * flm(l*l+l-m+1,n,np,mm,0) )
                                if (lcux) flmaux(l*l+l-m+1) = flmaux(l*l+l-m+1) - cux * flm(l*l+l-m+1,n+1,np,mm,0)
                            endif
                            flmaux(l*l+l+m+1) = bux * aux2 * (s1+s2 - za * flm(l*l+l+m+1,n,np,mm,0))
                            if (lcux) flmaux(l*l+l+m+1) = flmaux(l*l+l+m+1) - cux * flm(l*l+l+m+1,n+1,np,mm,0)
                        enddo     ! End of Do on m
                    enddo     ! End of Do on l
                    do l  = 0, lmaxaux
                        flm(l*l+l+1,n,np,mm,0) = flmaux(l*l+l+1)
                        do m  = 1, l
                            flm(l*l+l+m+1,n,np,mm,0) = flmaux(l*l+l+m+1)
                            flm(l*l+l-m+1,n,np,mm,0) = flmaux(l*l+l-m+1)
                        enddo     ! End of Do on m
                    enddo     ! End of Do on l
                enddo     ! End of Do on mm
            enddo     ! End of Do on np

            if (lg .eq. la) exit  ! exits do on lg

!           recursion of factors with  n > 1

            if (lg .gt. 1) then
                lgg = lg
                do n  = 2, min(la,lg,la+1-lg)
                    lgg = lgg - 1
                    aux = real(lgg+lgg-1) * 0.5d0
                    aux2 = aux + aux
                    lmaxaux = lmax-lg-n+2
                    do np = 1, npmax

!                    elements with M = lgg  y  M = -lgg
                        lmaxaux = lmaxaux-1
                        do l  = 0, lmaxaux
                            do m  = 0, l
                                s1 = 0.d0
                                s2 = 0.d0
                                s3 = 0.d0
                                s4 = 0.d0
                                s5 = 0.d0
                                s6 = 0.d0
                                s7 = 0.d0
                                s8 = 0.d0
                                s1m = 0.d0
                                s2m = 0.d0
                                s3m = 0.d0
                                s4m = 0.d0
                                s5m = 0.d0
                                s6m = 0.d0
                                s7m = 0.d0
                                s8m = 0.d0
                                umdltm0 = 1.d0               ! umdltm0 = 1 - delta(m,0)
                                updltm1 = 1.d0               ! updltm1 = 1 + delta(m,1)
                                umdltm1 = 1.d0               ! umdltm1 = 1 - delta(m,1)
                                if (m .eq. 0) umdltm0 = 0.d0
                                if (m .eq. 1) then
                                    umdltm1 = 0.d0
                                    updltm1 = 2.d0
                                endif
                                if (m .gt. 0) then
                                    s1 = r2 * ri(l+l+3) * flm((l+3)*l+m+2,n,np,lgg-1,0)
                                    s1m = r2 * ri(l+l+3) * flm((l+3)*l-m+4,n,np,lgg-1,0)
                                endif
                                if (lgg .gt. 1) then
                                    s5 = r2 * ri(l+l+3) * flm((l+3)*l-m+4,n,np,-lgg+1,0)
                                    s5m = r2 * ri(l+l+3) * flm((l+3)*l+m+2,n,np,-lgg+1,0)
                                    s7 = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l-m+2,n,np,-lgg+1,0)
                                    s7m = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l+m+4,n,np,-lgg+1,0)
                                endif
                                s3 = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l+m+4,n,np,lgg-1,0)
                                s3m = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l-m+2,n,np,lgg-1,0)
                                if (l .gt. 0) then
                                    if (m .gt. 0) then
                                        s2 = ri(l+l-1) * flm((l-1)*l+m,n,np,lgg-1,0)
                                        if (lgg .gt. 1) then
                                            s6m = ri(l+l-1) * flm((l-1)*l+m,n,np,-lgg+1,0)
                                        endif
                                    endif
                                    if (m .gt. 1) then
                                        s2m = ri(l+l-1) * flm((l-1)*l-m+2,n,np,lgg-1,0)
                                        if (lgg .gt. 1) then
                                            s6 = ri(l+l-1) * flm((l-1)*l-m+2,n,np,-lgg+1,0)
                                        endif
                                    endif
                                    if (m .lt. l-1) then
                                        s4 = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l+m+2,n,np,lgg-1,0)
                                        s4m = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l-m,n,np,lgg-1,0)
                                        if (lgg .gt. 1) then
                                            s8 = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l-m,n,np,-lgg+1,0)
                                            s8m = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l+m+2,n,np,-lgg+1,0)
                                        endif
                                    endif
                                endif
                                if (m .gt. 0) then
                                    flm(l*l+l-m+1,n,np,lgg,0) = aux  * (umdltm1*umdltm0*(-s1m+s2m) + s3m - s4m &
                                            - updltm1*umdltm0*(-s5m+s6m) + s7m - s8m )
                                    flm(l*l+l-m+1,n,np,-lgg,0) = aux  * (updltm1*umdltm0*(-s1+s2) - s3 + s4 &
                                            + umdltm1*umdltm0*(-s5+s6) + s7 - s8 )
                                endif
                                flm(l*l+l+m+1,n,np,lgg,0) =aux*(updltm1*umdltm0*(-s1+s2) + s3 - s4 &
                                        - umdltm1*umdltm0*(s5-s6) - s7 + s8)
                                flm(l*l+l+m+1,n,np,-lgg,0)=aux*(umdltm1*umdltm0*(s1m-s2m) + s3m - s4m &
                                        + updltm1*umdltm0*(-s5m+s6m) + s7m - s8m )
                            enddo     ! End of Do on m
                        enddo     ! End of Do on l

!                    elements with   -lgg < M < lgg
                        do mm = -lgg+1, lgg-1
                            bux = ri(lgg-abs(mm))
                            if (lgg-1-abs(mm) .le. 0) then
                                cux = 0.d0
                                lcux = .false.
                            else
                                cux = bux * re(lgg+abs(mm)-1)
                                lcux = .true.
                            endif
                            do l  = 0, lmaxaux
                                do m  = 0, l
                                    s1 = re(l+m+1) * ri(l+l+3) * r2  * flm((l+3)*l+m+3,n,np,mm,0)
                                    s1m = re(l+m+1) * ri(l+l+3) * r2 * flm((l+3)*l-m+3,n,np,mm,0)
                                    s2 = 0.d0
                                    s2m = 0.d0
                                    if (m .lt. l) then
                                        s2 = re(l-m) * ri(l+l-1) * flm((l-1)*(l-1)+l+m,n,np,mm,0)
                                        s2m = re(l-m) * ri(l+l-1) * flm((l-1)*(l-1)+l-m,n,np,mm,0)
                                    endif
                                    if (m .gt. 0) then
                                        flmaux(l*l+l-m+1) = bux * aux2 * (s1m+s2m - za * flm(l*l+l-m+1,n,np,mm,0) )
                                        if (lcux) flmaux(l*l+l-m+1) = flmaux(l*l+l-m+1)-cux * flm(l*l+l-m+1,n+1,np,mm,0)
                                    endif
                                    flmaux(l*l+l+m+1) = bux * aux2 * (s1+s2 - za * flm(l*l+l+m+1,n,np,mm,0) )
                                    if (lcux) flmaux(l*l+l+m+1) = flmaux(l*l+l+m+1) - cux * flm(l*l+l+m+1,n+1,np,mm,0)
                                enddo     ! End of Do on m
                            enddo     ! End of Do on l
                            do l  = 0, lmaxaux
                                flm(l*l+l+1,n,np,mm,0) = flmaux(l*l+l+1)
                                do m  = 1, l
                                    flm(l*l+l+m+1,n,np,mm,0) = flmaux(l*l+l+m+1)
                                    flm(l*l+l-m+1,n,np,mm,0) = flmaux(l*l+l-m+1)
                                enddo     ! End of Do on m
                            enddo     ! End of Do on l
                        enddo     ! End of Do on mm
                    enddo     ! End of Do on np
                enddo     ! End of Do on n
            endif     ! End of  if (lg .gt. 1)
        enddo     ! End of Do on lg
    endif  ! End of if (la .ge. 1)

    lmax = lmax - la

! =========================
!     recursion on L'   
! =========================

    if (lb .ge. 1) then
        do lg = 1, lb

!           recursion of factors with  np = 1

            aux = re(lg+lg-1) * 0.5d0
            aux2 = aux+aux
            lmaxaux = lmax-lg

            n = 1
            np = 1
!        elements with M = lg  y  M = -lg
            do ma = -la, la
                do l  = 0, lmaxaux
                    do m  = 0, l
                        s1 = 0.d0
                        s2 = 0.d0
                        s3 = 0.d0
                        s4 = 0.d0
                        s5 = 0.d0
                        s6 = 0.d0
                        s7 = 0.d0
                        s8 = 0.d0
                        sxpp = 0.d0      ! xb * f(l,m,n,L,M,n',L',L')
                        sxnp = 0.d0      ! xb * f(l,-m,n,L,M,n',L',L')
                        s1m = 0.d0
                        s2m = 0.d0
                        s3m = 0.d0
                        s4m = 0.d0
                        s5m = 0.d0
                        s6m = 0.d0
                        s7m = 0.d0
                        s8m = 0.d0
                        sxpn = 0.d0      ! xb * f(l,m,n,L,M,n',L',-L')
                        sxnn = 0.d0      ! xb * f(l,-m,n,L,M,n',L',-L')
                        umdltm0 = 1.d0               ! umdltm0 = 1 - delta(m,0)
                        updltm1 = 1.d0               ! updltm1 = 1 + delta(m,1)
                        umdltm1 = 1.d0               ! umdltm1 = 1 - delta(m,1)
                        if (m .eq. 0) umdltm0 = 0.d0
                        if (m .eq. 1) then
                            umdltm1 = 0.d0
                            updltm1 = 2.d0
                        endif
                        if (m .gt. 0) then
                            s1 = r2 * ri(l+l+3) * flm((l+3)*l+m+2,n,np,ma,lg-1)
                            s1m = r2 * ri(l+l+3) * flm((l+3)*l-m+4,n,np,ma,lg-1)
                        endif
                        if (lg .gt. 1) then
                            s5 = r2 * ri(l+l+3) * flm((l+3)*l-m+4,n,np,ma,-lg+1)
                            s5m = r2 * ri(l+l+3) * flm((l+3)*l+m+2,n,np,ma,-lg+1)
                            s7 = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l-m+2,n,np,ma,-lg+1)
                            s7m = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l+m+4,n,np,ma,-lg+1)
                        endif
                        s3 = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l+m+4,n,np,ma,lg-1)
                        s3m = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l-m+2,n,np,ma,lg-1)
                        if (l .gt. 0) then
                            if (m .gt. 0) then
                                s2 = ri(l+l-1) * flm((l-1)*l+m,n,np,ma,lg-1)
                                if (lg .gt. 1) s6m = ri(l+l-1) * flm((l-1)*l+m,n,np,ma,-lg+1)
                            endif
                            if (m .gt. 1) then
                                s2m = ri(l+l-1) * flm((l-1)*l-m+2,n,np,ma,lg-1)
                                if (lg .gt. 1) s6 = ri(l+l-1) * flm((l-1)*l-m+2,n,np,ma,-lg+1)
                            endif
                            if (m .lt. l-1) then
                                s4 = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l+m+2,n,np,ma,lg-1)
                                s4m = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l-m,n,np,ma,lg-1)
                                if (lg .gt. 1) then
                                    s8 = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l-m,n,np,ma,-lg+1)
                                    s8m = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l+m+2,n,np,ma,-lg+1)
                                endif
                            endif
                        endif
                        sxpp = 2.d0 * xb * flm(l*l+l+m+1,n,np,ma,lg-1)
                        sxnp = 2.d0 * xb * flm(l*l+l-m+1,n,np,ma,lg-1)
                        if (lg .gt. 1) then
                            sxpn = 2.d0 * xb * flm(l*l+l+m+1,n,np,ma,-lg+1)
                            sxnn = 2.d0 * xb * flm(l*l+l-m+1,n,np,ma,-lg+1)
                        endif
                        if (m .gt. 0) then
                            flm(l*l+l-m+1,n,np,ma,lg) = aux * (umdltm1*umdltm0*(-s1m+s2m) + s3m - s4m - sxnp &
                                    - updltm1*umdltm0*(-s5m+s6m) + s7m - s8m)
                            flm(l*l+l-m+1,n,np,ma,-lg) = aux * (updltm1*umdltm0*(-s1+s2) - s3 + s4 &
                                    + umdltm1*umdltm0*(-s5+s6) + s7 - s8 - sxnn )
                        endif
                        flm(l*l+l+m+1,n,np,ma,lg) = aux*(updltm1*umdltm0*(-s1+s2) +s3 -s4 - sxpp - umdltm1*umdltm0*(s5-s6) &
                                - s7 + s8 )
                        flm(l*l+l+m+1,n,np,ma,-lg)=aux*(umdltm1*umdltm0*(s1m-s2m) + s3m -s4m &
                                + updltm1 * umdltm0 * (-s5m+s6m)+s7m-s8m-sxpn)
                    enddo     ! End of Do on m
                enddo     ! End of Do on l

!            elements with   -lg < M < lg
                do mm = -lg+1, lg-1
                    bux = ri(lg-abs(mm))
                    if (lg-1-abs(mm) .le. 0) then
                        cux = 0.d0
                        lcux = .false.
                    else
                        cux = bux * re(lg+abs(mm)-1)
                        lcux = .true.
                    endif
                    do l  = 0, lmaxaux
                        do m  = 0, l
                            s1 = re(l+m+1) * ri(l+l+3) * r2  * flm((l+3)*l+m+3,n,np,ma,mm)
                            s1m = re(l+m+1) * ri(l+l+3) * r2 * flm((l+3)*l-m+3,n,np,ma,mm)
                            s2 = 0.d0
                            s2m = 0.d0
                            if (m .lt. l) then
                                s2 = re(l-m) * ri(l+l-1)  * flm((l-1)*(l-1)+l+m,n,np,ma,mm)
                                s2m = re(l-m) * ri(l+l-1)  * flm((l-1)*(l-1)+l-m,n,np,ma,mm)
                            endif
                            if (m .gt. 0) then
                                flmaux(l*l+l-m+1) = bux * aux2 * (s1m+s2m - zb * flm(l*l+l-m+1,n,np,ma,mm) )
                                if (lcux) flmaux(l*l+l-m+1) = flmaux(l*l+l-m+1) - cux * flm(l*l+l-m+1,n,np+1,ma,mm)
                            endif
                            flmaux(l*l+l+m+1) = bux * aux2 * (s1+s2 - zb * flm(l*l+l+m+1,n,np,ma,mm) )
                            if (lcux) flmaux(l*l+l+m+1) = flmaux(l*l+l+m+1) - cux * flm(l*l+l+m+1,n,np+1,ma,mm)
                        enddo     ! End of Do on m
                    enddo     ! End of Do on l
                    do l  = 0, lmaxaux
                        flm(l*l+l+1,n,np,ma,mm) = flmaux(l*l+l+1)
                        do m  = 1, l
                            flm(l*l+l+m+1,n,np,ma,mm) = flmaux(l*l+l+m+1)
                            flm(l*l+l-m+1,n,np,ma,mm) = flmaux(l*l+l-m+1)
                        enddo     ! End of Do on m
                    enddo     ! End of Do on l
                enddo     ! End of Do on mm
            enddo     ! End of Do on ma

            if (lg .eq. lb) exit

!           recurre los factores con  np > 1

            if (lg .gt. 1) then
                lgg = lg
                do np  = 2, min(lb,lg,lb+1-lg)
                    lgg = lgg - 1
                    aux = re(lgg+lgg-1) * 0.5d0
                    aux2 = aux + aux
                    lmaxaux = lmax-lg+1-np
                    do ma = -la, la

!                    elements with M = lgg  y  M = -lgg
                        do l  = 0, lmaxaux
                            do m  = 0, l
                                s1 = 0.d0
                                s2 = 0.d0
                                s3 = 0.d0
                                s4 = 0.d0
                                s5 = 0.d0
                                s6 = 0.d0
                                s7 = 0.d0
                                s8 = 0.d0
                                sxpp = 0.d0      ! xb * f(l,m,n,L,M,n',L',L')
                                sxnp = 0.d0      ! xb * f(l,-m,n,L,M,n',L',L')
                                s1m = 0.d0
                                s2m = 0.d0
                                s3m = 0.d0
                                s4m = 0.d0
                                s5m = 0.d0
                                s6m = 0.d0
                                s7m = 0.d0
                                s8m = 0.d0
                                sxpn = 0.d0      ! xb * f(l,m,n,L,M,n',L',-L')
                                sxnn = 0.d0      ! xb * f(l,-m,n,L,M,n',L',-L')
                                umdltm0 = 1.d0               ! umdltm0 = 1 - delta(m,0)
                                updltm1 = 1.d0               ! updltm1 = 1 + delta(m,1)
                                umdltm1 = 1.d0               ! umdltm1 = 1 - delta(m,1)
                                if (m .eq. 0) umdltm0 = 0.d0
                                if (m .eq. 1) then
                                    umdltm1 = 0.d0
                                    updltm1 = 2.d0
                                endif
                                if (m .gt. 0) then
                                    s1 = r2 * ri(l+l+3) * flm((l+3)*l+m+2,n,np,ma,lgg-1)
                                    s1m = r2 * ri(l+l+3) * flm((l+3)*l-m+4,n,np,ma,lgg-1)
                                endif
                                if (lgg .gt. 1) then
                                    s5 = r2 * ri(l+l+3) * flm((l+3)*l-m+4,n,np,ma,-lgg+1)
                                    s5m = r2 * ri(l+l+3) * flm((l+3)*l+m+2,n,np,ma,-lgg+1)
                                    s7 = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l-m+2,n,np,ma,-lgg+1)
                                    s7m = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l+m+4,n,np,ma,-lgg+1)
                                endif
                                s3 = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l+m+4,n,np,ma,lgg-1)
                                s3m = re(l+m+1) * re(l+m+2) * r2 * ri(l+l+3) * flm((l+3)*l-m+2,n,np,ma,lgg-1)
                                if (l .gt. 0) then
                                    if (m .gt. 0) then
                                        s2 = ri(l+l-1) * flm((l-1)*l+m,n,np,ma,lgg-1)
                                        if (lgg .gt. 1) then
                                            s6m = ri(l+l-1) * flm((l-1)*l+m,n,np,ma,-lgg+1)
                                        endif
                                    endif
                                    if (m .gt. 1) then
                                        s2m = ri(l+l-1) * flm((l-1)*l-m+2,n,np,ma,lgg-1)
                                        if (lgg .gt. 1) then
                                            s6 = ri(l+l-1) * flm((l-1)*l-m+2,n,np,ma,-lgg+1)
                                        endif
                                    endif
                                    if (m .lt. l-1) then
                                        s4 = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l+m+2,n,np,ma,lgg-1)
                                        s4m = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l-m,n,np,ma,lgg-1)
                                        if (lgg .gt. 1) then
                                            s8 = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l-m,n,np,ma,-lgg+1)
                                            s8m = re(l-m) * re(l-m-1) * ri(l+l-1) * flm((l-1)*l+m+2,n,np,ma,-lgg+1)
                                        endif
                                    endif
                                endif
                                sxpp = 2.d0 * xb * flm(l*l+l+m+1,n,np,ma,lgg-1)
                                sxnp = 2.d0 * xb * flm(l*l+l-m+1,n,np,ma,lgg-1)
                                if (lgg .gt. 1) then
                                    sxpn = 2.d0 * xb * flm(l*l+l+m+1,n,np,ma,-lgg+1)
                                    sxnn = 2.d0 * xb * flm(l*l+l-m+1,n,np,ma,-lgg+1)
                                endif
                                if (m .gt. 0) then
                                    flm(l*l+l-m+1,n,np,ma,lgg) = aux   * (umdltm1 * umdltm0 * (-s1m+s2m) + s3m - s4m &
                                            - sxnp - updltm1*umdltm0*(-s5m+s6m) + s7m - s8m )
                                    flm(l*l+l-m+1,n,np,ma,-lgg) = aux  * (updltm1*umdltm0*(-s1+s2) - s3 + s4 &
                                            + umdltm1*umdltm0*(-s5+s6) + s7 - s8 - sxnn )
                                endif
                                flm(l*l+l+m+1,n,np,ma,lgg) = aux*(updltm1*umdltm0*(-s1+s2) + s3 - s4 - sxpp &
                                        - umdltm1*umdltm0*(s5-s6) - s7 + s8 )
                                flm(l*l+l+m+1,n,np,ma,-lgg) = aux *(umdltm1*umdltm0*(s1m-s2m) + s3m - s4m &
                                        + updltm1*umdltm0*(-s5m+s6m) + s7m - s8m - sxpn)
                            enddo     ! End of Do on m
                        enddo     ! End of Do on l

!                    elements with   -lgg < M < lgg
                        do mm = -lgg+1, lgg-1
                            bux = ri(lgg-abs(mm))
                            if (lgg-1-abs(mm) .le. 0) then
                                cux = 0.d0
                                lcux = .false.
                            else
                                cux = bux * re(lgg+abs(mm)-1)
                                lcux = .true.
                            endif
                            do l  = 0, lmaxaux
                                do m  = 0, l
                                    s1 = re(l+m+1) * ri(l+l+3) * r2 * flm((l+3)*l+m+3,n,np,ma,mm)
                                    s1m = re(l+m+1) * ri(l+l+3) * r2 * flm((l+3)*l-m+3,n,np,ma,mm)
                                    s2 = 0.d0
                                    s2m = 0.d0
                                    if (m .lt. l) then
                                        s2 = re(l-m) * ri(l+l-1) * flm((l-1)*(l-1)+l+m,n,np,ma,mm)
                                        s2m = re(l-m) * ri(l+l-1) * flm((l-1)*(l-1)+l-m,n,np,ma,mm)
                                    endif
                                    if (m .gt. 0) then
                                        flmaux(l*l+l-m+1) = bux * aux2 * (s1m+s2m - zb * flm(l*l+l-m+1,n,np,ma,mm) )
                                        if (lcux) flmaux(l*l+l-m+1) = flmaux(l*l+l-m+1)- cux*flm(l*l+l-m+1,n,np+1,ma,mm)
                                    endif
                                    flmaux(l*l+l+m+1) = bux * aux2 * (s1+s2 - zb * flm(l*l+l+m+1,n,np,ma,mm) )
                                    if (lcux) flmaux(l*l+l+m+1) = flmaux(l*l+l+m+1) - cux * flm(l*l+l+m+1,n,np+1,ma,mm)
                                enddo     ! End of Do on m
                            enddo     ! End of Do on l
                            do l  = 0, lmaxaux
                                flm(l*l+l+1,n,np,ma,mm) = flmaux(l*l+l+1)
                                do m  = 1, l
                                    flm(l*l+l+m+1,n,np,ma,mm) = flmaux(l*l+l+m+1)
                                    flm(l*l+l-m+1,n,np,ma,mm) = flmaux(l*l+l-m+1)
                                enddo     ! End of Do on m
                            enddo     ! End of Do on l
                        enddo     ! End of Do on mm
                    enddo     ! End of Do on ma
                enddo     ! End of Do on np
            endif     ! End of  if (lg .gt. 1)
        enddo     ! End of Do on lg
    endif

    lmax = lmax - lb
    do mb = -lb, lb
        do ma = -la, la
            knt = 0
            do l = 0, lmax
                do m = -l, l
                    knt = knt + 1
                    flmmamb(knt,ma,mb) = flm(knt,1,1,ma,mb)
                enddo
            enddo
        enddo
    enddo
    return
    end subroutine recurflm
!
!   ***************************************************************
! 
!      Subroutine for tabulating regular spherical harmonics of (x,y=0,z), 
! 
!      zlm(l,m) = zlm(l,m,x,y=0,z)
!
!      Only stored for m .ge. 0  since the remaining ones are null because y = 0
! 
!      indices (l,m) contracted to a single one:
!          lm = l(l+1)+m      lm = 0, 1, 2, ... (lexpansion+1)2-1
!
  subroutine armonicosij(lmax, x, z, zlma)
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: l, lmax, m
    real(KREAL) :: zlma((lmax+1)*(lmax+2)/2)
    real(KREAL) :: rra, rra2, x, xxa, z, zza

    xxa = x
    zza = z
    rra2 = xxa*xxa+zza*zza
    rra = sqrt(rra2)
    zlma(1) = 1.d0
    if (lmax .eq. 0) return
    zlma(2) = zza
    zlma(3) = xxa
    do l = 1, lmax-1
        zlma(ind(l+2)) = re(l+l+1) * xxa*zlma(ind(l+1))  ! element  zlma(l+1,l+1) = re(l+l+1)*(xxa*zlma(l,l)-yya*zlma(l,-l))
        zlma(ind(l+2)-1) = re(l+l+1) * zza * zlma(ind(l+1))  ! element    zlma(l+1,l)=re(l+l+1)*zza*zlma(l,l)
        do m = 0, l-1   !elements    zlma(l+1,m)=(re(l+l+1)*zza*zlma(l,m) - (l+m)*rra2*zlma(l-1,m)) * ri(l-m+1)
            zlma(ind(l+1)+m+1) = (re(l+l+1) * zza * zlma(ind(l)+m+1) - re(l+m) * rra2 * zlma(ind(l-1)+m+1) ) / re(l-m+1)
        enddo
    enddo
    return
    end subroutine armonicosij
!     
!     ---------------------------------------------------------------------------------
!
!    Polynomials P_k^(LML'M')(0,0,1) of the shift-operators technique in the axis alligned system:
!
  subroutine subpolP001(la, lb)
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: ierr, k, k12, kntpol, l, la, lb, lk, llp, lm, lmp, lp, m, md, mp, ms, naux
    real(KREAL) :: aux, bux, sd, ss, suma, xa, ya, za

    kntpol = 0
    do l = 0, la
        do lp = 0, min(l, lb)
            ipntpolP(l,lp) = kntpol+1
            k12 = indk12(l*(l+1)+1,lp*(lp+1)+1)
            ss = ssv(0,0)
            aux = uno
            do k = 0, lp
                suma = cero
                do lk = k, min(l,lp)
                    suma = suma + fact(lk) * facts(l+lp-lk) * ss * app(l+lp-lk-lk, k12) * facti(lk-k) * factsi(l+lp-lk-k)
                enddo
                kntpol = kntpol+1
                polP(kntpol) = aux * suma
                aux = (aux+aux) * ri(k+1)
            enddo
            bux = dos
            do mp = 1, min(l, lb)
                k12 = indk12(l*(l+1)+mp+1,lp*(lp+1)+mp+1)
                sd = sdv(mp,mp)
                aux = bux
                do k = mp, lp
                    suma = cero
                    do lk = k, min(l,lp)
                        suma = suma + fact(lk) * facts(l+lp-lk) * sd * bpp(l+lp-lk-lk, k12) &
                                 * facti(lk-k) * factsi(l+lp-lk-k)
                    enddo
                    kntpol = kntpol+1
                    polP(kntpol) = aux * suma
                    aux = (aux+aux) * ri(k+1)
                enddo
                bux = (bux+bux) * ri(mp+1)
            enddo
        enddo
    enddo
    return
    end
!
!    -------------------------------------------------------------------------------------------------------
!
  subroutine totalchargeGTO
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: i, i1, i2, ia, ib, ierr, ii, ishift, j, la, lb, ldmrot, m, nfa, nfb, nga1, nga2, ngb1, ngb2
    real(KREAL) :: charge, cosal, cosbet, cosga, rab, rna, rnab, rnb, sinal, sinbet, singa, xab, xy, yab, zab
    real(KREAL) :: roaux(-mxl:mxl,-mxl:mxl)
    allocate(sol(0:mxl), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating sol. Stop')
    allocate(rl(-mxl:mxl,-mxl:mxl,0:mxl), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating rl. Stop')
    allocate(dl(-mxl:mxl,-mxl:mxl,0:mxl), stat = ierr)
    if (ierr .ne. 0) call error(ierr,'Memory error when allocating dl. Stop')
    charge = cero
    do ia = 1, ncen
        nga1 = ngini(ia)
        if (nga1 .le. 0) cycle
        nga2 = ngfin(ia)
        do i1 = nga1, nga2
            la = ll(i1)
            rna= rnor(i1)
            nfa = nf(i1)
            do i2 = nga1, nga2
                lb = ll(i2)
                rnb = rnor(i2)
                nfb = nf(i2)
                call gaussoverlap(i1, i2, cero)
                do m = -min(la,lb), min(la,lb)
                    charge = charge + rna * rnb * dmat(nfa+la+m,nfb+lb+m) * sol(abs(m))
                enddo
            enddo
        enddo
        if (lzdo) cycle
        do ib = 1, ncen
            if (ia .eq. ib .or. ngini(ib) .le. 0) cycle
!    Computes Euler angles and rotation matrices from the AB aligned axis system to the molecular system and conversely
            xab = rcen(1,ib) - rcen(1,ia)
            yab = rcen(2,ib) - rcen(2,ia)
            zab = rcen(3,ib) - rcen(3,ia)
            xy = sqrt(xab*xab + yab*yab)
            rab = sqrt(xab*xab + yab*yab + zab*zab)
            if (rab .lt. 1.d-10) then
                write(6,"('Centers ',i4,' and ',i4,' coincide. Stop')") ia, ib
                call error(1,' Stop')
            endif
            if (xy .gt. 1.d-10) then
                sinal = yab / xy
                cosal = xab / xy
            else
                sinal = cero
                cosal = uno
            endif
            sinbet = xy / rab
            cosbet = zab / rab
            singa = cero
            cosga = uno
            ldmrot = max(lmaxc(ia),lmaxc(ib))
            call rotar (ldmrot, cosal, sinal, cosbet, sinbet, cosga, singa)
            ngb1 = ngini(ib)
            ngb2 = ngfin(ib)
            do i1 = nga1, nga2
                la = ll(i1)
                rna= rnor(i1)
                nfa = nf(i1)
                do i2 = ngb1, ngb2
                    lb = ll(i2)
                    rnb = rnor(i2)
                    nfb = nf(i2)
!    Reads the pertinent block of density matrix and rotates it to the AB aligned system. Loads the result in array roblk.
!    Angular normalization factors are introduced at the end of the loading process.
                    do i = -la, la
                        ishift = i+la+nfa
                        do j = -lb, lb
                            roblk(i,j) = dmat(ishift,j+lb+nfb)
                        enddo
                    enddo
!    Rotation on center B
                    do i = -la, la
                        do j = -lb, lb
                            roaux(i,j) = dot_product(roblk(i,-lb:lb),rl(-lb:lb,j,lb))
                        enddo
                    enddo
!    Rotation on center A
                    do i = -la, la
                        do j = -lb, lb
                            roblk(i,j) =  dot_product(roaux(-la:la,j), rl(-la:la,i,la))
                        enddo
                    enddo
                    call gaussoverlap(i1, i2, rab)
                    do m = -min(la,lb), min(la,lb)
                        charge = charge + rna * rnb * roblk(m,m) * sol(abs(m))
                    enddo
                enddo
            enddo
        enddo
    enddo
    if (lzdo) then
        write(6,"(/'Total valence electron charge computed from density matrix = ', e22.15,/)") -charge
    else
        write(6,"(/'Total electron charge computed from density matrix = ', e22.15,/)") -charge
    endif
    deallocate(dl, rl, sol)
    return
    end
!
!    -------------------------------------------------------------------------------------------------------
!
  subroutine gaussoverlap(i1, i2, R)
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: i1, i1ini, i1fin, i1p, i2, i2ini, i2fin, i2p, k, kmax, knt, l, la, lb, m, maxl, minl, nprimi, nprimj
    real(KREAL) :: aux, R, z
    real(KREAL) :: rpw(0:mxldst), sumk, xiabinv, xikv(0:mxl)
    la = ll(i1)
    lb = ll(i2)
    nprimi = nprimit(i1)
    nprimj = nprimit(i2)
    i1ini = ipntprim(i1)
    i2ini = ipntprim(i2)
    if (i1ini .le. 0 .or. i2ini .le. 0) return
    i1fin = ipntprim(i1)+nprimi-1
    i2fin = ipntprim(i2)+nprimj-1
    Rpw(0) = uno
    do l = 1, la+lb
        Rpw(l) = Rpw(l-1) * R
    enddo
    sol = cero
    do i2p = i2ini, i2fin
        do i1p = i1ini, i1fin
            xiabinv = uno / (xxg(i1p)+xxg(i2p))
            xikv(0) = uno
            do l = 1, min(la,lb)
                    xikv(l) = -umed * xikv(l-1) * (xxg(i1p)+xxg(i2p)) / (xxg(i1p)*xxg(i2p))
            enddo
            maxl = max(la, lb)
            minl = min(la, lb)
            knt = ipntpolP(maxl,minl)
            if (xxg(i1p)*xxg(i2p)*R*R*xiabinv .gt. 100.d0) cycle
            aux = cfcontr(i2p) * cfcontr(i1p) * (-xxg(i1p))**lb * xxg(i2p)**la * sqrt(pi)**3 &
                     * exp(-xxg(i1p)*xxg(i2p)*R*R*xiabinv)* sqrt(xiabinv)**(2*(la+lb)+3)
            do m = 0, min(la,lb)
                sumk = cero
                do k = m, min(la,lb)
                    sumk = sumk + Rpw(la+lb-k-k) * xikv(k) * polP(knt)
                    knt = knt + 1
                enddo
                sol(m) = sol(m) + aux * sumk
            enddo
        enddo
    enddo
    do m = 0, min(la,lb)
        sol(m) = sol(m) * ang(ind(la)+abs(m)+1) * ang(ind(lb)+abs(m)+1)
    enddo
    return
    end

!   ***************************************************************
!
!    Subroutine sort: sorts the primitives of a contraction in ascending exponents 

   subroutine sort(nprim, xsort)
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: i, iux, j, nprim
    real(KREAL) :: aux
    integer(KINT), parameter :: mxsteps = 1000
    real(KREAL) :: xsort(*)
    logical :: lend
    do i = 1, nprim
        isort(i) = i
    enddo
    do i = 1, mxsteps
        lend = .true.
        do j = nprim, 2, -2
            if (xsort(j) .lt. xsort(j-1)) then
                aux = xsort(j)
                xsort(j) = xsort(j-1)
                xsort(j-1) = aux
                iux = isort(j)
                isort(j) = isort(j-1)
                isort(j-1) = iux
                lend = .false.
            endif
        enddo
        do j = nprim-1, 2, -2
            if (xsort(j) .lt. xsort(j-1)) then
                aux = xsort(j)
                xsort(j) = xsort(j-1)
                xsort(j-1) = aux
                iux = isort(j)
                isort(j) = isort(j-1)
                isort(j-1) = iux
                lend = .false.
            endif
        enddo
        if (lend) return
    enddo
    write(6,"('Error in subroutine sort. Highest number of steps (',i4,') exceeded')") mxsteps
    call error(1,'Stop.')
    return
    end
!
!    -------------------------------------------------------------------------------------------------------
!
  subroutine error(ierr, msg)
    USE Zernike_Jacobi_GTO_D
    implicit none
    integer(KINT) :: ierr
    character(*) :: msg
    write(6,"(a)") msg
    write(6,"('Error code = ', i4)") ierr
    stop
    end
